
BootstrapMethod:
Firma: (n_resamples=9999, batch=None, random_state=None, method='BCa', *, rng=None)

Docstring:
Configuration information for a bootstrap confidence interval.

Instances of this class can be passed into the `method` parameter of some
confidence interval methods to generate a bootstrap confidence interval.

Attributes
----------
n_resamples : int, optional
    The number of resamples to perform. Default is 9999.
batch : int, optional
    The number of resamples to process in each vectorized call to
    the statistic. Batch sizes >>1 tend to be faster when the statistic
    is vectorized, but memory usage scales linearly with the batch size.
    Default is ``None``, which processes all resamples in a single batch.
rng : `numpy.random.Generator`, optional
    Pseudorandom number generator used to perform resampling.

    If `rng` is passed by keyword to the initializer or the `rng` attribute is used
    directly, types other than `numpy.random.Generator` are passed to
    `numpy.random.default_rng` to instantiate a ``Generator``  before use.
    If `rng` is already a ``Generator`` instance, then the provided instance is
    used. Specify `rng` for repeatable behavior.

    If this argument is passed by position, if `random_state` is passed by keyword
    into the initializer, or if the `random_state` attribute is used directly,
    legacy behavior for `random_state` applies:

    - If `random_state` is None (or `numpy.random`), the `numpy.random.RandomState`
      singleton is used.
    - If `random_state` is an int, a new ``RandomState`` instance is used,
      seeded with `random_state`.
    - If `random_state` is already a ``Generator`` or ``RandomState`` instance then
      that instance is used.

    .. versionchanged:: 1.15.0

        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this attribute name was changed from
        `random_state` to `rng`. For an interim period, both names will continue to
        work, although only one may be specified at a time. After the interim
        period, uses of `random_state` will emit warnings. The behavior of both
        `random_state` and `rng` are outlined above, but only `rng` should be used
        in new code.

method : {'BCa', 'percentile', 'basic'}
    Whether to use the 'percentile' bootstrap ('percentile'), the 'basic'
    (AKA 'reverse') bootstrap ('basic'), or the bias-corrected and
    accelerated bootstrap ('BCa', default).
================================================================================

CensoredData:
Firma: (uncensored=None, *, left=None, right=None, interval=None)

Docstring:
Instances of this class represent censored data.

Instances may be passed to the ``fit`` method of continuous
univariate SciPy distributions for maximum likelihood estimation.
The *only* method of the univariate continuous distributions that
understands `CensoredData` is the ``fit`` method.  An instance of
`CensoredData` can not be passed to methods such as ``pdf`` and
``cdf``.

An observation is said to be *censored* when the precise value is unknown,
but it has a known upper and/or lower bound.  The conventional terminology
is:

* left-censored: an observation is below a certain value but it is
  unknown by how much.
* right-censored: an observation is above a certain value but it is
  unknown by how much.
* interval-censored: an observation lies somewhere on an interval between
  two values.

Left-, right-, and interval-censored data can be represented by
`CensoredData`.

For convenience, the class methods ``left_censored`` and
``right_censored`` are provided to create a `CensoredData`
instance from a single one-dimensional array of measurements
and a corresponding boolean array to indicate which measurements
are censored.  The class method ``interval_censored`` accepts two
one-dimensional arrays that hold the lower and upper bounds of the
intervals.

Parameters
----------
uncensored : array_like, 1D
    Uncensored observations.
left : array_like, 1D
    Left-censored observations.
right : array_like, 1D
    Right-censored observations.
interval : array_like, 2D, with shape (m, 2)
    Interval-censored observations.  Each row ``interval[k, :]``
    represents the interval for the kth interval-censored observation.

Notes
-----
In the input array `interval`, the lower bound of the interval may
be ``-inf``, and the upper bound may be ``inf``, but at least one must be
finite. When the lower bound is ``-inf``, the row represents a left-
censored observation, and when the upper bound is ``inf``, the row
represents a right-censored observation.  If the length of an interval
is 0 (i.e. ``interval[k, 0] == interval[k, 1]``, the observation is
treated as uncensored.  So one can represent all the types of censored
and uncensored data in ``interval``, but it is generally more convenient
to use `uncensored`, `left` and `right` for uncensored, left-censored and
right-censored observations, respectively.

Examples
--------
In the most general case, a censored data set may contain values that
are left-censored, right-censored, interval-censored, and uncensored.
For example, here we create a data set with five observations.  Two
are uncensored (values 1 and 1.5), one is a left-censored observation
of 0, one is a right-censored observation of 10 and one is
interval-censored in the interval [2, 3].

>>> import numpy as np
>>> from scipy.stats import CensoredData
>>> data = CensoredData(uncensored=[1, 1.5], left=[0], right=[10],
...                     interval=[[2, 3]])
>>> print(data)
CensoredData(5 values: 2 not censored, 1 left-censored,
1 right-censored, 1 interval-censored)

Equivalently,

>>> data = CensoredData(interval=[[1, 1],
...                               [1.5, 1.5],
...                               [-np.inf, 0],
...                               [10, np.inf],
...                               [2, 3]])
>>> print(data)
CensoredData(5 values: 2 not censored, 1 left-censored,
1 right-censored, 1 interval-censored)

A common case is to have a mix of uncensored observations and censored
observations that are all right-censored (or all left-censored). For
example, consider an experiment in which six devices are started at
various times and left running until they fail.  Assume that time is
measured in hours, and the experiment is stopped after 30 hours, even
if all the devices have not failed by that time.  We might end up with
data such as this::

    Device  Start-time  Fail-time  Time-to-failure
       1         0         13           13
       2         2         24           22
       3         5         22           17
       4         8         23           15
       5        10        ***          >20
       6        12        ***          >18

Two of the devices had not failed when the experiment was stopped;
the observations of the time-to-failure for these two devices are
right-censored.  We can represent this data with

>>> data = CensoredData(uncensored=[13, 22, 17, 15], right=[20, 18])
>>> print(data)
CensoredData(6 values: 4 not censored, 2 right-censored)

Alternatively, we can use the method `CensoredData.right_censored` to
create a representation of this data.  The time-to-failure observations
are put the list ``ttf``.  The ``censored`` list indicates which values
in ``ttf`` are censored.

>>> ttf = [13, 22, 17, 15, 20, 18]
>>> censored = [False, False, False, False, True, True]

Pass these lists to `CensoredData.right_censored` to create an
instance of `CensoredData`.

>>> data = CensoredData.right_censored(ttf, censored)
>>> print(data)
CensoredData(6 values: 4 not censored, 2 right-censored)

If the input data is interval censored and already stored in two
arrays, one holding the low end of the intervals and another
holding the high ends, the class method ``interval_censored`` can
be used to create the `CensoredData` instance.

This example creates an instance with four interval-censored values.
The intervals are [10, 11], [0.5, 1], [2, 3], and [12.5, 13.5].

>>> a = [10, 0.5, 2, 12.5]  # Low ends of the intervals
>>> b = [11, 1.0, 3, 13.5]  # High ends of the intervals
>>> data = CensoredData.interval_censored(low=a, high=b)
>>> print(data)
CensoredData(4 values: 0 not censored, 4 interval-censored)

Finally, we create and censor some data from the `weibull_min`
distribution, and then fit `weibull_min` to that data. We'll assume
that the location parameter is known to be 0.

>>> from scipy.stats import weibull_min
>>> rng = np.random.default_rng()

Create the random data set.

>>> x = weibull_min.rvs(2.5, loc=0, scale=30, size=250, random_state=rng)
>>> x[x > 40] = 40  # Right-censor values greater or equal to 40.

Create the `CensoredData` instance with the `right_censored` method.
The censored values are those where the value is 40.

>>> data = CensoredData.right_censored(x, x == 40)
>>> print(data)
CensoredData(250 values: 215 not censored, 35 right-censored)

35 values have been right-censored.

Fit `weibull_min` to the censored data.  We expect to shape and scale
to be approximately 2.5 and 30, respectively.

>>> weibull_min.fit(data, floc=0)
(2.3575922823897315, 0, 30.40650074451254)
================================================================================

ConstantInputWarning:
Firma: (msg=None)

Docstring:
Warns when all values in data are exactly equal.
================================================================================

Covariance:
Firma: ()

Docstring:
Representation of a covariance matrix

Calculations involving covariance matrices (e.g. data whitening,
multivariate normal function evaluation) are often performed more
efficiently using a decomposition of the covariance matrix instead of the
covariance matrix itself. This class allows the user to construct an
object representing a covariance matrix using any of several
decompositions and perform calculations using a common interface.

.. note::

    The `Covariance` class cannot be instantiated directly. Instead, use
    one of the factory methods (e.g. `Covariance.from_diagonal`).

Examples
--------
The `Covariance` class is used by calling one of its
factory methods to create a `Covariance` object, then pass that
representation of the `Covariance` matrix as a shape parameter of a
multivariate distribution.

For instance, the multivariate normal distribution can accept an array
representing a covariance matrix:

>>> from scipy import stats
>>> import numpy as np
>>> d = [1, 2, 3]
>>> A = np.diag(d)  # a diagonal covariance matrix
>>> x = [4, -2, 5]  # a point of interest
>>> dist = stats.multivariate_normal(mean=[0, 0, 0], cov=A)
>>> dist.pdf(x)
4.9595685102808205e-08

but the calculations are performed in a very generic way that does not
take advantage of any special properties of the covariance matrix. Because
our covariance matrix is diagonal, we can use ``Covariance.from_diagonal``
to create an object representing the covariance matrix, and
`multivariate_normal` can use this to compute the probability density
function more efficiently.

>>> cov = stats.Covariance.from_diagonal(d)
>>> dist = stats.multivariate_normal(mean=[0, 0, 0], cov=cov)
>>> dist.pdf(x)
4.9595685102808205e-08
================================================================================

DegenerateDataWarning:
Firma: (msg=None)

Docstring:
Warns when data is degenerate and results may not be reliable.
================================================================================

FitError:
Firma: (msg=None)

Docstring:
Represents an error condition when fitting a distribution to data.
================================================================================

Mixture:
Firma: (components, *, weights=None)

Docstring:
Representation of a mixture distribution.

A mixture distribution is the distribution of a random variable
defined in the following way: first, a random variable is selected
from `components` according to the probabilities given by `weights`, then
the selected random variable is realized.

Parameters
----------
components : sequence of `ContinuousDistribution`
    The underlying instances of `ContinuousDistribution`.
    All must have scalar shape parameters (if any); e.g., the `pdf` evaluated
    at a scalar argument must return a scalar.
weights : sequence of floats, optional
    The corresponding probabilities of selecting each random variable.
    Must be non-negative and sum to one. The default behavior is to weight
    all components equally.

Attributes
----------
components : sequence of `ContinuousDistribution`
    The underlying instances of `ContinuousDistribution`.
weights : ndarray
    The corresponding probabilities of selecting each random variable.

Methods
-------
support

sample

moment

mean
median
mode

variance
standard_deviation

skewness
kurtosis

pdf
logpdf

cdf
icdf
ccdf
iccdf

logcdf
ilogcdf
logccdf
ilogccdf

entropy

Notes
-----
The following abbreviations are used throughout the documentation.

- PDF: probability density function
- CDF: cumulative distribution function
- CCDF: complementary CDF
- entropy: differential entropy
- log-*F*: logarithm of *F* (e.g. log-CDF)
- inverse *F*: inverse function of *F* (e.g. inverse CDF)

References
----------
.. [1] Mixture distribution, *Wikipedia*,
       https://en.wikipedia.org/wiki/Mixture_distribution
================================================================================

MonteCarloMethod:
Firma: (n_resamples=9999, batch=None, rvs=None, rng=None)

Docstring:
Configuration information for a Monte Carlo hypothesis test.

Instances of this class can be passed into the `method` parameter of some
hypothesis test functions to perform a Monte Carlo version of the
hypothesis tests.

Attributes
----------
n_resamples : int, optional
    The number of Monte Carlo samples to draw. Default is 9999.
batch : int, optional
    The number of Monte Carlo samples to process in each vectorized call to
    the statistic. Batch sizes >>1 tend to be faster when the statistic
    is vectorized, but memory usage scales linearly with the batch size.
    Default is ``None``, which processes all samples in a single batch.
rvs : callable or tuple of callables, optional
    A callable or sequence of callables that generates random variates
    under the null hypothesis. Each element of `rvs` must be a callable
    that accepts keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and
    returns an N-d array sample of that shape. If `rvs` is a sequence, the
    number of callables in `rvs` must match the number of samples passed
    to the hypothesis test in which the `MonteCarloMethod` is used. Default
    is ``None``, in which case the hypothesis test function chooses values
    to match the standard version of the hypothesis test. For example,
    the null hypothesis of `scipy.stats.pearsonr` is typically that the
    samples are drawn from the standard normal distribution, so
    ``rvs = (rng.normal, rng.normal)`` where
    ``rng = np.random.default_rng()``.
rng : `numpy.random.Generator`, optional
    Pseudorandom number generator state. When `rng` is None, a new
    `numpy.random.Generator` is created using entropy from the
    operating system. Types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.
================================================================================

NearConstantInputWarning:
Firma: (msg=None)

Docstring:
Warns when all values in data are nearly equal.
================================================================================

Normal:
Firma: (mu=None, sigma=None, **kwargs)

Docstring:
Normal distribution with prescribed mean and standard deviation.

The probability density function of the normal distribution is:

.. math::

    f(x) = \frac{1}{\sigma \sqrt{2 \pi}} \exp {
        \left( -\frac{1}{2}\left( \frac{x - \mu}{\sigma} \right)^2 \right)}

for :math:`x` in (-\infty, \infty).
This class accepts one parameterization:
`mu` for :math:`\mu \in (-\infty, \infty)`, `sigma` for :math:`\sigma \in (0, \infty)`.


Parameters
----------
tol : positive float, optional
    The desired relative tolerance of calculations. Left unspecified,
    calculations may be faster; when provided, calculations may be
    more likely to meet the desired accuracy.
validation_policy : {None, "skip_all"}
    Specifies the level of input validation to perform. Left unspecified,
    input validation is performed to ensure appropriate behavior in edge
    case (e.g. parameters out of domain, argument outside of distribution
    support, etc.) and improve consistency of output dtype, shape, etc.
    Pass ``'skip_all'`` to avoid the computational overhead of these
    checks when rough edges are acceptable.
cache_policy : {None, "no_cache"}
    Specifies the extent to which intermediate results are cached. Left
    unspecified, intermediate results of some calculations (e.g. distribution
    support, moments, etc.) are cached to improve performance of future
    calculations. Pass ``'no_cache'`` to reduce memory reserved by the class
    instance.

Attributes
----------
All parameters are available as attributes.

Methods
-------
support
plot
sample
moment
mean
median
mode
variance
standard_deviation
skewness
kurtosis
pdf
logpdf
cdf
icdf
ccdf
iccdf
logcdf
ilogcdf
logccdf
ilogccdf
entropy
logentropy

See Also
--------

:ref:`rv_infrastructure`
    Tutorial


Notes
-----
The following abbreviations are used throughout the documentation.

- PDF: probability density function
- CDF: cumulative distribution function
- CCDF: complementary CDF
- entropy: differential entropy
- log-*F*: logarithm of *F* (e.g. log-CDF)
- inverse *F*: inverse function of *F* (e.g. inverse CDF)

The API documentation is written to describe the API, not to serve as
a statistical reference. Effort is made to be correct at the level
required to use the functionality, not to be mathematically rigorous.
For example, continuity and differentiability may be implicitly assumed.
For precise mathematical definitions, consult your preferred mathematical
text.

Examples
--------
To use the distribution class, it must be instantiated using keyword
parameters corresponding with one of the accepted parameterizations.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> from scipy.stats import Normal
>>> X = Normal(mu=-0.81, sigma=0.69)

For convenience, the ``plot`` method can be used to visualize the density
and other functions of the distribution.

>>> X.plot()
>>> plt.show()

The support of the underlying distribution is available using the ``support``
method.

>>> X.support()
(np.float64(-inf), np.float64(inf))

The numerical values of parameters associated with all parameterizations
are available as attributes.

>>> X.mu, X.sigma
(np.float64(-0.81), np.float64(0.69))

To evaluate the probability density function of the underlying distribution
at argument ``x=-1.13``:

>>> x = -1.13
>>> X.pdf(x)
0.5192263911374636

The cumulative distribution function, its complement, and the logarithm
of these functions are evaluated similarly.

>>> np.allclose(np.exp(X.logccdf(x)), 1 - X.cdf(x))
True

The inverse of these functions with respect to the argument ``x`` is also
available.

>>> logp = np.log(1 - X.ccdf(x))
>>> np.allclose(X.ilogcdf(logp), x)
True

Note that distribution functions and their logarithms also have two-argument
versions for working with the probability mass between two arguments. The
result tends to be more accurate than the naive implementation because it avoids
subtractive cancellation.

>>> y = -0.56
>>> np.allclose(X.ccdf(x, y), 1 - (X.cdf(y) - X.cdf(x)))
True

There are methods for computing measures of central tendency,
dispersion, higher moments, and entropy.

>>> X.mean(), X.median(), X.mode()
(np.float64(-0.81), np.float64(-0.81), np.float64(-0.81))
>>> X.variance(), X.standard_deviation()
(np.float64(0.4760999999999999), np.float64(0.69))
>>> X.skewness(), X.kurtosis()
(np.float64(0.0), np.float64(3.0))
>>> np.allclose(X.moment(order=6, kind='standardized'),
...             X.moment(order=6, kind='central') / X.variance()**3)
True
>>> np.allclose(np.exp(X.logentropy()), X.entropy())
True

Pseudo-random samples can be drawn from
the underlying distribution using ``sample``.

>>> X.sample(shape=(4,))
array([-0.64466808,  0.2974767 , -0.14478395, -0.83549689])  # may vary
================================================================================

PermutationMethod:
Firma: (n_resamples=9999, batch=None, random_state=None, *, rng=None)

Docstring:
Configuration information for a permutation hypothesis test.

Instances of this class can be passed into the `method` parameter of some
hypothesis test functions to perform a permutation version of the
hypothesis tests.

Attributes
----------
n_resamples : int, optional
    The number of resamples to perform. Default is 9999.
batch : int, optional
    The number of resamples to process in each vectorized call to
    the statistic. Batch sizes >>1 tend to be faster when the statistic
    is vectorized, but memory usage scales linearly with the batch size.
    Default is ``None``, which processes all resamples in a single batch.
rng : `numpy.random.Generator`, optional
    Pseudorandom number generator used to perform resampling.

    If `rng` is passed by keyword to the initializer or the `rng` attribute is used
    directly, types other than `numpy.random.Generator` are passed to
    `numpy.random.default_rng` to instantiate a ``Generator`` before use.
    If `rng` is already a ``Generator`` instance, then the provided instance is
    used. Specify `rng` for repeatable behavior.

    If this argument is passed by position, if `random_state` is passed by keyword
    into the initializer, or if the `random_state` attribute is used directly,
    legacy behavior for `random_state` applies:

    - If `random_state` is None (or `numpy.random`), the `numpy.random.RandomState`
      singleton is used.
    - If `random_state` is an int, a new ``RandomState`` instance is used,
      seeded with `random_state`.
    - If `random_state` is already a ``Generator`` or ``RandomState`` instance then
      that instance is used.

    .. versionchanged:: 1.15.0

        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this attribute name was changed from
        `random_state` to `rng`. For an interim period, both names will continue to
        work, although only one may be specified at a time. After the interim
        period, uses of `random_state` will emit warnings. The behavior of both
        `random_state` and `rng` are outlined above, but only `rng` should be used
        in new code.
================================================================================

Uniform:
Firma: (*, a=None, b=None, **kwargs)

Docstring:
Uniform distribution.

The probability density function of the uniform distribution is:

.. math::

    f(x; a, b) = \frac{1}
                      {b - a}

for :math:`x` in [a, b].
This class accepts one parameterization:
`a` for :math:`a \in (-\infty, \infty)`, `b` for :math:`b \in (a, \infty)`.


Parameters
----------
tol : positive float, optional
    The desired relative tolerance of calculations. Left unspecified,
    calculations may be faster; when provided, calculations may be
    more likely to meet the desired accuracy.
validation_policy : {None, "skip_all"}
    Specifies the level of input validation to perform. Left unspecified,
    input validation is performed to ensure appropriate behavior in edge
    case (e.g. parameters out of domain, argument outside of distribution
    support, etc.) and improve consistency of output dtype, shape, etc.
    Pass ``'skip_all'`` to avoid the computational overhead of these
    checks when rough edges are acceptable.
cache_policy : {None, "no_cache"}
    Specifies the extent to which intermediate results are cached. Left
    unspecified, intermediate results of some calculations (e.g. distribution
    support, moments, etc.) are cached to improve performance of future
    calculations. Pass ``'no_cache'`` to reduce memory reserved by the class
    instance.

Attributes
----------
All parameters are available as attributes.

Methods
-------
support
plot
sample
moment
mean
median
mode
variance
standard_deviation
skewness
kurtosis
pdf
logpdf
cdf
icdf
ccdf
iccdf
logcdf
ilogcdf
logccdf
ilogccdf
entropy
logentropy

See Also
--------

:ref:`rv_infrastructure`
    Tutorial


Notes
-----
The following abbreviations are used throughout the documentation.

- PDF: probability density function
- CDF: cumulative distribution function
- CCDF: complementary CDF
- entropy: differential entropy
- log-*F*: logarithm of *F* (e.g. log-CDF)
- inverse *F*: inverse function of *F* (e.g. inverse CDF)

The API documentation is written to describe the API, not to serve as
a statistical reference. Effort is made to be correct at the level
required to use the functionality, not to be mathematically rigorous.
For example, continuity and differentiability may be implicitly assumed.
For precise mathematical definitions, consult your preferred mathematical
text.

Examples
--------
To use the distribution class, it must be instantiated using keyword
parameters corresponding with one of the accepted parameterizations.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> from scipy.stats import Uniform
>>> X = Uniform(a=0.09, b=188.73)

For convenience, the ``plot`` method can be used to visualize the density
and other functions of the distribution.

>>> X.plot()
>>> plt.show()

The support of the underlying distribution is available using the ``support``
method.

>>> X.support()
(np.float64(0.09), np.float64(188.73))

The numerical values of parameters associated with all parameterizations
are available as attributes.

>>> X.a, X.b, X.ab
(np.float64(0.09), np.float64(188.73), np.float64(188.64))

To evaluate the probability density function of the underlying distribution
at argument ``x=60.45``:

>>> x = 60.45
>>> X.pdf(x)
0.005301102629346905

The cumulative distribution function, its complement, and the logarithm
of these functions are evaluated similarly.

>>> np.allclose(np.exp(X.logccdf(x)), 1 - X.cdf(x))
True

The inverse of these functions with respect to the argument ``x`` is also
available.

>>> logp = np.log(1 - X.ccdf(x))
>>> np.allclose(X.ilogcdf(logp), x)
True

Note that distribution functions and their logarithms also have two-argument
versions for working with the probability mass between two arguments. The
result tends to be more accurate than the naive implementation because it avoids
subtractive cancellation.

>>> y = 120.82
>>> np.allclose(X.ccdf(x, y), 1 - (X.cdf(y) - X.cdf(x)))
True

There are methods for computing measures of central tendency,
dispersion, higher moments, and entropy.

>>> X.mean(), X.median(), X.mode()
(np.float64(94.41), np.float64(94.41), np.float64(94.41))
>>> X.variance(), X.standard_deviation()
(np.float64(2965.4208), np.float64(54.4556773899655))
>>> X.skewness(), X.kurtosis()
(np.float64(1.4418186690070737e-15), np.float64(1.7999999999999878))
>>> np.allclose(X.moment(order=6, kind='standardized'),
...             X.moment(order=6, kind='central') / X.variance()**3)
True
>>> np.allclose(np.exp(X.logentropy()), X.entropy())
True

Pseudo-random samples can be drawn from
the underlying distribution using ``sample``.

>>> X.sample(shape=(4,))
array([183.12313638,  55.13240458, 134.96072977, 106.55867002])  # may vary
================================================================================

abs:
Firma: (X, /)

Docstring:
Absolute value of a random variable

Parameters
----------
X : `ContinuousDistribution`
    The random variable :math:`X`.

Returns
-------
Y : `ContinuousDistribution`
    A random variable :math:`Y = |X|`.

Examples
--------
Suppose we have a normally distributed random variable :math:`X`:

>>> import numpy as np
>>> from scipy import stats
>>> X = stats.Normal()

We wish to have a random variable :math:`Y` distributed according to
the folded normal distribution; that is, a random variable :math:`|X|`.

>>> Y = stats.abs(X)

The PDF of the distribution in the left half plane is "folded" over to
the right half plane. Because the normal PDF is symmetric, the resulting
PDF is zero for negative arguments and doubled for positive arguments.

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(0, 5, 300)
>>> ax = plt.gca()
>>> Y.plot(x='x', y='pdf', t=('x', -1, 5), ax=ax)
>>> plt.plot(x, 2 * X.pdf(x), '--')
>>> plt.legend(('PDF of `Y`', 'Doubled PDF of `X`'))
>>> plt.show()
================================================================================

alexandergovern:
Firma: (*samples, nan_policy='propagate', axis=0, keepdims=False)

Docstring:
Performs the Alexander Govern test.

The Alexander-Govern approximation tests the equality of k independent
means in the face of heterogeneity of variance. The test is applied to
samples from two or more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.  There must be at least
    two samples, and each sample must contain at least two observations.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : AlexanderGovernResult
    An object with attributes:
    
    statistic : float
        The computed A statistic of the test.
    pvalue : float
        The associated p-value from the chi-squared distribution.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if an input is a constant array.  The statistic is not defined
    in this case, so ``np.nan`` is returned.

See Also
--------

:func:`f_oneway`
    one-way ANOVA


Notes
-----
The use of this test relies on several assumptions.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. Unlike `f_oneway`, this test does not assume on homoscedasticity,
   instead relaxing the assumption of equal variances.

Input samples must be finite, one dimensional, and with size greater than
one.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Alexander, Ralph A., and Diane M. Govern. "A New and Simpler
       Approximation for ANOVA under Variance Heterogeneity." Journal
       of Educational Statistics, vol. 19, no. 2, 1994, pp. 91-101.
       JSTOR, www.jstor.org/stable/1165140. Accessed 12 Sept. 2020.

Examples
--------
>>> from scipy.stats import alexandergovern

Here are some data on annual percentage rate of interest charged on
new car loans at nine of the largest banks in four American cities
taken from the National Institute of Standards and Technology's
ANOVA dataset.

We use `alexandergovern` to test the null hypothesis that all cities
have the same mean APR against the alternative that the cities do not
all have the same mean APR. We decide that a significance level of 5%
is required to reject the null hypothesis in favor of the alternative.

>>> atlanta = [13.75, 13.75, 13.5, 13.5, 13.0, 13.0, 13.0, 12.75, 12.5]
>>> chicago = [14.25, 13.0, 12.75, 12.5, 12.5, 12.4, 12.3, 11.9, 11.9]
>>> houston = [14.0, 14.0, 13.51, 13.5, 13.5, 13.25, 13.0, 12.5, 12.5]
>>> memphis = [15.0, 14.0, 13.75, 13.59, 13.25, 12.97, 12.5, 12.25,
...           11.89]
>>> alexandergovern(atlanta, chicago, houston, memphis)
AlexanderGovernResult(statistic=4.65087071883494,
                      pvalue=0.19922132490385214)

The p-value is 0.1992, indicating a nearly 20% chance of observing
such an extreme value of the test statistic under the null hypothesis.
This exceeds 5%, so we do not reject the null hypothesis in favor of
the alternative.
================================================================================

alpha:
Firma: (*args, **kwds)

Docstring:
An alpha continuous random variable.

As an instance of the `rv_continuous` class, `alpha` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `alpha` ([1]_, [2]_) is:

.. math::

    f(x, a) = \frac{1}{x^2 \Phi(a) \sqrt{2\pi}} *
              \exp(-\frac{1}{2} (a-1/x)^2)

where :math:`\Phi` is the normal CDF, :math:`x > 0`, and :math:`a > 0`.

`alpha` takes ``a`` as a shape parameter.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``alpha.pdf(x, a, loc, scale)`` is identically
equivalent to ``alpha.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Johnson, Kotz, and Balakrishnan, "Continuous Univariate
       Distributions, Volume 1", Second Edition, John Wiley and Sons,
       p. 173 (1994).
.. [2] Anthony A. Salvia, "Reliability applications of the Alpha
       Distribution", IEEE Transactions on Reliability, Vol. R-34,
       No. 3, pp. 251-252 (1985).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import alpha
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 3.57
>>> mean, var, skew, kurt = alpha.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(alpha.ppf(0.01, a),
...                 alpha.ppf(0.99, a), 100)
>>> ax.plot(x, alpha.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='alpha pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = alpha(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = alpha.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], alpha.cdf(vals, a))
True

Generate random numbers:

>>> r = alpha.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

anderson:
Firma: (x, dist='norm')

Docstring:
Anderson-Darling test for data coming from a particular distribution.

The Anderson-Darling test tests the null hypothesis that a sample is
drawn from a population that follows a particular distribution.
For the Anderson-Darling test, the critical values depend on
which distribution is being tested against.  This function works
for normal, exponential, logistic, weibull_min, or Gumbel (Extreme Value
Type I) distributions.

Parameters
----------
x : array_like
    Array of sample data.
dist : {'norm', 'expon', 'logistic', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1', 'weibull_min'}, optional
    The type of distribution to test against.  The default is 'norm'.
    The names 'extreme1', 'gumbel_l' and 'gumbel' are synonyms for the
    same distribution.

Returns
-------
result : AndersonResult
    An object with the following attributes:

    statistic : float
        The Anderson-Darling test statistic.
    critical_values : list
        The critical values for this distribution.
    significance_level : list
        The significance levels for the corresponding critical values
        in percents.  The function returns critical values for a
        differing set of significance levels depending on the
        distribution that is being tested against.
    fit_result : `~scipy.stats._result_classes.FitResult`
        An object containing the results of fitting the distribution to
        the data.

See Also
--------
kstest : The Kolmogorov-Smirnov test for goodness-of-fit.

Notes
-----
Critical values provided are for the following significance levels:

normal/exponential
    15%, 10%, 5%, 2.5%, 1%
logistic
    25%, 10%, 5%, 2.5%, 1%, 0.5%
gumbel_l / gumbel_r
    25%, 10%, 5%, 2.5%, 1%
weibull_min
    50%, 25%, 15%, 10%, 5%, 2.5%, 1%, 0.5%

If the returned statistic is larger than these critical values then
for the corresponding significance level, the null hypothesis that
the data come from the chosen distribution can be rejected.
The returned statistic is referred to as 'A2' in the references.

For `weibull_min`, maximum likelihood estimation is known to be
challenging. If the test returns successfully, then the first order
conditions for a maximum likelihood estimate have been verified and
the critical values correspond relatively well to the significance levels,
provided that the sample is sufficiently large (>10 observations [7]).
However, for some data - especially data with no left tail - `anderson`
is likely to result in an error message. In this case, consider
performing a custom goodness of fit test using
`scipy.stats.monte_carlo_test`.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and
       Some Comparisons, Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit
       Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,
       pp. 357-369.
.. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value
       Distribution, Biometrika, Vol. 64, pp. 583-588.
.. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference
       to Tests for Exponentiality , Technical Report No. 262,
       Department of Statistics, Stanford University, Stanford, CA.
.. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution
       Based on the Empirical Distribution Function, Biometrika, Vol. 66,
       pp. 591-595.
.. [7] Richard A. Lockhart and Michael A. Stephens "Estimation and Tests of
       Fit for the Three-Parameter Weibull Distribution"
       Journal of the Royal Statistical Society.Series B(Methodological)
       Vol. 56, No. 3 (1994), pp. 491-500, Table 0.

Examples
--------
Test the null hypothesis that a random sample was drawn from a normal
distribution (with unspecified mean and standard deviation).

>>> import numpy as np
>>> from scipy.stats import anderson
>>> rng = np.random.default_rng()
>>> data = rng.random(size=35)
>>> res = anderson(data)
>>> res.statistic
0.8398018749744764
>>> res.critical_values
array([0.527, 0.6  , 0.719, 0.839, 0.998])
>>> res.significance_level
array([15. , 10. ,  5. ,  2.5,  1. ])

The value of the statistic (barely) exceeds the critical value associated
with a significance level of 2.5%, so the null hypothesis may be rejected
at a significance level of 2.5%, but not at a significance level of 1%.
================================================================================

anderson_ksamp:
Firma: (samples, midrank=True, *, method=None)

Docstring:
The Anderson-Darling test for k-samples.

The k-sample Anderson-Darling test is a modification of the
one-sample Anderson-Darling test. It tests the null hypothesis
that k-samples are drawn from the same population without having
to specify the distribution function of that population. The
critical values depend on the number of samples.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample data in arrays.
midrank : bool, optional
    Type of Anderson-Darling test which is computed. Default
    (True) is the midrank test applicable to continuous and
    discrete populations. If False, the right side empirical
    distribution is used.
method : PermutationMethod, optional
    Defines the method used to compute the p-value. If `method` is an
    instance of `PermutationMethod`, the p-value is computed using
    `scipy.stats.permutation_test` with the provided configuration options
    and other appropriate settings. Otherwise, the p-value is interpolated
    from tabulated values.

Returns
-------
res : Anderson_ksampResult
    An object containing attributes:

    statistic : float
        Normalized k-sample Anderson-Darling test statistic.
    critical_values : array
        The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%,
        0.5%, 0.1%.
    pvalue : float
        The approximate p-value of the test. If `method` is not
        provided, the value is floored / capped at 0.1% / 25%.

Raises
------
ValueError
    If fewer than 2 samples are provided, a sample is empty, or no
    distinct observations are in the samples.

See Also
--------
ks_2samp : 2 sample Kolmogorov-Smirnov test
anderson : 1 sample Anderson-Darling test

Notes
-----
[1]_ defines three versions of the k-sample Anderson-Darling test:
one for continuous distributions and two for discrete
distributions, in which ties between samples may occur. The
default of this routine is to compute the version based on the
midrank empirical distribution function. This test is applicable
to continuous and discrete data. If midrank is set to False, the
right side empirical distribution is used for a test for discrete
data. According to [1]_, the two discrete test statistics differ
only slightly if a few collisions due to round-off errors occur in
the test not adjusted for ties between samples.

The critical values corresponding to the significance levels from 0.01
to 0.25 are taken from [1]_. p-values are floored / capped
at 0.1% / 25%. Since the range of critical values might be extended in
future releases, it is recommended not to test ``p == 0.25``, but rather
``p >= 0.25`` (analogously for the lower bound).

.. versionadded:: 0.14.0

References
----------
.. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample
       Anderson-Darling Tests, Journal of the American Statistical
       Association, Vol. 82, pp. 918-924.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> res = stats.anderson_ksamp([rng.normal(size=50),
... rng.normal(loc=0.5, size=30)])
>>> res.statistic, res.pvalue
(1.974403288713695, 0.04991293614572478)
>>> res.critical_values
array([0.325, 1.226, 1.961, 2.718, 3.752, 4.592, 6.546])

The null hypothesis that the two random samples come from the same
distribution can be rejected at the 5% level because the returned
test value is greater than the critical value for 5% (1.961) but
not at the 2.5% level. The interpolation gives an approximate
p-value of 4.99%.

>>> samples = [rng.normal(size=50), rng.normal(size=30),
...            rng.normal(size=20)]
>>> res = stats.anderson_ksamp(samples)
>>> res.statistic, res.pvalue
(-0.29103725200789504, 0.25)
>>> res.critical_values
array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856,
  4.07210043, 5.56419101])

The null hypothesis cannot be rejected for three samples from an
identical distribution. The reported p-value (25%) has been capped and
may not be very accurate (since it corresponds to the value 0.449
whereas the statistic is -0.291).

In such cases where the p-value is capped or when sample sizes are
small, a permutation test may be more accurate.

>>> method = stats.PermutationMethod(n_resamples=9999, random_state=rng)
>>> res = stats.anderson_ksamp(samples, method=method)
>>> res.pvalue
0.5254
================================================================================

anglit:
Firma: (*args, **kwds)

Docstring:
An anglit continuous random variable.

As an instance of the `rv_continuous` class, `anglit` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `anglit` is:

.. math::

    f(x) = \sin(2x + \pi/2) = \cos(2x)

for :math:`-\pi/4 \le x \le \pi/4`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``anglit.pdf(x, loc, scale)`` is identically
equivalent to ``anglit.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import anglit
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = anglit.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(anglit.ppf(0.01),
...                 anglit.ppf(0.99), 100)
>>> ax.plot(x, anglit.pdf(x),
...        'r-', lw=5, alpha=0.6, label='anglit pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = anglit()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = anglit.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], anglit.cdf(vals))
True

Generate random numbers:

>>> r = anglit.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

ansari:
Firma: (x, y, alternative='two-sided', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform the Ansari-Bradley test for equal scale parameters.

The Ansari-Bradley test ([1]_, [2]_) is a non-parametric test
for the equality of the scale parameter of the distributions
from which two samples were drawn. The null hypothesis states that
the ratio of the scale of the distribution underlying `x` to the scale
of the distribution underlying `y` is 1.

Parameters
----------
x, y : array_like
    Arrays of sample data.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:
    
    * 'two-sided': the ratio of scales is not equal to 1.
    * 'less': the ratio of scales is less than 1.
    * 'greater': the ratio of scales is greater than 1.
    
    .. versionadded:: 1.7.0
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The Ansari-Bradley test statistic.
pvalue : float
    The p-value of the hypothesis test.

See Also
--------

:func:`fligner`
    A non-parametric test for the equality of k variances
:func:`mood`
    A non-parametric test for the equality of two scale parameters


Notes
-----
The p-value given is exact when the sample sizes are both less than
55 and there are no ties, otherwise a normal approximation for the
p-value is used.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Ansari, A. R. and Bradley, R. A. (1960) Rank-sum tests for
       dispersions, Annals of Mathematical Statistics, 31, 1174-1189.
.. [2] Sprent, Peter and N.C. Smeeton.  Applied nonparametric
       statistical methods.  3rd ed. Chapman and Hall/CRC. 2001.
       Section 5.8.2.
.. [3] Nathaniel E. Helwig "Nonparametric Dispersion and Equality
       Tests" at http://users.stat.umn.edu/~helwig/notes/npde-Notes.pdf

Examples
--------
>>> import numpy as np
>>> from scipy.stats import ansari
>>> rng = np.random.default_rng()

For these examples, we'll create three random data sets.  The first
two, with sizes 35 and 25, are drawn from a normal distribution with
mean 0 and standard deviation 2.  The third data set has size 25 and
is drawn from a normal distribution with standard deviation 1.25.

>>> x1 = rng.normal(loc=0, scale=2, size=35)
>>> x2 = rng.normal(loc=0, scale=2, size=25)
>>> x3 = rng.normal(loc=0, scale=1.25, size=25)

First we apply `ansari` to `x1` and `x2`.  These samples are drawn
from the same distribution, so we expect the Ansari-Bradley test
should not lead us to conclude that the scales of the distributions
are different.

>>> ansari(x1, x2)
AnsariResult(statistic=541.0, pvalue=0.9762532927399098)

With a p-value close to 1, we cannot conclude that there is a
significant difference in the scales (as expected).

Now apply the test to `x1` and `x3`:

>>> ansari(x1, x3)
AnsariResult(statistic=425.0, pvalue=0.0003087020407974518)

The probability of observing such an extreme value of the statistic
under the null hypothesis of equal scales is only 0.03087%. We take this
as evidence against the null hypothesis in favor of the alternative:
the scales of the distributions from which the samples were drawn
are not equal.

We can use the `alternative` parameter to perform a one-tailed test.
In the above example, the scale of `x1` is greater than `x3` and so
the ratio of scales of `x1` and `x3` is greater than 1. This means
that the p-value when ``alternative='greater'`` should be near 0 and
hence we should be able to reject the null hypothesis:

>>> ansari(x1, x3, alternative='greater')
AnsariResult(statistic=425.0, pvalue=0.0001543510203987259)

As we can see, the p-value is indeed quite low. Use of
``alternative='less'`` should thus yield a large p-value:

>>> ansari(x1, x3, alternative='less')
AnsariResult(statistic=425.0, pvalue=0.9998643258449039)
================================================================================

arcsine:
Firma: (*args, **kwds)

Docstring:
An arcsine continuous random variable.

As an instance of the `rv_continuous` class, `arcsine` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `arcsine` is:

.. math::

    f(x) = \frac{1}{\pi \sqrt{x (1-x)}}

for :math:`0 < x < 1`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``arcsine.pdf(x, loc, scale)`` is identically
equivalent to ``arcsine.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import arcsine
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = arcsine.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(arcsine.ppf(0.01),
...                 arcsine.ppf(0.99), 100)
>>> ax.plot(x, arcsine.pdf(x),
...        'r-', lw=5, alpha=0.6, label='arcsine pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = arcsine()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = arcsine.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], arcsine.cdf(vals))
True

Generate random numbers:

>>> r = arcsine.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

argus:
Firma: (*args, **kwds)

Docstring:
Argus distribution

As an instance of the `rv_continuous` class, `argus` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(chi, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, chi, loc=0, scale=1)
    Probability density function.
logpdf(x, chi, loc=0, scale=1)
    Log of the probability density function.
cdf(x, chi, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, chi, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, chi, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, chi, loc=0, scale=1)
    Log of the survival function.
ppf(q, chi, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, chi, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, chi, loc=0, scale=1)
    Non-central moment of the specified order.
stats(chi, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(chi, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(chi,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(chi, loc=0, scale=1)
    Median of the distribution.
mean(chi, loc=0, scale=1)
    Mean of the distribution.
var(chi, loc=0, scale=1)
    Variance of the distribution.
std(chi, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, chi, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `argus` is:

.. math::

    f(x, \chi) = \frac{\chi^3}{\sqrt{2\pi} \Psi(\chi)} x \sqrt{1-x^2}
                 \exp(-\chi^2 (1 - x^2)/2)

for :math:`0 < x < 1` and :math:`\chi > 0`, where

.. math::

    \Psi(\chi) = \Phi(\chi) - \chi \phi(\chi) - 1/2

with :math:`\Phi` and :math:`\phi` being the CDF and PDF of a standard
normal distribution, respectively.

`argus` takes :math:`\chi` as shape a parameter. Details about sampling
from the ARGUS distribution can be found in [2]_.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``argus.pdf(x, chi, loc, scale)`` is identically
equivalent to ``argus.pdf(y, chi) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] "ARGUS distribution",
       https://en.wikipedia.org/wiki/ARGUS_distribution
.. [2] Christoph Baumgarten "Random variate generation by fast numerical
       inversion in the varying parameter case." Research in Statistics,
       vol. 1, 2023, doi:10.1080/27684520.2023.2279060.

.. versionadded:: 0.19.0

Examples
--------
>>> import numpy as np
>>> from scipy.stats import argus
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> chi = 1
>>> mean, var, skew, kurt = argus.stats(chi, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(argus.ppf(0.01, chi),
...                 argus.ppf(0.99, chi), 100)
>>> ax.plot(x, argus.pdf(x, chi),
...        'r-', lw=5, alpha=0.6, label='argus pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = argus(chi)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = argus.ppf([0.001, 0.5, 0.999], chi)
>>> np.allclose([0.001, 0.5, 0.999], argus.cdf(vals, chi))
True

Generate random numbers:

>>> r = argus.rvs(chi, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

barnard_exact:
Firma: (table, alternative='two-sided', pooled=True, n=32)

Docstring:
Perform a Barnard exact test on a 2x2 contingency table.

Parameters
----------
table : array_like of ints
    A 2x2 contingency table.  Elements should be non-negative integers.

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes section below.

pooled : bool, optional
    Whether to compute score statistic with pooled variance (as in
    Student's t-test, for example) or unpooled variance (as in Welch's
    t-test). Default is ``True``.

n : int, optional
    Number of sampling points used in the construction of the sampling
    method. Note that this argument will automatically be converted to
    the next higher power of 2 since `scipy.stats.qmc.Sobol` is used to
    select sample points. Default is 32. Must be positive. In most cases,
    32 points is enough to reach good precision. More points comes at
    performance cost.

Returns
-------
ber : BarnardExactResult
    A result object with the following attributes.

    statistic : float
        The Wald statistic with pooled or unpooled variance, depending
        on the user choice of `pooled`.

    pvalue : float
        P-value, the probability of obtaining a distribution at least as
        extreme as the one that was actually observed, assuming that the
        null hypothesis is true.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.
fisher_exact : Fisher exact test on a 2x2 contingency table.
boschloo_exact : Boschloo's exact test on a 2x2 contingency table,
    which is an uniformly more powerful alternative to Fisher's exact test.

Notes
-----
Barnard's test is an exact test used in the analysis of contingency
tables. It examines the association of two categorical variables, and
is a more powerful alternative than Fisher's exact test
for 2x2 contingency tables.

Let's define :math:`X_0` a 2x2 matrix representing the observed sample,
where each column stores the binomial experiment, as in the example
below. Let's also define :math:`p_1, p_2` the theoretical binomial
probabilities for  :math:`x_{11}` and :math:`x_{12}`. When using
Barnard exact test, we can assert three different null hypotheses :

- :math:`H_0 : p_1 \geq p_2` versus :math:`H_1 : p_1 < p_2`,
  with `alternative` = "less"

- :math:`H_0 : p_1 \leq p_2` versus :math:`H_1 : p_1 > p_2`,
  with `alternative` = "greater"

- :math:`H_0 : p_1 = p_2` versus :math:`H_1 : p_1 \neq p_2`,
  with `alternative` = "two-sided" (default one)

In order to compute Barnard's exact test, we are using the Wald
statistic [3]_ with pooled or unpooled variance.
Under the default assumption that both variances are equal
(``pooled = True``), the statistic is computed as:

.. math::

    T(X) = \frac{
        \hat{p}_1 - \hat{p}_2
    }{
        \sqrt{
            \hat{p}(1 - \hat{p})
            (\frac{1}{c_1} +
            \frac{1}{c_2})
        }
    }

with :math:`\hat{p}_1, \hat{p}_2` and :math:`\hat{p}` the estimator of
:math:`p_1, p_2` and :math:`p`, the latter being the combined probability,
given the assumption that :math:`p_1 = p_2`.

If this assumption is invalid (``pooled = False``), the statistic is:

.. math::

    T(X) = \frac{
        \hat{p}_1 - \hat{p}_2
    }{
        \sqrt{
            \frac{\hat{p}_1 (1 - \hat{p}_1)}{c_1} +
            \frac{\hat{p}_2 (1 - \hat{p}_2)}{c_2}
        }
    }

The p-value is then computed as:

.. math::

    \sum
        \binom{c_1}{x_{11}}
        \binom{c_2}{x_{12}}
        \pi^{x_{11} + x_{12}}
        (1 - \pi)^{t - x_{11} - x_{12}}

where the sum is over all  2x2 contingency tables :math:`X` such that:
* :math:`T(X) \leq T(X_0)` when `alternative` = "less",
* :math:`T(X) \geq T(X_0)` when `alternative` = "greater", or
* :math:`T(X) \geq |T(X_0)|` when `alternative` = "two-sided".
Above, :math:`c_1, c_2` are the sum of the columns 1 and 2,
and :math:`t` the total (sum of the 4 sample's element).

The returned p-value is the maximum p-value taken over the nuisance
parameter :math:`\pi`, where :math:`0 \leq \pi \leq 1`.

This function's complexity is :math:`O(n c_1 c_2)`, where `n` is the
number of sample points.

References
----------
.. [1] Barnard, G. A. "Significance Tests for 2x2 Tables". *Biometrika*.
       34.1/2 (1947): 123-138. :doi:`dpgkg3`

.. [2] Mehta, Cyrus R., and Pralay Senchaudhuri. "Conditional versus
       unconditional exact tests for comparing two binomials."
       *Cytel Software Corporation* 675 (2003): 1-5.

.. [3] "Wald Test". *Wikipedia*. https://en.wikipedia.org/wiki/Wald_test

Examples
--------
An example use of Barnard's test is presented in [2]_.

    Consider the following example of a vaccine efficacy study
    (Chan, 1998). In a randomized clinical trial of 30 subjects, 15 were
    inoculated with a recombinant DNA influenza vaccine and the 15 were
    inoculated with a placebo. Twelve of the 15 subjects in the placebo
    group (80%) eventually became infected with influenza whereas for the
    vaccine group, only 7 of the 15 subjects (47%) became infected. The
    data are tabulated as a 2 x 2 table::

            Vaccine  Placebo
        Yes     7        12
        No      8        3

When working with statistical hypothesis testing, we usually use a
threshold probability or significance level upon which we decide
to reject the null hypothesis :math:`H_0`. Suppose we choose the common
significance level of 5%.

Our alternative hypothesis is that the vaccine will lower the chance of
becoming infected with the virus; that is, the probability :math:`p_1` of
catching the virus with the vaccine will be *less than* the probability
:math:`p_2` of catching the virus without the vaccine.  Therefore, we call
`barnard_exact` with the ``alternative="less"`` option:

>>> import scipy.stats as stats
>>> res = stats.barnard_exact([[7, 12], [8, 3]], alternative="less")
>>> res.statistic
-1.894
>>> res.pvalue
0.03407

Under the null hypothesis that the vaccine will not lower the chance of
becoming infected, the probability of obtaining test results at least as
extreme as the observed data is approximately 3.4%. Since this p-value is
less than our chosen significance level, we have evidence to reject
:math:`H_0` in favor of the alternative.

Suppose we had used Fisher's exact test instead:

>>> _, pvalue = stats.fisher_exact([[7, 12], [8, 3]], alternative="less")
>>> pvalue
0.0640

With the same threshold significance of 5%, we would not have been able
to reject the null hypothesis in favor of the alternative. As stated in
[2]_, Barnard's test is uniformly more powerful than Fisher's exact test
because Barnard's test does not condition on any margin. Fisher's test
should only be used when both sets of marginals are fixed.
================================================================================

bartlett:
Firma: (*samples, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform Bartlett's test for equal variances.

Bartlett's test tests the null hypothesis that all input samples
are from populations with equal variances.  For samples
from significantly non-normal populations, Levene's test
`levene` is more robust.

Parameters
----------
sample1, sample2, ... : array_like
    arrays of sample data.  Only 1d arrays are accepted, they may have
    different lengths.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value of the test.

See Also
--------

:func:`fligner`
    A non-parametric test for the equality of k variances
:func:`levene`
    A robust parametric test for equality of k variances
:ref:`hypothesis_bartlett`
    Extended example


Notes
-----
Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power
([3]_).

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1]  https://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm
.. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical
          Methods, Eighth Edition, Iowa State University Press.
.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
.. [4] Bartlett, M. S. (1937). Properties of Sufficiency and Statistical
       Tests. Proceedings of the Royal Society of London. Series A,
       Mathematical and Physical Sciences, Vol. 160, No.901, pp. 268-282.

Examples
--------
Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

>>> import numpy as np
>>> from scipy import stats
>>> a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
>>> b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
>>> c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
>>> stat, p = stats.bartlett(a, b, c)
>>> p
1.1254782518834628e-05

The very small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

>>> [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]

For a more detailed example, see :ref:`hypothesis_bartlett`.
================================================================================

bayes_mvs:
Firma: (data, alpha=0.9)

Docstring:
Bayesian confidence intervals for the mean, var, and std.

Parameters
----------
data : array_like
    Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
    Requires 2 or more data points.
alpha : float, optional
    Probability that the returned confidence interval contains
    the true parameter.

Returns
-------
mean_cntr, var_cntr, std_cntr : tuple
    The three results are for the mean, variance and standard deviation,
    respectively.  Each result is a tuple of the form::

        (center, (lower, upper))

    with ``center`` the mean of the conditional pdf of the value given the
    data, and ``(lower, upper)`` a confidence interval, centered on the
    median, containing the estimate to a probability ``alpha``.

See Also
--------
mvsdist

Notes
-----
Each tuple of mean, variance, and standard deviation estimates represent
the (center, (lower, upper)) with center the mean of the conditional pdf
of the value given the data and (lower, upper) is a confidence interval
centered on the median, containing the estimate to a probability
``alpha``.

Converts data to 1-D and assumes all data has the same mean and variance.
Uses Jeffrey's prior for variance and std.

Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``

References
----------
T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
2006.

Examples
--------
First a basic example to demonstrate the outputs:

>>> from scipy import stats
>>> data = [6, 9, 12, 7, 8, 8, 13]
>>> mean, var, std = stats.bayes_mvs(data)
>>> mean
Mean(statistic=9.0, minmax=(7.103650222612533, 10.896349777387467))
>>> var
Variance(statistic=10.0, minmax=(3.176724206, 24.45910382))
>>> std
Std_dev(statistic=2.9724954732045084,
        minmax=(1.7823367265645143, 4.945614605014631))

Now we generate some normally distributed random data, and get estimates of
mean and standard deviation with 95% confidence intervals for those
estimates:

>>> n_samples = 100000
>>> data = stats.norm.rvs(size=n_samples)
>>> res_mean, res_var, res_std = stats.bayes_mvs(data, alpha=0.95)

>>> import matplotlib.pyplot as plt
>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.hist(data, bins=100, density=True, label='Histogram of data')
>>> ax.vlines(res_mean.statistic, 0, 0.5, colors='r', label='Estimated mean')
>>> ax.axvspan(res_mean.minmax[0],res_mean.minmax[1], facecolor='r',
...            alpha=0.2, label=r'Estimated mean (95% limits)')
>>> ax.vlines(res_std.statistic, 0, 0.5, colors='g', label='Estimated scale')
>>> ax.axvspan(res_std.minmax[0],res_std.minmax[1], facecolor='g', alpha=0.2,
...            label=r'Estimated scale (95% limits)')

>>> ax.legend(fontsize=10)
>>> ax.set_xlim([-4, 4])
>>> ax.set_ylim([0, 0.5])
>>> plt.show()
================================================================================

bernoulli:
Firma: (*args, **kwds)

Docstring:
A Bernoulli discrete random variable.

As an instance of the `rv_discrete` class, `bernoulli` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, p, loc=0)
    Probability mass function.
logpmf(k, p, loc=0)
    Log of the probability mass function.
cdf(k, p, loc=0)
    Cumulative distribution function.
logcdf(k, p, loc=0)
    Log of the cumulative distribution function.
sf(k, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, p, loc=0)
    Log of the survival function.
ppf(q, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(p,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, loc=0)
    Median of the distribution.
mean(p, loc=0)
    Mean of the distribution.
var(p, loc=0)
    Variance of the distribution.
std(p, loc=0)
    Standard deviation of the distribution.
interval(confidence, p, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `bernoulli` is:

.. math::

   f(k) = \begin{cases}1-p  &\text{if } k = 0\\
                       p    &\text{if } k = 1\end{cases}

for :math:`k` in :math:`\{0, 1\}`, :math:`0 \leq p \leq 1`

`bernoulli` takes :math:`p` as shape parameter,
where :math:`p` is the probability of a single success
and :math:`1-p` is the probability of a single failure.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``bernoulli.pmf(k, p, loc)`` is identically
equivalent to ``bernoulli.pmf(k - loc, p)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import bernoulli
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p = 0.3
>>> mean, var, skew, kurt = bernoulli.stats(p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(bernoulli.ppf(0.01, p),
...               bernoulli.ppf(0.99, p))
>>> ax.plot(x, bernoulli.pmf(x, p), 'bo', ms=8, label='bernoulli pmf')
>>> ax.vlines(x, 0, bernoulli.pmf(x, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = bernoulli(p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = bernoulli.cdf(x, p)
>>> np.allclose(x, bernoulli.ppf(prob, p))
True

Generate random numbers:

>>> r = bernoulli.rvs(p, size=1000)
================================================================================

beta:
Firma: (*args, **kwds)

Docstring:
A beta continuous random variable.

As an instance of the `rv_continuous` class, `beta` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `beta` is:

.. math::

    f(x, a, b) = \frac{\Gamma(a+b) x^{a-1} (1-x)^{b-1}}
                      {\Gamma(a) \Gamma(b)}

for :math:`0 <= x <= 1`, :math:`a > 0`, :math:`b > 0`, where
:math:`\Gamma` is the gamma function (`scipy.special.gamma`).

`beta` takes :math:`a` and :math:`b` as shape parameters.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pdf``, ``cdf``, ``ppf``, ``sf`` and ``isf``
methods. [1]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``beta.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``beta.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import beta
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 2.31, 0.627
>>> mean, var, skew, kurt = beta.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(beta.ppf(0.01, a, b),
...                 beta.ppf(0.99, a, b), 100)
>>> ax.plot(x, beta.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='beta pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = beta(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = beta.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], beta.cdf(vals, a, b))
True

Generate random numbers:

>>> r = beta.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

betabinom:
Firma: (*args, **kwds)

Docstring:
A beta-binomial discrete random variable.

As an instance of the `rv_discrete` class, `betabinom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, a, b, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, n, a, b, loc=0)
    Probability mass function.
logpmf(k, n, a, b, loc=0)
    Log of the probability mass function.
cdf(k, n, a, b, loc=0)
    Cumulative distribution function.
logcdf(k, n, a, b, loc=0)
    Log of the cumulative distribution function.
sf(k, n, a, b, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, n, a, b, loc=0)
    Log of the survival function.
ppf(q, n, a, b, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, a, b, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(n, a, b, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, a, b, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(n, a, b), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, a, b, loc=0)
    Median of the distribution.
mean(n, a, b, loc=0)
    Mean of the distribution.
var(n, a, b, loc=0)
    Variance of the distribution.
std(n, a, b, loc=0)
    Standard deviation of the distribution.
interval(confidence, n, a, b, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The beta-binomial distribution is a binomial distribution with a
probability of success `p` that follows a beta distribution.

The probability mass function for `betabinom` is:

.. math::

   f(k) = \binom{n}{k} \frac{B(k + a, n - k + b)}{B(a, b)}

for :math:`k \in \{0, 1, \dots, n\}`, :math:`n \geq 0`, :math:`a > 0`,
:math:`b > 0`, where :math:`B(a, b)` is the beta function.

`betabinom` takes :math:`n`, :math:`a`, and :math:`b` as shape parameters.

References
----------
.. [1] https://en.wikipedia.org/wiki/Beta-binomial_distribution

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``betabinom.pmf(k, n, a, b, loc)`` is identically
equivalent to ``betabinom.pmf(k - loc, n, a, b)``.

.. versionadded:: 1.4.0

See Also
--------
beta, binom

Examples
--------
>>> import numpy as np
>>> from scipy.stats import betabinom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> n, a, b = 5, 2.3, 0.63
>>> mean, var, skew, kurt = betabinom.stats(n, a, b, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(betabinom.ppf(0.01, n, a, b),
...               betabinom.ppf(0.99, n, a, b))
>>> ax.plot(x, betabinom.pmf(x, n, a, b), 'bo', ms=8, label='betabinom pmf')
>>> ax.vlines(x, 0, betabinom.pmf(x, n, a, b), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = betabinom(n, a, b)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = betabinom.cdf(x, n, a, b)
>>> np.allclose(x, betabinom.ppf(prob, n, a, b))
True

Generate random numbers:

>>> r = betabinom.rvs(n, a, b, size=1000)
================================================================================

betanbinom:
Firma: (*args, **kwds)

Docstring:
A beta-negative-binomial discrete random variable.

As an instance of the `rv_discrete` class, `betanbinom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, a, b, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, n, a, b, loc=0)
    Probability mass function.
logpmf(k, n, a, b, loc=0)
    Log of the probability mass function.
cdf(k, n, a, b, loc=0)
    Cumulative distribution function.
logcdf(k, n, a, b, loc=0)
    Log of the cumulative distribution function.
sf(k, n, a, b, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, n, a, b, loc=0)
    Log of the survival function.
ppf(q, n, a, b, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, a, b, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(n, a, b, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, a, b, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(n, a, b), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, a, b, loc=0)
    Median of the distribution.
mean(n, a, b, loc=0)
    Mean of the distribution.
var(n, a, b, loc=0)
    Variance of the distribution.
std(n, a, b, loc=0)
    Standard deviation of the distribution.
interval(confidence, n, a, b, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The beta-negative-binomial distribution is a negative binomial
distribution with a probability of success `p` that follows a
beta distribution.

The probability mass function for `betanbinom` is:

.. math::

   f(k) = \binom{n + k - 1}{k} \frac{B(a + n, b + k)}{B(a, b)}

for :math:`k \ge 0`, :math:`n \geq 0`, :math:`a > 0`,
:math:`b > 0`, where :math:`B(a, b)` is the beta function.

`betanbinom` takes :math:`n`, :math:`a`, and :math:`b` as shape parameters.

References
----------
.. [1] https://en.wikipedia.org/wiki/Beta_negative_binomial_distribution

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``betanbinom.pmf(k, n, a, b, loc)`` is identically
equivalent to ``betanbinom.pmf(k - loc, n, a, b)``.

.. versionadded:: 1.12.0

See Also
--------
betabinom : Beta binomial distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import betanbinom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> n, a, b = 5, 9.3, 1
>>> mean, var, skew, kurt = betanbinom.stats(n, a, b, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(betanbinom.ppf(0.01, n, a, b),
...               betanbinom.ppf(0.99, n, a, b))
>>> ax.plot(x, betanbinom.pmf(x, n, a, b), 'bo', ms=8, label='betanbinom pmf')
>>> ax.vlines(x, 0, betanbinom.pmf(x, n, a, b), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = betanbinom(n, a, b)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = betanbinom.cdf(x, n, a, b)
>>> np.allclose(x, betanbinom.ppf(prob, n, a, b))
True

Generate random numbers:

>>> r = betanbinom.rvs(n, a, b, size=1000)
================================================================================

betaprime:
Firma: (*args, **kwds)

Docstring:
A beta prime continuous random variable.

As an instance of the `rv_continuous` class, `betaprime` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `betaprime` is:

.. math::

    f(x, a, b) = \frac{x^{a-1} (1+x)^{-a-b}}{\beta(a, b)}

for :math:`x >= 0`, :math:`a > 0`, :math:`b > 0`, where
:math:`\beta(a, b)` is the beta function (see `scipy.special.beta`).

`betaprime` takes ``a`` and ``b`` as shape parameters.

The distribution is related to the `beta` distribution as follows:
If :math:`X` follows a beta distribution with parameters :math:`a, b`,
then :math:`Y = X/(1-X)` has a beta prime distribution with
parameters :math:`a, b` ([1]_).

The beta prime distribution is a reparametrized version of the
F distribution.  The beta prime distribution with shape parameters
``a`` and ``b`` and ``scale = s`` is equivalent to the F distribution
with parameters ``d1 = 2*a``, ``d2 = 2*b`` and ``scale = (a/b)*s``.
For example,

>>> from scipy.stats import betaprime, f
>>> x = [1, 2, 5, 10]
>>> a = 12
>>> b = 5
>>> betaprime.pdf(x, a, b, scale=2)
array([0.00541179, 0.08331299, 0.14669185, 0.03150079])
>>> f.pdf(x, 2*a, 2*b, scale=(a/b)*2)
array([0.00541179, 0.08331299, 0.14669185, 0.03150079])

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``betaprime.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``betaprime.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Beta prime distribution, Wikipedia,
       https://en.wikipedia.org/wiki/Beta_prime_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import betaprime
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 5, 6
>>> mean, var, skew, kurt = betaprime.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(betaprime.ppf(0.01, a, b),
...                 betaprime.ppf(0.99, a, b), 100)
>>> ax.plot(x, betaprime.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='betaprime pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = betaprime(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = betaprime.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], betaprime.cdf(vals, a, b))
True

Generate random numbers:

>>> r = betaprime.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

binned_statistic:
Firma: (x, values, statistic='mean', bins=10, range=None)

Docstring:
Compute a binned statistic for one or more sets of data.

This is a generalization of a histogram function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values (or set of values) within each bin.

Parameters
----------
x : (N,) array_like
    A sequence of values to be binned.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `x`, or a set of sequences - each the same shape as
    `x`.  If `values` is a set of sequences, the statistic will be computed
    on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or sequence of scalars, optional
    If `bins` is an int, it defines the number of equal-width bins in the
    given range (10 by default).  If `bins` is a sequence, it defines the
    bin edges, including the rightmost edge, allowing for non-uniform bin
    widths.  Values in `x` that are smaller than lowest bin edge are
    assigned to bin number 0, values beyond the highest bin are assigned to
    ``bins[-1]``.  If the bin edges are specified, the number of bins will
    be, (nx = len(bins)-1).
range : (float, float) or [(float, float)], optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(x.min(), x.max())``.  Values outside the range are
    ignored.

Returns
-------
statistic : array
    The values of the selected statistic in each bin.
bin_edges : array of dtype float
    Return the bin edges ``(length(statistic)+1)``.
binnumber: 1-D ndarray of ints
    Indices of the bins (corresponding to `bin_edges`) in which each value
    of `x` belongs.  Same length as `values`.  A binnumber of `i` means the
    corresponding value is between (bin_edges[i-1], bin_edges[i]).

See Also
--------
numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
``[3, 4]``, which *includes* 4.

.. versionadded:: 0.11.0

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

First some basic examples:

Create two evenly spaced bins in the range of the given sample, and sum the
corresponding values in each of those bins:

>>> values = [1.0, 1.0, 2.0, 1.5, 3.0]
>>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
BinnedStatisticResult(statistic=array([4. , 4.5]),
        bin_edges=array([1., 4., 7.]), binnumber=array([1, 1, 1, 2, 2]))

Multiple arrays of values can also be passed.  The statistic is calculated
on each set independently:

>>> values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]]
>>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
BinnedStatisticResult(statistic=array([[4. , 4.5],
       [8. , 9. ]]), bin_edges=array([1., 4., 7.]),
       binnumber=array([1, 1, 1, 2, 2]))

>>> stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean',
...                        bins=3)
BinnedStatisticResult(statistic=array([1., 2., 4.]),
        bin_edges=array([1., 2., 3., 4.]),
        binnumber=array([1, 2, 1, 2, 3]))

As a second example, we now generate some random data of sailing boat speed
as a function of wind speed, and then determine how fast our boat is for
certain wind speeds:

>>> rng = np.random.default_rng()
>>> windspeed = 8 * rng.random(500)
>>> boatspeed = .3 * windspeed**.5 + .2 * rng.random(500)
>>> bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,
...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7])
>>> plt.figure()
>>> plt.plot(windspeed, boatspeed, 'b.', label='raw data')
>>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5,
...            label='binned statistic of data')
>>> plt.legend()

Now we can use ``binnumber`` to select all datapoints with a windspeed
below 1:

>>> low_boatspeed = boatspeed[binnumber == 0]

As a final example, we will use ``bin_edges`` and ``binnumber`` to make a
plot of a distribution that shows the mean and distribution around that
mean per bin, on top of a regular histogram and the probability
distribution function:

>>> x = np.linspace(0, 5, num=500)
>>> x_pdf = stats.maxwell.pdf(x)
>>> samples = stats.maxwell.rvs(size=10000)

>>> bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,
...         statistic='mean', bins=25)
>>> bin_width = (bin_edges[1] - bin_edges[0])
>>> bin_centers = bin_edges[1:] - bin_width/2

>>> plt.figure()
>>> plt.hist(samples, bins=50, density=True, histtype='stepfilled',
...          alpha=0.2, label='histogram of data')
>>> plt.plot(x, x_pdf, 'r-', label='analytical pdf')
>>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2,
...            label='binned statistic of data')
>>> plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5)
>>> plt.legend(fontsize=10)
>>> plt.show()
================================================================================

binned_statistic_2d:
Firma: (x, y, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)

Docstring:
Compute a bidimensional binned statistic for one or more sets of data.

This is a generalization of a histogram2d function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values (or set of values) within each bin.

Parameters
----------
x : (N,) array_like
    A sequence of values to be binned along the first dimension.
y : (N,) array_like
    A sequence of values to be binned along the second dimension.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `x`, or a list of sequences - each with the same
    shape as `x`.  If `values` is such a list, the statistic will be
    computed on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or [int, int] or array_like or [array, array], optional
    The bin specification:

      * the number of bins for the two dimensions (nx = ny = bins),
      * the number of bins in each dimension (nx, ny = bins),
      * the bin edges for the two dimensions (x_edge = y_edge = bins),
      * the bin edges in each dimension (x_edge, y_edge = bins).

    If the bin edges are specified, the number of bins will be,
    (nx = len(x_edge)-1, ny = len(y_edge)-1).

range : (2,2) array_like, optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
    considered outliers and not tallied in the histogram.
expand_binnumbers : bool, optional
    'False' (default): the returned `binnumber` is a shape (N,) array of
    linearized bin indices.
    'True': the returned `binnumber` is 'unraveled' into a shape (2,N)
    ndarray, where each row gives the bin numbers in the corresponding
    dimension.
    See the `binnumber` returned value, and the `Examples` section.

    .. versionadded:: 0.17.0

Returns
-------
statistic : (nx, ny) ndarray
    The values of the selected statistic in each two-dimensional bin.
x_edge : (nx + 1) ndarray
    The bin edges along the first dimension.
y_edge : (ny + 1) ndarray
    The bin edges along the second dimension.
binnumber : (N,) array of ints or (2,N) ndarray of ints
    This assigns to each element of `sample` an integer that represents the
    bin in which this observation falls.  The representation depends on the
    `expand_binnumbers` argument.  See `Notes` for details.


See Also
--------
numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd

Notes
-----
Binedges:
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
``[3, 4]``, which *includes* 4.

`binnumber`:
This returned argument assigns to each element of `sample` an integer that
represents the bin in which it belongs.  The representation depends on the
`expand_binnumbers` argument. If 'False' (default): The returned
`binnumber` is a shape (N,) array of linearized indices mapping each
element of `sample` to its corresponding bin (using row-major ordering).
Note that the returned linearized bin indices are used for an array with
extra bins on the outer binedges to capture values outside of the defined
bin bounds.
If 'True': The returned `binnumber` is a shape (2,N) ndarray where
each row indicates bin placements for each dimension respectively.  In each
dimension, a binnumber of `i` means the corresponding value is between
(D_edge[i-1], D_edge[i]), where 'D' is either 'x' or 'y'.

.. versionadded:: 0.11.0

Examples
--------
>>> from scipy import stats

Calculate the counts with explicit bin-edges:

>>> x = [0.1, 0.1, 0.1, 0.6]
>>> y = [2.1, 2.6, 2.1, 2.1]
>>> binx = [0.0, 0.5, 1.0]
>>> biny = [2.0, 2.5, 3.0]
>>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny])
>>> ret.statistic
array([[2., 1.],
       [1., 0.]])

The bin in which each sample is placed is given by the `binnumber`
returned parameter.  By default, these are the linearized bin indices:

>>> ret.binnumber
array([5, 6, 5, 9])

The bin indices can also be expanded into separate entries for each
dimension using the `expand_binnumbers` parameter:

>>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny],
...                                 expand_binnumbers=True)
>>> ret.binnumber
array([[1, 1, 1, 2],
       [1, 2, 1, 1]])

Which shows that the first three elements belong in the xbin 1, and the
fourth into xbin 2; and so on for y.
================================================================================

binned_statistic_dd:
Firma: (sample, values, statistic='mean', bins=10, range=None, expand_binnumbers=False, binned_statistic_result=None)

Docstring:
Compute a multidimensional binned statistic for a set of data.

This is a generalization of a histogramdd function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values within each bin.

Parameters
----------
sample : array_like
    Data to histogram passed as a sequence of N arrays of length D, or
    as an (N,D) array.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `sample`, or a list of sequences - each with the
    same shape as `sample`.  If `values` is such a list, the statistic
    will be computed on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0. If the number of values
        within a given bin is 0 or 1, the computed standard deviation value
        will be 0 for the bin.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : sequence or positive int, optional
    The bin specification must be in one of the following forms:

      * A sequence of arrays describing the bin edges along each dimension.
      * The number of bins for each dimension (nx, ny, ... = bins).
      * The number of bins for all dimensions (nx = ny = ... = bins).
range : sequence, optional
    A sequence of lower and upper bin edges to be used if the edges are
    not given explicitly in `bins`. Defaults to the minimum and maximum
    values along each dimension.
expand_binnumbers : bool, optional
    'False' (default): the returned `binnumber` is a shape (N,) array of
    linearized bin indices.
    'True': the returned `binnumber` is 'unraveled' into a shape (D,N)
    ndarray, where each row gives the bin numbers in the corresponding
    dimension.
    See the `binnumber` returned value, and the `Examples` section of
    `binned_statistic_2d`.
binned_statistic_result : binnedStatisticddResult
    Result of a previous call to the function in order to reuse bin edges
    and bin numbers with new values and/or a different statistic.
    To reuse bin numbers, `expand_binnumbers` must have been set to False
    (the default)

    .. versionadded:: 0.17.0

Returns
-------
statistic : ndarray, shape(nx1, nx2, nx3,...)
    The values of the selected statistic in each two-dimensional bin.
bin_edges : list of ndarrays
    A list of D arrays describing the (nxi + 1) bin edges for each
    dimension.
binnumber : (N,) array of ints or (D,N) ndarray of ints
    This assigns to each element of `sample` an integer that represents the
    bin in which this observation falls.  The representation depends on the
    `expand_binnumbers` argument.  See `Notes` for details.


See Also
--------
numpy.digitize, numpy.histogramdd, binned_statistic, binned_statistic_2d

Notes
-----
Binedges:
All but the last (righthand-most) bin is half-open in each dimension.  In
other words, if `bins` is ``[1, 2, 3, 4]``, then the first bin is
``[1, 2)`` (including 1, but excluding 2) and the second ``[2, 3)``.  The
last bin, however, is ``[3, 4]``, which *includes* 4.

`binnumber`:
This returned argument assigns to each element of `sample` an integer that
represents the bin in which it belongs.  The representation depends on the
`expand_binnumbers` argument. If 'False' (default): The returned
`binnumber` is a shape (N,) array of linearized indices mapping each
element of `sample` to its corresponding bin (using row-major ordering).
If 'True': The returned `binnumber` is a shape (D,N) ndarray where
each row indicates bin placements for each dimension respectively.  In each
dimension, a binnumber of `i` means the corresponding value is between
(bin_edges[D][i-1], bin_edges[D][i]), for each dimension 'D'.

.. versionadded:: 0.11.0

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.mplot3d import Axes3D

Take an array of 600 (x, y) coordinates as an example.
`binned_statistic_dd` can handle arrays of higher dimension `D`. But a plot
of dimension `D+1` is required.

>>> mu = np.array([0., 1.])
>>> sigma = np.array([[1., -0.5],[-0.5, 1.5]])
>>> multinormal = stats.multivariate_normal(mu, sigma)
>>> data = multinormal.rvs(size=600, random_state=235412)
>>> data.shape
(600, 2)

Create bins and count how many arrays fall in each bin:

>>> N = 60
>>> x = np.linspace(-3, 3, N)
>>> y = np.linspace(-3, 4, N)
>>> ret = stats.binned_statistic_dd(data, np.arange(600), bins=[x, y],
...                                 statistic='count')
>>> bincounts = ret.statistic

Set the volume and the location of bars:

>>> dx = x[1] - x[0]
>>> dy = y[1] - y[0]
>>> x, y = np.meshgrid(x[:-1]+dx/2, y[:-1]+dy/2)
>>> z = 0

>>> bincounts = bincounts.ravel()
>>> x = x.ravel()
>>> y = y.ravel()

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111, projection='3d')
>>> with np.errstate(divide='ignore'):   # silence random axes3d warning
...     ax.bar3d(x, y, z, dx, dy, bincounts)

Reuse bin numbers and bin edges with new values:

>>> ret2 = stats.binned_statistic_dd(data, -np.arange(600),
...                                  binned_statistic_result=ret,
...                                  statistic='mean')
================================================================================

binom:
Firma: (*args, **kwds)

Docstring:
A binomial discrete random variable.

As an instance of the `rv_discrete` class, `binom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, n, p, loc=0)
    Probability mass function.
logpmf(k, n, p, loc=0)
    Log of the probability mass function.
cdf(k, n, p, loc=0)
    Cumulative distribution function.
logcdf(k, n, p, loc=0)
    Log of the cumulative distribution function.
sf(k, n, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, n, p, loc=0)
    Log of the survival function.
ppf(q, n, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(n, p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(n, p), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, p, loc=0)
    Median of the distribution.
mean(n, p, loc=0)
    Mean of the distribution.
var(n, p, loc=0)
    Variance of the distribution.
std(n, p, loc=0)
    Standard deviation of the distribution.
interval(confidence, n, p, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `binom` is:

.. math::

   f(k) = \binom{n}{k} p^k (1-p)^{n-k}

for :math:`k \in \{0, 1, \dots, n\}`, :math:`0 \leq p \leq 1`

`binom` takes :math:`n` and :math:`p` as shape parameters,
where :math:`p` is the probability of a single success
and :math:`1-p` is the probability of a single failure.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pmf``, ``cdf``, ``sf``, ``ppf`` and ``isf``
methods. [1]_

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``binom.pmf(k, n, p, loc)`` is identically
equivalent to ``binom.pmf(k - loc, n, p)``.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import binom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> n, p = 5, 0.4
>>> mean, var, skew, kurt = binom.stats(n, p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(binom.ppf(0.01, n, p),
...               binom.ppf(0.99, n, p))
>>> ax.plot(x, binom.pmf(x, n, p), 'bo', ms=8, label='binom pmf')
>>> ax.vlines(x, 0, binom.pmf(x, n, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = binom(n, p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = binom.cdf(x, n, p)
>>> np.allclose(x, binom.ppf(prob, n, p))
True

Generate random numbers:

>>> r = binom.rvs(n, p, size=1000)

See Also
--------
hypergeom, nbinom, nhypergeom
================================================================================

binomtest:
Firma: (k, n, p=0.5, alternative='two-sided')

Docstring:
Perform a test that the probability of success is p.

The binomial test [1]_ is a test of the null hypothesis that the
probability of success in a Bernoulli experiment is `p`.

Details of the test can be found in many texts on statistics, such
as section 24.5 of [2]_.

Parameters
----------
k : int
    The number of successes.
n : int
    The number of trials.
p : float, optional
    The hypothesized probability of success, i.e. the expected
    proportion of successes.  The value must be in the interval
    ``0 <= p <= 1``. The default value is ``p = 0.5``.
alternative : {'two-sided', 'greater', 'less'}, optional
    Indicates the alternative hypothesis. The default value is
    'two-sided'.

Returns
-------
result : `~scipy.stats._result_classes.BinomTestResult` instance
    The return value is an object with the following attributes:

    k : int
        The number of successes (copied from `binomtest` input).
    n : int
        The number of trials (copied from `binomtest` input).
    alternative : str
        Indicates the alternative hypothesis specified in the input
        to `binomtest`.  It will be one of ``'two-sided'``, ``'greater'``,
        or ``'less'``.
    statistic : float
        The estimate of the proportion of successes.
    pvalue : float
        The p-value of the hypothesis test.

    The object has the following methods:

    proportion_ci(confidence_level=0.95, method='exact') :
        Compute the confidence interval for ``statistic``.

Notes
-----
.. versionadded:: 1.7.0

References
----------
.. [1] Binomial test, https://en.wikipedia.org/wiki/Binomial_test
.. [2] Jerrold H. Zar, Biostatistical Analysis (fifth edition),
       Prentice Hall, Upper Saddle River, New Jersey USA (2010)

Examples
--------
>>> from scipy.stats import binomtest

A car manufacturer claims that no more than 10% of their cars are unsafe.
15 cars are inspected for safety, 3 were found to be unsafe. Test the
manufacturer's claim:

>>> result = binomtest(3, n=15, p=0.1, alternative='greater')
>>> result.pvalue
0.18406106910639114

The null hypothesis cannot be rejected at the 5% level of significance
because the returned p-value is greater than the critical value of 5%.

The test statistic is equal to the estimated proportion, which is simply
``3/15``:

>>> result.statistic
0.2

We can use the `proportion_ci()` method of the result to compute the
confidence interval of the estimate:

>>> result.proportion_ci(confidence_level=0.95)
ConfidenceInterval(low=0.05684686759024681, high=1.0)
================================================================================

boltzmann:
Firma: (*args, **kwds)

Docstring:
A Boltzmann (Truncated Discrete Exponential) random variable.

As an instance of the `rv_discrete` class, `boltzmann` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(lambda_, N, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, lambda_, N, loc=0)
    Probability mass function.
logpmf(k, lambda_, N, loc=0)
    Log of the probability mass function.
cdf(k, lambda_, N, loc=0)
    Cumulative distribution function.
logcdf(k, lambda_, N, loc=0)
    Log of the cumulative distribution function.
sf(k, lambda_, N, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, lambda_, N, loc=0)
    Log of the survival function.
ppf(q, lambda_, N, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, lambda_, N, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(lambda_, N, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(lambda_, N, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(lambda_, N), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(lambda_, N, loc=0)
    Median of the distribution.
mean(lambda_, N, loc=0)
    Mean of the distribution.
var(lambda_, N, loc=0)
    Variance of the distribution.
std(lambda_, N, loc=0)
    Standard deviation of the distribution.
interval(confidence, lambda_, N, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `boltzmann` is:

.. math::

    f(k) = (1-\exp(-\lambda)) \exp(-\lambda k) / (1-\exp(-\lambda N))

for :math:`k = 0,..., N-1`.

`boltzmann` takes :math:`\lambda > 0` and :math:`N > 0` as shape parameters.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``boltzmann.pmf(k, lambda_, N, loc)`` is identically
equivalent to ``boltzmann.pmf(k - loc, lambda_, N)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import boltzmann
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> lambda_, N = 1.4, 19
>>> mean, var, skew, kurt = boltzmann.stats(lambda_, N, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(boltzmann.ppf(0.01, lambda_, N),
...               boltzmann.ppf(0.99, lambda_, N))
>>> ax.plot(x, boltzmann.pmf(x, lambda_, N), 'bo', ms=8, label='boltzmann pmf')
>>> ax.vlines(x, 0, boltzmann.pmf(x, lambda_, N), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = boltzmann(lambda_, N)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = boltzmann.cdf(x, lambda_, N)
>>> np.allclose(x, boltzmann.ppf(prob, lambda_, N))
True

Generate random numbers:

>>> r = boltzmann.rvs(lambda_, N, size=1000)
================================================================================

bootstrap:
Firma: (data, statistic, *, n_resamples=9999, batch=None, vectorized=None, paired=False, axis=0, confidence_level=0.95, alternative='two-sided', method='BCa', bootstrap_result=None, rng=None)

Docstring:
Compute a two-sided bootstrap confidence interval of a statistic.

When `method` is ``'percentile'`` and `alternative` is ``'two-sided'``,
a bootstrap confidence interval is computed according to the following
procedure.

1. Resample the data: for each sample in `data` and for each of
   `n_resamples`, take a random sample of the original sample
   (with replacement) of the same size as the original sample.

2. Compute the bootstrap distribution of the statistic: for each set of
   resamples, compute the test statistic.

3. Determine the confidence interval: find the interval of the bootstrap
   distribution that is

   - symmetric about the median and
   - contains `confidence_level` of the resampled statistic values.

While the ``'percentile'`` method is the most intuitive, it is rarely
used in practice. Two more common methods are available, ``'basic'``
('reverse percentile') and ``'BCa'`` ('bias-corrected and accelerated');
they differ in how step 3 is performed.

If the samples in `data` are  taken at random from their respective
distributions :math:`n` times, the confidence interval returned by
`bootstrap` will contain the true value of the statistic for those
distributions approximately `confidence_level`:math:`\, \times \, n` times.

Parameters
----------
data : sequence of array-like
    Each element of `data` is a sample containing scalar observations from an
    underlying distribution. Elements of `data` must be broadcastable to the
    same shape (with the possible exception of the dimension specified by `axis`).
    
    .. versionchanged:: 1.14.0
        `bootstrap` will now emit a ``FutureWarning`` if the shapes of the
        elements of `data` are not the same (with the exception of the dimension
        specified by `axis`).
        Beginning in SciPy 1.16.0, `bootstrap` will explicitly broadcast the
        elements to the same shape (except along `axis`) before performing
        the calculation.
statistic : callable
    Statistic for which the confidence interval is to be calculated.
    `statistic` must be a callable that accepts ``len(data)`` samples
    as separate arguments and returns the resulting statistic.
    If `vectorized` is set ``True``,
    `statistic` must also accept a keyword argument `axis` and be
    vectorized to compute the statistic along the provided `axis`.
n_resamples : int, default: ``9999``
    The number of resamples performed to form the bootstrap distribution
    of the statistic.
batch : int, optional
    The number of resamples to process in each vectorized call to
    `statistic`. Memory usage is O( `batch` * ``n`` ), where ``n`` is the
    sample size. Default is ``None``, in which case ``batch = n_resamples``
    (or ``batch = max(n_resamples, n)`` for ``method='BCa'``).
vectorized : bool, optional
    If `vectorized` is set ``False``, `statistic` will not be passed
    keyword argument `axis` and is expected to calculate the statistic
    only for 1D samples. If ``True``, `statistic` will be passed keyword
    argument `axis` and is expected to calculate the statistic along `axis`
    when passed an ND sample array. If ``None`` (default), `vectorized`
    will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of
    a vectorized statistic typically reduces computation time.
paired : bool, default: ``False``
    Whether the statistic treats corresponding elements of the samples
    in `data` as paired. If True, `bootstrap` resamples an array of
    *indices* and uses the same indices for all arrays in `data`; otherwise,
    `bootstrap` independently resamples the elements of each array.
axis : int, default: ``0``
    The axis of the samples in `data` along which the `statistic` is
    calculated.
confidence_level : float, default: ``0.95``
    The confidence level of the confidence interval.
alternative : {'two-sided', 'less', 'greater'}, default: ``'two-sided'``
    Choose ``'two-sided'`` (default) for a two-sided confidence interval,
    ``'less'`` for a one-sided confidence interval with the lower bound
    at ``-np.inf``, and ``'greater'`` for a one-sided confidence interval
    with the upper bound at ``np.inf``. The other bound of the one-sided
    confidence intervals is the same as that of a two-sided confidence
    interval with `confidence_level` twice as far from 1.0; e.g. the upper
    bound of a 95% ``'less'``  confidence interval is the same as the upper
    bound of a 90% ``'two-sided'`` confidence interval.
method : {'percentile', 'basic', 'bca'}, default: ``'BCa'``
    Whether to return the 'percentile' bootstrap confidence interval
    (``'percentile'``), the 'basic' (AKA 'reverse') bootstrap confidence
    interval (``'basic'``), or the bias-corrected and accelerated bootstrap
    confidence interval (``'BCa'``).
bootstrap_result : BootstrapResult, optional
    Provide the result object returned by a previous call to `bootstrap`
    to include the previous bootstrap distribution in the new bootstrap
    distribution. This can be used, for example, to change
    `confidence_level`, change `method`, or see the effect of performing
    additional resampling without repeating computations.
rng : {None, int, `numpy.random.Generator`}, optional
    If `rng` is passed by keyword, types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.
    If `rng` is already a ``Generator`` instance, then the provided instance is
    used. Specify `rng` for repeatable function behavior.

    If this argument is passed by position or `random_state` is passed by keyword,
    legacy behavior for the argument `random_state` applies:

    - If `random_state` is None (or `numpy.random`), the `numpy.random.RandomState`
      singleton is used.
    - If `random_state` is an int, a new ``RandomState`` instance is used,
      seeded with `random_state`.
    - If `random_state` is already a ``Generator`` or ``RandomState`` instance then
      that instance is used.

    .. versionchanged:: 1.15.0
        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this keyword was changed from `random_state` to `rng`.
        For an interim period, both keywords will continue to work, although only one
        may be specified at a time. After the interim period, function calls using the
        `random_state` keyword will emit warnings. The behavior of both `random_state` and
        `rng` are outlined above, but only the `rng` keyword should be used in new code.
        

Returns
-------
res : BootstrapResult
    An object with attributes:
    
    confidence_interval : ConfidenceInterval
        The bootstrap confidence interval as an instance of
        `collections.namedtuple` with attributes `low` and `high`.
    bootstrap_distribution : ndarray
        The bootstrap distribution, that is, the value of `statistic` for
        each resample. The last dimension corresponds with the resamples
        (e.g. ``res.bootstrap_distribution.shape[-1] == n_resamples``).
    standard_error : float or ndarray
        The bootstrap standard error, that is, the sample standard
        deviation of the bootstrap distribution.

Warns
-----
`~scipy.stats.DegenerateDataWarning`
    Generated when ``method='BCa'`` and the bootstrap distribution is
    degenerate (e.g. all elements are identical).

Notes
-----
Elements of the confidence interval may be NaN for ``method='BCa'`` if
the bootstrap distribution is degenerate (e.g. all elements are identical).
In this case, consider using another `method` or inspecting `data` for
indications that other analysis may be more appropriate (e.g. all
observations are identical).

References
----------
.. [1] B. Efron and R. J. Tibshirani, An Introduction to the Bootstrap,
   Chapman & Hall/CRC, Boca Raton, FL, USA (1993)
.. [2] Nathaniel E. Helwig, "Bootstrap Confidence Intervals",
   http://users.stat.umn.edu/~helwig/notes/bootci-Notes.pdf
.. [3] Bootstrapping (statistics), Wikipedia,
   https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29

Examples
--------
Suppose we have sampled data from an unknown distribution.

>>> import numpy as np
>>> rng = np.random.default_rng()
>>> from scipy.stats import norm
>>> dist = norm(loc=2, scale=4)  # our "unknown" distribution
>>> data = dist.rvs(size=100, random_state=rng)

We are interested in the standard deviation of the distribution.

>>> std_true = dist.std()      # the true value of the statistic
>>> print(std_true)
4.0
>>> std_sample = np.std(data)  # the sample statistic
>>> print(std_sample)
3.9460644295563863

The bootstrap is used to approximate the variability we would expect if we
were to repeatedly sample from the unknown distribution and calculate the
statistic of the sample each time. It does this by repeatedly resampling
values *from the original sample* with replacement and calculating the
statistic of each resample. This results in a "bootstrap distribution" of
the statistic.

>>> import matplotlib.pyplot as plt
>>> from scipy.stats import bootstrap
>>> data = (data,)  # samples must be in a sequence
>>> res = bootstrap(data, np.std, confidence_level=0.9, rng=rng)
>>> fig, ax = plt.subplots()
>>> ax.hist(res.bootstrap_distribution, bins=25)
>>> ax.set_title('Bootstrap Distribution')
>>> ax.set_xlabel('statistic value')
>>> ax.set_ylabel('frequency')
>>> plt.show()

The standard error quantifies this variability. It is calculated as the
standard deviation of the bootstrap distribution.

>>> res.standard_error
0.24427002125829136
>>> res.standard_error == np.std(res.bootstrap_distribution, ddof=1)
True

The bootstrap distribution of the statistic is often approximately normal
with scale equal to the standard error.

>>> x = np.linspace(3, 5)
>>> pdf = norm.pdf(x, loc=std_sample, scale=res.standard_error)
>>> fig, ax = plt.subplots()
>>> ax.hist(res.bootstrap_distribution, bins=25, density=True)
>>> ax.plot(x, pdf)
>>> ax.set_title('Normal Approximation of the Bootstrap Distribution')
>>> ax.set_xlabel('statistic value')
>>> ax.set_ylabel('pdf')
>>> plt.show()

This suggests that we could construct a 90% confidence interval on the
statistic based on quantiles of this normal distribution.

>>> norm.interval(0.9, loc=std_sample, scale=res.standard_error)
(3.5442759991341726, 4.3478528599786)

Due to central limit theorem, this normal approximation is accurate for a
variety of statistics and distributions underlying the samples; however,
the approximation is not reliable in all cases. Because `bootstrap` is
designed to work with arbitrary underlying distributions and statistics,
it uses more advanced techniques to generate an accurate confidence
interval.

>>> print(res.confidence_interval)
ConfidenceInterval(low=3.57655333533867, high=4.382043696342881)

If we sample from the original distribution 100 times and form a bootstrap
confidence interval for each sample, the confidence interval
contains the true value of the statistic approximately 90% of the time.

>>> n_trials = 100
>>> ci_contains_true_std = 0
>>> for i in range(n_trials):
...    data = (dist.rvs(size=100, random_state=rng),)
...    res = bootstrap(data, np.std, confidence_level=0.9,
...                    n_resamples=999, rng=rng)
...    ci = res.confidence_interval
...    if ci[0] < std_true < ci[1]:
...        ci_contains_true_std += 1
>>> print(ci_contains_true_std)
88

Rather than writing a loop, we can also determine the confidence intervals
for all 100 samples at once.

>>> data = (dist.rvs(size=(n_trials, 100), random_state=rng),)
>>> res = bootstrap(data, np.std, axis=-1, confidence_level=0.9,
...                 n_resamples=999, rng=rng)
>>> ci_l, ci_u = res.confidence_interval

Here, `ci_l` and `ci_u` contain the confidence interval for each of the
``n_trials = 100`` samples.

>>> print(ci_l[:5])
[3.86401283 3.33304394 3.52474647 3.54160981 3.80569252]
>>> print(ci_u[:5])
[4.80217409 4.18143252 4.39734707 4.37549713 4.72843584]

And again, approximately 90% contain the true value, ``std_true = 4``.

>>> print(np.sum((ci_l < std_true) & (std_true < ci_u)))
93

`bootstrap` can also be used to estimate confidence intervals of
multi-sample statistics. For example, to get a confidence interval
for the difference between means, we write a function that accepts
two sample arguments and returns only the statistic. The use of the
``axis`` argument ensures that all mean calculations are perform in
a single vectorized call, which is faster than looping over pairs
of resamples in Python.

>>> def my_statistic(sample1, sample2, axis=-1):
...     mean1 = np.mean(sample1, axis=axis)
...     mean2 = np.mean(sample2, axis=axis)
...     return mean1 - mean2

Here, we use the 'percentile' method with the default 95% confidence level.

>>> sample1 = norm.rvs(scale=1, size=100, random_state=rng)
>>> sample2 = norm.rvs(scale=2, size=100, random_state=rng)
>>> data = (sample1, sample2)
>>> res = bootstrap(data, my_statistic, method='basic', rng=rng)
>>> print(my_statistic(sample1, sample2))
0.16661030792089523
>>> print(res.confidence_interval)
ConfidenceInterval(low=-0.29087973240818693, high=0.6371338699912273)

The bootstrap estimate of the standard error is also available.

>>> print(res.standard_error)
0.238323948262459

Paired-sample statistics work, too. For example, consider the Pearson
correlation coefficient.

>>> from scipy.stats import pearsonr
>>> n = 100
>>> x = np.linspace(0, 10, n)
>>> y = x + rng.uniform(size=n)
>>> print(pearsonr(x, y)[0])  # element 0 is the statistic
0.9954306665125647

We wrap `pearsonr` so that it returns only the statistic, ensuring
that we use the `axis` argument because it is available.

>>> def my_statistic(x, y, axis=-1):
...     return pearsonr(x, y, axis=axis)[0]

We call `bootstrap` using ``paired=True``.

>>> res = bootstrap((x, y), my_statistic, paired=True, rng=rng)
>>> print(res.confidence_interval)
ConfidenceInterval(low=0.9941504301315878, high=0.996377412215445)

The result object can be passed back into `bootstrap` to perform additional
resampling:

>>> len(res.bootstrap_distribution)
9999
>>> res = bootstrap((x, y), my_statistic, paired=True,
...                 n_resamples=1000, rng=rng,
...                 bootstrap_result=res)
>>> len(res.bootstrap_distribution)
10999

or to change the confidence interval options:

>>> res2 = bootstrap((x, y), my_statistic, paired=True,
...                  n_resamples=0, rng=rng, bootstrap_result=res,
...                  method='percentile', confidence_level=0.9)
>>> np.testing.assert_equal(res2.bootstrap_distribution,
...                         res.bootstrap_distribution)
>>> res.confidence_interval
ConfidenceInterval(low=0.9941574828235082, high=0.9963781698210212)

without repeating computation of the original bootstrap distribution.
================================================================================

boschloo_exact:
Firma: (table, alternative='two-sided', n=32)

Docstring:
Perform Boschloo's exact test on a 2x2 contingency table.

Parameters
----------
table : array_like of ints
    A 2x2 contingency table.  Elements should be non-negative integers.

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes section below.

n : int, optional
    Number of sampling points used in the construction of the sampling
    method. Note that this argument will automatically be converted to
    the next higher power of 2 since `scipy.stats.qmc.Sobol` is used to
    select sample points. Default is 32. Must be positive. In most cases,
    32 points is enough to reach good precision. More points comes at
    performance cost.

Returns
-------
ber : BoschlooExactResult
    A result object with the following attributes.

    statistic : float
        The statistic used in Boschloo's test; that is, the p-value
        from Fisher's exact test.

    pvalue : float
        P-value, the probability of obtaining a distribution at least as
        extreme as the one that was actually observed, assuming that the
        null hypothesis is true.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.
fisher_exact : Fisher exact test on a 2x2 contingency table.
barnard_exact : Barnard's exact test, which is a more powerful alternative
    than Fisher's exact test for 2x2 contingency tables.

Notes
-----
Boschloo's test is an exact test used in the analysis of contingency
tables. It examines the association of two categorical variables, and
is a uniformly more powerful alternative to Fisher's exact test
for 2x2 contingency tables.

Boschloo's exact test uses the p-value of Fisher's exact test as a
statistic, and Boschloo's p-value is the probability under the null
hypothesis of observing such an extreme value of this statistic.

Let's define :math:`X_0` a 2x2 matrix representing the observed sample,
where each column stores the binomial experiment, as in the example
below. Let's also define :math:`p_1, p_2` the theoretical binomial
probabilities for  :math:`x_{11}` and :math:`x_{12}`. When using
Boschloo exact test, we can assert three different alternative hypotheses:

- :math:`H_0 : p_1=p_2` versus :math:`H_1 : p_1 < p_2`,
  with `alternative` = "less"

- :math:`H_0 : p_1=p_2` versus :math:`H_1 : p_1 > p_2`,
  with `alternative` = "greater"

- :math:`H_0 : p_1=p_2` versus :math:`H_1 : p_1 \neq p_2`,
  with `alternative` = "two-sided" (default)

There are multiple conventions for computing a two-sided p-value when the
null distribution is asymmetric. Here, we apply the convention that the
p-value of a two-sided test is twice the minimum of the p-values of the
one-sided tests (clipped to 1.0). Note that `fisher_exact` follows a
different convention, so for a given `table`, the statistic reported by
`boschloo_exact` may differ from the p-value reported by `fisher_exact`
when ``alternative='two-sided'``.

.. versionadded:: 1.7.0

References
----------
.. [1] R.D. Boschloo. "Raised conditional level of significance for the
   2 x 2-table when testing the equality of two probabilities",
   Statistica Neerlandica, 24(1), 1970

.. [2] "Boschloo's test", Wikipedia,
   https://en.wikipedia.org/wiki/Boschloo%27s_test

.. [3] Lise M. Saari et al. "Employee attitudes and job satisfaction",
   Human Resource Management, 43(4), 395-407, 2004,
   :doi:`10.1002/hrm.20032`.

Examples
--------
In the following example, we consider the article "Employee
attitudes and job satisfaction" [3]_
which reports the results of a survey from 63 scientists and 117 college
professors. Of the 63 scientists, 31 said they were very satisfied with
their jobs, whereas 74 of the college professors were very satisfied
with their work. Is this significant evidence that college
professors are happier with their work than scientists?
The following table summarizes the data mentioned above::

                     college professors   scientists
    Very Satisfied   74                     31
    Dissatisfied     43                     32

When working with statistical hypothesis testing, we usually use a
threshold probability or significance level upon which we decide
to reject the null hypothesis :math:`H_0`. Suppose we choose the common
significance level of 5%.

Our alternative hypothesis is that college professors are truly more
satisfied with their work than scientists. Therefore, we expect
:math:`p_1` the proportion of very satisfied college professors to be
greater than :math:`p_2`, the proportion of very satisfied scientists.
We thus call `boschloo_exact` with the ``alternative="greater"`` option:

>>> import scipy.stats as stats
>>> res = stats.boschloo_exact([[74, 31], [43, 32]], alternative="greater")
>>> res.statistic
0.0483
>>> res.pvalue
0.0355

Under the null hypothesis that scientists are happier in their work than
college professors, the probability of obtaining test
results at least as extreme as the observed data is approximately 3.55%.
Since this p-value is less than our chosen significance level, we have
evidence to reject :math:`H_0` in favor of the alternative hypothesis.
================================================================================

boxcox:
Firma: (x, lmbda=None, alpha=None, optimizer=None)

Docstring:
Return a dataset transformed by a Box-Cox power transformation.

Parameters
----------
x : ndarray
    Input array to be transformed.

    If `lmbda` is not None, this is an alias of
    `scipy.special.boxcox`.
    Returns nan if ``x < 0``; returns -inf if ``x == 0 and lmbda < 0``.

    If `lmbda` is None, array must be positive, 1-dimensional, and
    non-constant.

lmbda : scalar, optional
    If `lmbda` is None (default), find the value of `lmbda` that maximizes
    the log-likelihood function and return it as the second output
    argument.

    If `lmbda` is not None, do the transformation for that value.

alpha : float, optional
    If `lmbda` is None and `alpha` is not None (default), return the
    ``100 * (1-alpha)%`` confidence  interval for `lmbda` as the third
    output argument. Must be between 0.0 and 1.0.

    If `lmbda` is not None, `alpha` is ignored.
optimizer : callable, optional
    If `lmbda` is None, `optimizer` is the scalar optimizer used to find
    the value of `lmbda` that minimizes the negative log-likelihood
    function. `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function, which evaluates the negative
        log-likelihood function at a provided value of `lmbda`

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example in `boxcox_normmax` or the documentation of
    `scipy.optimize.minimize_scalar` for more information.

    If `lmbda` is not None, `optimizer` is ignored.

Returns
-------
boxcox : ndarray
    Box-Cox power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the `lmbda` that maximizes the log-likelihood function.
(min_ci, max_ci) : tuple of float, optional
    If `lmbda` parameter is None and `alpha` is not None, this returned
    tuple of floats represents the minimum and maximum confidence limits
    given `alpha`.

See Also
--------
probplot, boxcox_normplot, boxcox_normmax, boxcox_llf

Notes
-----
The Box-Cox transform is given by::

    y = (x**lmbda - 1) / lmbda,  for lmbda != 0
        log(x),                  for lmbda = 0

`boxcox` requires the input data to be positive.  Sometimes a Box-Cox
transformation provides a shift parameter to achieve this; `boxcox` does
not.  Such a shift parameter is equivalent to adding a positive constant to
`x` before calling `boxcox`.

The confidence limits returned when `alpha` is provided give the interval
where:

.. math::

    llf(\hat{\lambda}) - llf(\lambda) < \frac{1}{2}\chi^2(1 - \alpha, 1),

with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared
function.

References
----------
G.E.P. Box and D.R. Cox, "An Analysis of Transformations", Journal of the
Royal Statistical Society B, 26, 211-252 (1964).

Examples
--------
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

>>> fig = plt.figure()
>>> ax1 = fig.add_subplot(211)
>>> x = stats.loggamma.rvs(5, size=500) + 5
>>> prob = stats.probplot(x, dist=stats.norm, plot=ax1)
>>> ax1.set_xlabel('')
>>> ax1.set_title('Probplot against normal distribution')

We now use `boxcox` to transform the data so it's closest to normal:

>>> ax2 = fig.add_subplot(212)
>>> xt, _ = stats.boxcox(x)
>>> prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
>>> ax2.set_title('Probplot after Box-Cox transformation')

>>> plt.show()
================================================================================

boxcox_llf:
Firma: (lmb, data)

Docstring:
The boxcox log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Box-Cox transformation.  See `boxcox` for details.
data : array_like
    Data to calculate Box-Cox log-likelihood for.  If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float or ndarray
    Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
    an array otherwise.

See Also
--------
boxcox, probplot, boxcox_normplot, boxcox_normmax

Notes
-----
The Box-Cox log-likelihood function is defined here as

.. math::

    llf = (\lambda - 1) \sum_i(\log(x_i)) -
          N/2 \log(\sum_i (y_i - \bar{y})^2 / N),

where ``y`` is the Box-Cox transformed input data ``x``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Box-Cox log-likelihood values
for them for a range of ``lmbda`` values:

>>> rng = np.random.default_rng()
>>> x = stats.loggamma.rvs(5, loc=10, size=1000, random_state=rng)
>>> lmbdas = np.linspace(-2, 10)
>>> llf = np.zeros(lmbdas.shape, dtype=float)
>>> for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.boxcox_llf(lmbda, x)

Also find the optimal lmbda value with `boxcox`:

>>> x_most_normal, lmbda_optimal = stats.boxcox(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(lmbdas, llf, 'b.-')
>>> ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color='r')
>>> ax.set_xlabel('lmbda parameter')
>>> ax.set_ylabel('Box-Cox log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `boxcox` looks closest to normal:

>>> locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
>>> for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.boxcox(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

>>> plt.show()
================================================================================

boxcox_normmax:
Firma: (x, brack=None, method='pearsonr', optimizer=None, *, ymax=BIG_FLOAT)

Docstring:
Compute optimal Box-Cox transform parameter for input data.

Parameters
----------
x : array_like
    Input array. All entries must be positive, finite, real numbers.
brack : 2-tuple, optional, default (-2.0, 2.0)
     The starting interval for a downhill bracket search for the default
     `optimize.brent` solver. Note that this is in most cases not
     critical; the final result is allowed to be outside this bracket.
     If `optimizer` is passed, `brack` must be None.
method : str, optional
    The method to determine the optimal transform parameter (`boxcox`
    ``lmbda`` parameter). Options are:

    'pearsonr'  (default)
        Maximizes the Pearson correlation coefficient between
        ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
        normally-distributed.

    'mle'
        Maximizes the log-likelihood `boxcox_llf`.  This is the method used
        in `boxcox`.

    'all'
        Use all optimization methods available, and return all results.
        Useful to compare different methods.
optimizer : callable, optional
    `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function to be minimized. `fun` accepts one argument,
        the Box-Cox transform parameter `lmbda`, and returns the value of
        the function (e.g., the negative log-likelihood) at the provided
        argument. The job of `optimizer` is to find the value of `lmbda`
        that *minimizes* `fun`.

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example below or the documentation of
    `scipy.optimize.minimize_scalar` for more information.
ymax : float, optional
    The unconstrained optimal transform parameter may cause Box-Cox
    transformed data to have extreme magnitude or even overflow.
    This parameter constrains MLE optimization such that the magnitude
    of the transformed `x` does not exceed `ymax`. The default is
    the maximum value of the input dtype. If set to infinity,
    `boxcox_normmax` returns the unconstrained optimal lambda.
    Ignored when ``method='pearsonr'``.

Returns
-------
maxlog : float or ndarray
    The optimal transform parameter found.  An array instead of a scalar
    for ``method='all'``.

See Also
--------
boxcox, boxcox_llf, boxcox_normplot, scipy.optimize.minimize_scalar

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

We can generate some data and determine the optimal ``lmbda`` in various
ways:

>>> rng = np.random.default_rng()
>>> x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
>>> y, lmax_mle = stats.boxcox(x)
>>> lmax_pearsonr = stats.boxcox_normmax(x)

>>> lmax_mle
2.217563431465757
>>> lmax_pearsonr
2.238318660200961
>>> stats.boxcox_normmax(x, method='all')
array([2.23831866, 2.21756343])

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> prob = stats.boxcox_normplot(x, -10, 10, plot=ax)
>>> ax.axvline(lmax_mle, color='r')
>>> ax.axvline(lmax_pearsonr, color='g', ls='--')

>>> plt.show()

Alternatively, we can define our own `optimizer` function. Suppose we
are only interested in values of `lmbda` on the interval [6, 7], we
want to use `scipy.optimize.minimize_scalar` with ``method='bounded'``,
and we want to use tighter tolerances when optimizing the log-likelihood
function. To do this, we define a function that accepts positional argument
`fun` and uses `scipy.optimize.minimize_scalar` to minimize `fun` subject
to the provided bounds and tolerances:

>>> from scipy import optimize
>>> options = {'xatol': 1e-12}  # absolute tolerance on `x`
>>> def optimizer(fun):
...     return optimize.minimize_scalar(fun, bounds=(6, 7),
...                                     method="bounded", options=options)
>>> stats.boxcox_normmax(x, optimizer=optimizer)
6.000000000
================================================================================

boxcox_normplot:
Firma: (x, la, lb, plot=None, N=80)

Docstring:
Compute parameters for a Box-Cox normality plot, optionally show it.

A Box-Cox normality plot shows graphically what the best transformation
parameter is to use in `boxcox` to obtain a distribution that is close
to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
    for Box-Cox transformations.  These are also the limits of the
    horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Box-Cox transform was done.
ppcc : ndarray
    Probability Plot Correlation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

Examples
--------
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Box-Cox plot:

>>> x = stats.loggamma.rvs(5, size=500) + 5
>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> prob = stats.boxcox_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

>>> _, maxlog = stats.boxcox(x)
>>> ax.axvline(maxlog, color='r')

>>> plt.show()
================================================================================

bradford:
Firma: (*args, **kwds)

Docstring:
A Bradford continuous random variable.

As an instance of the `rv_continuous` class, `bradford` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `bradford` is:

.. math::

    f(x, c) = \frac{c}{\log(1+c) (1+cx)}

for :math:`0 <= x <= 1` and :math:`c > 0`.

`bradford` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``bradford.pdf(x, c, loc, scale)`` is identically
equivalent to ``bradford.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import bradford
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.299
>>> mean, var, skew, kurt = bradford.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(bradford.ppf(0.01, c),
...                 bradford.ppf(0.99, c), 100)
>>> ax.plot(x, bradford.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='bradford pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = bradford(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = bradford.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], bradford.cdf(vals, c))
True

Generate random numbers:

>>> r = bradford.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

brunnermunzel:
Firma: (x, y, alternative='two-sided', distribution='t', nan_policy='propagate', *, axis=0, keepdims=False)

Docstring:
Compute the Brunner-Munzel test on samples x and y.

The Brunner-Munzel test is a nonparametric test of the null hypothesis that
when values are taken one by one from each group, the probabilities of
getting large values in both groups are equal.
Unlike the Wilcoxon-Mann-Whitney's U test, this does not require the
assumption of equivariance of two groups. Note that this does not assume
the distributions are same. This test works on two independent samples,
which may have different sizes.

Parameters
----------
x, y : array_like
    Array of samples, should be one-dimensional.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):
    
      * 'two-sided'
      * 'less': one-sided
      * 'greater': one-sided
distribution : {'t', 'normal'}, optional
    Defines how to get the p-value.
    The following options are available (default is 't'):
    
      * 't': get the p-value by t-distribution
      * 'normal': get the p-value by standard normal distribution.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The Brunner-Munzer W statistic.
pvalue : float
    p-value assuming an t distribution. One-sided or
    two-sided, depending on the choice of `alternative` and `distribution`.

See Also
--------

:func:`mannwhitneyu`
    Mann-Whitney rank test on two samples.


Notes
-----
Brunner and Munzel recommended to estimate the p-value by t-distribution
when the size of data is 50 or less. If the size is lower than 10, it would
be better to use permuted Brunner Munzel test (see [2]_).

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Brunner, E. and Munzel, U. "The nonparametric Benhrens-Fisher
       problem: Asymptotic theory and a small-sample approximation".
       Biometrical Journal. Vol. 42(2000): 17-25.
.. [2] Neubert, K. and Brunner, E. "A studentized permutation test for the
       non-parametric Behrens-Fisher problem". Computational Statistics and
       Data Analysis. Vol. 51(2007): 5192-5204.

Examples
--------
>>> from scipy import stats
>>> x1 = [1,2,1,1,1,1,1,1,1,1,2,4,1,1]
>>> x2 = [3,3,4,3,1,2,3,1,1,5,4]
>>> w, p_value = stats.brunnermunzel(x1, x2)
>>> w
3.1374674823029505
>>> p_value
0.0057862086661515377
================================================================================

burr:
Firma: (*args, **kwds)

Docstring:
A Burr (Type III) continuous random variable.

As an instance of the `rv_continuous` class, `burr` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, d, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, d, loc=0, scale=1)
    Probability density function.
logpdf(x, c, d, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, d, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, d, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, d, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, d, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, d, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, d, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, d, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, d, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, d, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c, d), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, d, loc=0, scale=1)
    Median of the distribution.
mean(c, d, loc=0, scale=1)
    Mean of the distribution.
var(c, d, loc=0, scale=1)
    Variance of the distribution.
std(c, d, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, d, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
fisk : a special case of either `burr` or `burr12` with ``d=1``
burr12 : Burr Type XII distribution
mielke : Mielke Beta-Kappa / Dagum distribution

Notes
-----
The probability density function for `burr` is:

.. math::

    f(x; c, d) = c d \frac{x^{-c - 1}}
                          {{(1 + x^{-c})}^{d + 1}}

for :math:`x >= 0` and :math:`c, d > 0`.

`burr` takes ``c`` and ``d`` as shape parameters for :math:`c` and
:math:`d`.

This is the PDF corresponding to the third CDF given in Burr's list;
specifically, it is equation (11) in Burr's paper [1]_. The distribution
is also commonly referred to as the Dagum distribution [2]_. If the
parameter :math:`c < 1` then the mean of the distribution does not
exist and if :math:`c < 2` the variance does not exist [2]_.
The PDF is finite at the left endpoint :math:`x = 0` if :math:`c * d >= 1`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``burr.pdf(x, c, d, loc, scale)`` is identically
equivalent to ``burr.pdf(y, c, d) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Burr, I. W. "Cumulative frequency functions", Annals of
   Mathematical Statistics, 13(2), pp 215-232 (1942).
.. [2] https://en.wikipedia.org/wiki/Dagum_distribution
.. [3] Kleiber, Christian. "A guide to the Dagum distributions."
   Modeling Income Distributions and Lorenz Curves  pp 97-117 (2008).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import burr
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c, d = 10.5, 4.3
>>> mean, var, skew, kurt = burr.stats(c, d, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(burr.ppf(0.01, c, d),
...                 burr.ppf(0.99, c, d), 100)
>>> ax.plot(x, burr.pdf(x, c, d),
...        'r-', lw=5, alpha=0.6, label='burr pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = burr(c, d)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = burr.ppf([0.001, 0.5, 0.999], c, d)
>>> np.allclose([0.001, 0.5, 0.999], burr.cdf(vals, c, d))
True

Generate random numbers:

>>> r = burr.rvs(c, d, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

burr12:
Firma: (*args, **kwds)

Docstring:
A Burr (Type XII) continuous random variable.

As an instance of the `rv_continuous` class, `burr12` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, d, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, d, loc=0, scale=1)
    Probability density function.
logpdf(x, c, d, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, d, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, d, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, d, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, d, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, d, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, d, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, d, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, d, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, d, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c, d), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, d, loc=0, scale=1)
    Median of the distribution.
mean(c, d, loc=0, scale=1)
    Mean of the distribution.
var(c, d, loc=0, scale=1)
    Variance of the distribution.
std(c, d, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, d, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
fisk : a special case of either `burr` or `burr12` with ``d=1``
burr : Burr Type III distribution

Notes
-----
The probability density function for `burr12` is:

.. math::

    f(x; c, d) = c d \frac{x^{c-1}}
                          {(1 + x^c)^{d + 1}}

for :math:`x >= 0` and :math:`c, d > 0`.

`burr12` takes ``c`` and ``d`` as shape parameters for :math:`c`
and :math:`d`.

This is the PDF corresponding to the twelfth CDF given in Burr's list;
specifically, it is equation (20) in Burr's paper [1]_.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``burr12.pdf(x, c, d, loc, scale)`` is identically
equivalent to ``burr12.pdf(y, c, d) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The Burr type 12 distribution is also sometimes referred to as
the Singh-Maddala distribution from NIST [2]_.

References
----------
.. [1] Burr, I. W. "Cumulative frequency functions", Annals of
   Mathematical Statistics, 13(2), pp 215-232 (1942).

.. [2] https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/b12pdf.htm

.. [3] "Burr distribution",
   https://en.wikipedia.org/wiki/Burr_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import burr12
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c, d = 10, 4
>>> mean, var, skew, kurt = burr12.stats(c, d, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(burr12.ppf(0.01, c, d),
...                 burr12.ppf(0.99, c, d), 100)
>>> ax.plot(x, burr12.pdf(x, c, d),
...        'r-', lw=5, alpha=0.6, label='burr12 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = burr12(c, d)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = burr12.ppf([0.001, 0.5, 0.999], c, d)
>>> np.allclose([0.001, 0.5, 0.999], burr12.cdf(vals, c, d))
True

Generate random numbers:

>>> r = burr12.rvs(c, d, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

bws_test:
Firma: (x, y, *, alternative='two-sided', method=None)

Docstring:
Perform the Baumgartner-Weiss-Schindler test on two independent samples.

The Baumgartner-Weiss-Schindler (BWS) test is a nonparametric test of 
the null hypothesis that the distribution underlying sample `x` 
is the same as the distribution underlying sample `y`. Unlike 
the Kolmogorov-Smirnov, Wilcoxon, and Cramer-Von Mises tests, 
the BWS test weights the integral by the variance of the difference
in cumulative distribution functions (CDFs), emphasizing the tails of the
distributions, which increases the power of the test in many applications.

Parameters
----------
x, y : array-like
    1-d arrays of samples.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    Let *F(u)* and *G(u)* be the cumulative distribution functions of the
    distributions underlying `x` and `y`, respectively. Then the following
    alternative hypotheses are available:

    * 'two-sided': the distributions are not equal, i.e. *F(u) ≠ G(u)* for
      at least one *u*.
    * 'less': the distribution underlying `x` is stochastically less than
      the distribution underlying `y`, i.e. *F(u) >= G(u)* for all *u*.
    * 'greater': the distribution underlying `x` is stochastically greater
      than the distribution underlying `y`, i.e. *F(u) <= G(u)* for all
      *u*.

    Under a more restrictive set of assumptions, the alternative hypotheses
    can be expressed in terms of the locations of the distributions;
    see [2] section 5.1.
method : PermutationMethod, optional
    Configures the method used to compute the p-value. The default is
    the default `PermutationMethod` object.

Returns
-------
res : PermutationTestResult
An object with attributes:

statistic : float
    The observed test statistic of the data.
pvalue : float
    The p-value for the given alternative.
null_distribution : ndarray
    The values of the test statistic generated under the null hypothesis.

See also
--------
scipy.stats.wilcoxon, scipy.stats.mannwhitneyu, scipy.stats.ttest_ind

Notes
-----
When ``alternative=='two-sided'``, the statistic is defined by the
equations given in [1]_ Section 2. This statistic is not appropriate for
one-sided alternatives; in that case, the statistic is the *negative* of
that given by the equations in [1]_ Section 2. Consequently, when the
distribution of the first sample is stochastically greater than that of the
second sample, the statistic will tend to be positive.

References
----------
.. [1] Neuhäuser, M. (2005). Exact Tests Based on the
       Baumgartner-Weiss-Schindler Statistic: A Survey. Statistical Papers,
       46(1), 1-29.
.. [2] Fay, M. P., & Proschan, M. A. (2010). Wilcoxon-Mann-Whitney or t-test?
       On assumptions for hypothesis tests and multiple interpretations of 
       decision rules. Statistics surveys, 4, 1.

Examples
--------
We follow the example of table 3 in [1]_: Fourteen children were divided
randomly into two groups. Their ranks at performing a specific tests are
as follows.

>>> import numpy as np
>>> x = [1, 2, 3, 4, 6, 7, 8]
>>> y = [5, 9, 10, 11, 12, 13, 14]

We use the BWS test to assess whether there is a statistically significant
difference between the two groups.
The null hypothesis is that there is no difference in the distributions of
performance between the two groups. We decide that a significance level of
1% is required to reject the null hypothesis in favor of the alternative
that the distributions are different.
Since the number of samples is very small, we can compare the observed test
statistic against the *exact* distribution of the test statistic under the
null hypothesis.

>>> from scipy.stats import bws_test
>>> res = bws_test(x, y)
>>> print(res.statistic)
5.132167152575315

This agrees with :math:`B = 5.132` reported in [1]_. The *p*-value produced
by `bws_test` also agrees with :math:`p = 0.0029` reported in [1]_.

>>> print(res.pvalue)
0.002913752913752914

Because the p-value is below our threshold of 1%, we take this as evidence
against the null hypothesis in favor of the alternative that there is a
difference in performance between the two groups.
================================================================================

cauchy:
Firma: (*args, **kwds)

Docstring:
A Cauchy continuous random variable.

As an instance of the `rv_continuous` class, `cauchy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `cauchy` is

.. math::

    f(x) = \frac{1}{\pi (1 + x^2)}

for a real number :math:`x`.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``ppf` and ``isf`` methods. [1]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``cauchy.pdf(x, loc, scale)`` is identically
equivalent to ``cauchy.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import cauchy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = cauchy.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(cauchy.ppf(0.01),
...                 cauchy.ppf(0.99), 100)
>>> ax.plot(x, cauchy.pdf(x),
...        'r-', lw=5, alpha=0.6, label='cauchy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = cauchy()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = cauchy.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], cauchy.cdf(vals))
True

Generate random numbers:

>>> r = cauchy.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

chatterjeexi:
Firma: (x, y, *, axis=0, y_continuous=False, method='asymptotic', nan_policy='propagate', keepdims=False)

Docstring:
Compute the xi correlation and perform a test of independence

The xi correlation coefficient is a measure of association between two
variables; the value tends to be close to zero when the variables are
independent and close to 1 when there is a strong association. Unlike
other correlation coefficients, the xi correlation is effective even
when the association is not monotonic.

Parameters
----------
x, y : array-like
    The samples: corresponding observations of the independent and
    dependent variable. The (N-d) arrays must be broadcastable.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
method : 'asymptotic' or `PermutationMethod` instance, optional
    Selects the method used to calculate the *p*-value.
    Default is 'asymptotic'. The following options are available.
    
    * ``'asymptotic'``: compares the standardized test statistic
      against the normal distribution.
    * `PermutationMethod` instance. In this case, the p-value
      is computed using `permutation_test` with the provided
      configuration options and other appropriate settings.
y_continuous : bool, default: False
    Whether `y` is assumed to be drawn from a continuous distribution.
    If `y` is drawn from a continuous distribution, results are valid
    whether this is assumed or not, but enabling this assumption will
    result in faster computation and typically produce similar results.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : SignificanceResult
    An object containing attributes:
    
    statistic : float
        The xi correlation statistic.
    pvalue : float
        The associated *p*-value: the probability of a statistic at least as
        high as the observed value under the null hypothesis of independence.

See Also
--------

:func:`scipy.stats.pearsonr`, :func:`scipy.stats.spearmanr`, :func:`scipy.stats.kendalltau`
    ..

Notes
-----
There is currently no special handling of ties in `x`; they are broken arbitrarily
by the implementation.

[1]_ notes that the statistic is not symmetric in `x` and `y` *by design*:
"...we may want to understand if :math:`Y` is a function :math:`X`, and not just
if one of the variables is a function of the other." See [1]_ Remark 1.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Chatterjee, Sourav. "A new coefficient of correlation." Journal of
       the American Statistical Association 116.536 (2021): 2009-2022.
       :doi:`10.1080/01621459.2020.1758115`.

Examples
--------
Generate perfectly correlated data, and observe that the xi correlation is
nearly 1.0.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng(348932549825235)
>>> x = rng.uniform(0, 10, size=100)
>>> y = np.sin(x)
>>> res = stats.chatterjeexi(x, y)
>>> res.statistic
np.float64(0.9012901290129013)

The probability of observing such a high value of the statistic under the
null hypothesis of independence is very low.

>>> res.pvalue
np.float64(2.2206974648177804e-46)

As noise is introduced, the correlation coefficient decreases.

>>> noise = rng.normal(scale=[[0.1], [0.5], [1]], size=(3, 100))
>>> res = stats.chatterjeexi(x, y + noise, axis=-1)
>>> res.statistic
array([0.79507951, 0.41824182, 0.16651665])

Because the distribution of `y` is continuous, it is valid to pass
``y_continuous=True``. The statistic is identical, and the p-value
(not shown) is only slightly different.

>>> stats.chatterjeexi(x, y + noise, y_continuous=True, axis=-1).statistic
array([0.79507951, 0.41824182, 0.16651665])
================================================================================

chi:
Firma: (*args, **kwds)

Docstring:
A chi continuous random variable.

As an instance of the `rv_continuous` class, `chi` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(df, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, df, loc=0, scale=1)
    Probability density function.
logpdf(x, df, loc=0, scale=1)
    Log of the probability density function.
cdf(x, df, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, df, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, df, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, df, loc=0, scale=1)
    Log of the survival function.
ppf(q, df, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, df, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, df, loc=0, scale=1)
    Non-central moment of the specified order.
stats(df, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(df, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(df,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(df, loc=0, scale=1)
    Median of the distribution.
mean(df, loc=0, scale=1)
    Mean of the distribution.
var(df, loc=0, scale=1)
    Variance of the distribution.
std(df, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, df, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `chi` is:

.. math::

    f(x, k) = \frac{1}{2^{k/2-1} \Gamma \left( k/2 \right)}
               x^{k-1} \exp \left( -x^2/2 \right)

for :math:`x >= 0` and :math:`k > 0` (degrees of freedom, denoted ``df``
in the implementation). :math:`\Gamma` is the gamma function
(`scipy.special.gamma`).

Special cases of `chi` are:

    - ``chi(1, loc, scale)`` is equivalent to `halfnorm`
    - ``chi(2, 0, scale)`` is equivalent to `rayleigh`
    - ``chi(3, 0, scale)`` is equivalent to `maxwell`

`chi` takes ``df`` as a shape parameter.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``chi.pdf(x, df, loc, scale)`` is identically
equivalent to ``chi.pdf(y, df) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import chi
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> df = 78
>>> mean, var, skew, kurt = chi.stats(df, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(chi.ppf(0.01, df),
...                 chi.ppf(0.99, df), 100)
>>> ax.plot(x, chi.pdf(x, df),
...        'r-', lw=5, alpha=0.6, label='chi pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = chi(df)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = chi.ppf([0.001, 0.5, 0.999], df)
>>> np.allclose([0.001, 0.5, 0.999], chi.cdf(vals, df))
True

Generate random numbers:

>>> r = chi.rvs(df, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

chi2:
Firma: (*args, **kwds)

Docstring:
A chi-squared continuous random variable.

For the noncentral chi-square distribution, see `ncx2`.

As an instance of the `rv_continuous` class, `chi2` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(df, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, df, loc=0, scale=1)
    Probability density function.
logpdf(x, df, loc=0, scale=1)
    Log of the probability density function.
cdf(x, df, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, df, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, df, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, df, loc=0, scale=1)
    Log of the survival function.
ppf(q, df, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, df, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, df, loc=0, scale=1)
    Non-central moment of the specified order.
stats(df, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(df, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(df,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(df, loc=0, scale=1)
    Median of the distribution.
mean(df, loc=0, scale=1)
    Mean of the distribution.
var(df, loc=0, scale=1)
    Variance of the distribution.
std(df, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, df, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
ncx2

Notes
-----
The probability density function for `chi2` is:

.. math::

    f(x, k) = \frac{1}{2^{k/2} \Gamma \left( k/2 \right)}
               x^{k/2-1} \exp \left( -x/2 \right)

for :math:`x > 0`  and :math:`k > 0` (degrees of freedom, denoted ``df``
in the implementation).

`chi2` takes ``df`` as a shape parameter.

The chi-squared distribution is a special case of the gamma
distribution, with gamma parameters ``a = df/2``, ``loc = 0`` and
``scale = 2``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``chi2.pdf(x, df, loc, scale)`` is identically
equivalent to ``chi2.pdf(y, df) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import chi2
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> df = 55
>>> mean, var, skew, kurt = chi2.stats(df, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(chi2.ppf(0.01, df),
...                 chi2.ppf(0.99, df), 100)
>>> ax.plot(x, chi2.pdf(x, df),
...        'r-', lw=5, alpha=0.6, label='chi2 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = chi2(df)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = chi2.ppf([0.001, 0.5, 0.999], df)
>>> np.allclose([0.001, 0.5, 0.999], chi2.cdf(vals, df))
True

Generate random numbers:

>>> r = chi2.rvs(df, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

chi2_contingency:
Firma: (observed, correction=True, lambda_=None, *, method=None)

Docstring:
Chi-square test of independence of variables in a contingency table.

This function computes the chi-square statistic and p-value for the
hypothesis test of independence of the observed frequencies in the
contingency table [1]_ `observed`.  The expected frequencies are computed
based on the marginal sums under the assumption of independence; see
`scipy.stats.contingency.expected_freq`.  The number of degrees of
freedom is (expressed using numpy functions and attributes)::

    dof = observed.size - sum(observed.shape) + observed.ndim - 1


Parameters
----------
observed : array_like
    The contingency table. The table contains the observed frequencies
    (i.e. number of occurrences) in each category.  In the two-dimensional
    case, the table is often described as an "R x C table".
correction : bool, optional
    If True, *and* the degrees of freedom is 1, apply Yates' correction
    for continuity.  The effect of the correction is to adjust each
    observed value by 0.5 towards the corresponding expected value.
lambda_ : float or str, optional
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic [2]_.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family [3]_ to be used instead.  See
    `scipy.stats.power_divergence` for details.
method : ResamplingMethod, optional
    Defines the method used to compute the p-value. Compatible only with
    `correction=False`,  default `lambda_`, and two-way tables.
    If `method` is an instance of `PermutationMethod`/`MonteCarloMethod`,
    the p-value is computed using
    `scipy.stats.permutation_test`/`scipy.stats.monte_carlo_test` with the
    provided configuration options and other appropriate settings.
    Otherwise, the p-value is computed as documented in the notes.
    Note that if `method` is an instance of `MonteCarloMethod`, the ``rvs``
    attribute must be left unspecified; Monte Carlo samples are always drawn
    using the ``rvs`` method of `scipy.stats.random_table`.

    .. versionadded:: 1.15.0


Returns
-------
res : Chi2ContingencyResult
    An object containing attributes:

    statistic : float
        The test statistic.
    pvalue : float
        The p-value of the test.
    dof : int
        The degrees of freedom. NaN if `method` is not ``None``.
    expected_freq : ndarray, same shape as `observed`
        The expected frequencies, based on the marginal sums of the table.

See Also
--------
scipy.stats.contingency.expected_freq
scipy.stats.fisher_exact
scipy.stats.chisquare
scipy.stats.power_divergence
scipy.stats.barnard_exact
scipy.stats.boschloo_exact
:ref:`hypothesis_chi2_contingency` : Extended example

Notes
-----
An often quoted guideline for the validity of this calculation is that
the test should be used only if the observed and expected frequencies
in each cell are at least 5.

This is a test for the independence of different categories of a
population. The test is only meaningful when the dimension of
`observed` is two or more.  Applying the test to a one-dimensional
table will always result in `expected` equal to `observed` and a
chi-square statistic equal to 0.

This function does not handle masked arrays, because the calculation
does not make sense with missing values.

Like `scipy.stats.chisquare`, this function computes a chi-square
statistic; the convenience this function provides is to figure out the
expected frequencies and degrees of freedom from the given contingency
table. If these were already known, and if the Yates' correction was not
required, one could use `scipy.stats.chisquare`.  That is, if one calls::

    res = chi2_contingency(obs, correction=False)

then the following is true::

    (res.statistic, res.pvalue) == stats.chisquare(obs.ravel(),
                                                   f_exp=ex.ravel(),
                                                   ddof=obs.size - 1 - dof)

The `lambda_` argument was added in version 0.13.0 of scipy.

References
----------
.. [1] "Contingency table",
       https://en.wikipedia.org/wiki/Contingency_table
.. [2] "Pearson's chi-squared test",
       https://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
.. [3] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------
A two-way example (2 x 3):

>>> import numpy as np
>>> from scipy.stats import chi2_contingency
>>> obs = np.array([[10, 10, 20], [20, 20, 20]])
>>> res = chi2_contingency(obs)
>>> res.statistic
2.7777777777777777
>>> res.pvalue
0.24935220877729619
>>> res.dof
2
>>> res.expected_freq
array([[ 12.,  12.,  16.],
       [ 18.,  18.,  24.]])

Perform the test using the log-likelihood ratio (i.e. the "G-test")
instead of Pearson's chi-squared statistic.

>>> res = chi2_contingency(obs, lambda_="log-likelihood")
>>> res.statistic
2.7688587616781319
>>> res.pvalue
0.25046668010954165

A four-way example (2 x 2 x 2 x 2):

>>> obs = np.array(
...     [[[[12, 17],
...        [11, 16]],
...       [[11, 12],
...        [15, 16]]],
...      [[[23, 15],
...        [30, 22]],
...       [[14, 17],
...        [15, 16]]]])
>>> res = chi2_contingency(obs)
>>> res.statistic
8.7584514426741897
>>> res.pvalue
0.64417725029295503

When the sum of the elements in a two-way table is small, the p-value
produced by the default asymptotic approximation may be inaccurate.
Consider passing a `PermutationMethod` or `MonteCarloMethod` as the
`method` parameter with `correction=False`.

>>> from scipy.stats import PermutationMethod
>>> obs = np.asarray([[12, 3],
...                   [17, 16]])
>>> res = chi2_contingency(obs, correction=False)
>>> ref = chi2_contingency(obs, correction=False, method=PermutationMethod())
>>> res.pvalue, ref.pvalue
(0.0614122539870913, 0.1074)  # may vary

For a more detailed example, see :ref:`hypothesis_chi2_contingency`.
================================================================================

chisquare:
Firma: (f_obs, f_exp=None, ddof=0, axis=0, *, sum_check=True)

Docstring:
Perform Pearson's chi-squared test.

Pearson's chi-squared test [1]_ is a goodness-of-fit test for a multinomial
distribution with given probabilities; that is, it assesses the null hypothesis
that the observed frequencies (counts) are obtained by independent
sampling of *N* observations from a categorical distribution with given
expected frequencies.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category. By default, the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where ``k``
    is the number of categories.  The default value of `ddof` is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.
sum_check : bool, optional
    Whether to perform a check that ``sum(f_obs) - sum(f_exp) == 0``. If True,
    (default) raise an error when the relative difference exceeds the square root
    of the precision of the data type. See Notes for rationale and possible
    exceptions.

Returns
-------
res: Power_divergenceResult
    An object containing attributes:

    statistic : float or ndarray
        The chi-squared test statistic.  The value is a float if `axis` is
        None or `f_obs` and `f_exp` are 1-D.
    pvalue : float or ndarray
        The p-value of the test.  The value is a float if `ddof` and the
        result attribute `statistic` are scalars.

See Also
--------
scipy.stats.power_divergence
scipy.stats.fisher_exact : Fisher exact test on a 2x2 contingency table.
scipy.stats.barnard_exact : An unconditional exact test. An alternative
    to chi-squared test for small sample sizes.
:ref:`hypothesis_chisquare` : Extended example

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5. According to [2]_, the
total number of observations is recommended to be greater than 13,
otherwise exact tests (such as Barnard's Exact test) should be used
because they do not overreject.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not chi-square, in which case this test
is not appropriate.

For Pearson's chi-squared test, the total observed and expected counts must match
for the p-value to accurately reflect the probability of observing such an extreme
value of the statistic under the null hypothesis.
This function may be used to perform other statistical tests that do not require
the total counts to be equal. For instance, to test the null hypothesis that
``f_obs[i]`` is Poisson-distributed with expectation ``f_exp[i]``, set ``ddof=-1``
and ``sum_check=False``. This test follows from the fact that a Poisson random
variable with mean and variance ``f_exp[i]`` is approximately normal with the
same mean and variance; the chi-squared statistic standardizes, squares, and sums
the observations; and the sum of ``n`` squared standard normal variables follows
the chi-squared distribution with ``n`` degrees of freedom.

References
----------
.. [1] "Pearson's chi-squared test".
       *Wikipedia*. https://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
.. [2] Pearson, Karl. "On the criterion that a given system of deviations from the probable
       in the case of a correlated system of variables is such that it can be reasonably
       supposed to have arisen from random sampling", Philosophical Magazine. Series 5. 50
       (1900), pp. 157-175.

Examples
--------
When only the mandatory `f_obs` argument is given, it is assumed that the
expected frequencies are uniform and given by the mean of the observed
frequencies:

>>> import numpy as np
>>> from scipy.stats import chisquare
>>> chisquare([16, 18, 16, 14, 12, 12])
Power_divergenceResult(statistic=2.0, pvalue=0.84914503608460956)

The optional `f_exp` argument gives the expected frequencies.

>>> chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
Power_divergenceResult(statistic=3.5, pvalue=0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

>>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
>>> obs.shape
(6, 2)
>>> chisquare(obs)
Power_divergenceResult(statistic=array([2.        , 6.66666667]), pvalue=array([0.84914504, 0.24663415]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

>>> chisquare(obs, axis=None)
Power_divergenceResult(statistic=23.31034482758621, pvalue=0.015975692534127565)
>>> chisquare(obs.ravel())
Power_divergenceResult(statistic=23.310344827586206, pvalue=0.01597569253412758)

`ddof` is the change to make to the default degrees of freedom.

>>> chisquare([16, 18, 16, 14, 12, 12], ddof=1)
Power_divergenceResult(statistic=2.0, pvalue=0.7357588823428847)

The calculation of the p-values is done by broadcasting the
chi-squared statistic with `ddof`.

>>> chisquare([16, 18, 16, 14, 12, 12], ddof=[0, 1, 2])
Power_divergenceResult(statistic=2.0, pvalue=array([0.84914504, 0.73575888, 0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we use ``axis=1``:

>>> chisquare([16, 18, 16, 14, 12, 12],
...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
...           axis=1)
Power_divergenceResult(statistic=array([3.5 , 9.25]), pvalue=array([0.62338763, 0.09949846]))

For a more detailed example, see :ref:`hypothesis_chisquare`.
================================================================================

circmean:
Firma: (samples, high=6.283185307179586, low=0, axis=None, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the circular mean of a sample of angle observations.

Given :math:`n` angle observations :math:`x_1, \cdots, x_n` measured in
radians, their *circular mean* is defined by ([1]_, Eq. 2.2.4)

.. math::

   \mathrm{Arg} \left( \frac{1}{n} \sum_{k=1}^n e^{i x_k} \right)

where :math:`i` is the imaginary unit and :math:`\mathop{\mathrm{Arg}} z`
gives the principal value of the argument of complex number :math:`z`,
restricted to the range :math:`[0,2\pi]` by default.  :math:`z` in the
above expression is known as the `mean resultant vector`.

Parameters
----------
samples : array_like
    Input array of angle observations.  The value of a full angle is
    equal to ``(high - low)``.
high : float, optional
    Upper boundary of the principal value of an angle.  Default is ``2*pi``.
low : float, optional
    Lower boundary of the principal value of an angle.  Default is ``0``.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
circmean : float
    Circular mean, restricted to the range ``[low, high]``.
    
    If the mean resultant vector is zero, an input-dependent,
    implementation-defined number between ``[low, high]`` is returned.
    If the input array is empty, ``np.nan`` is returned.

See Also
--------

:func:`circstd`
    Circular standard deviation.
:func:`circvar`
    Circular variance.


Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Mardia, K. V. and Jupp, P. E. *Directional Statistics*.
       John Wiley & Sons, 1999.

Examples
--------
For readability, all angles are printed out in degrees.

>>> import numpy as np
>>> from scipy.stats import circmean
>>> import matplotlib.pyplot as plt
>>> angles = np.deg2rad(np.array([20, 30, 330]))
>>> circmean = circmean(angles)
>>> np.rad2deg(circmean)
7.294976657784009

>>> mean = angles.mean()
>>> np.rad2deg(mean)
126.66666666666666

Plot and compare the circular mean against the arithmetic mean.

>>> plt.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...          np.sin(np.linspace(0, 2*np.pi, 500)),
...          c='k')
>>> plt.scatter(np.cos(angles), np.sin(angles), c='k')
>>> plt.scatter(np.cos(circmean), np.sin(circmean), c='b',
...             label='circmean')
>>> plt.scatter(np.cos(mean), np.sin(mean), c='r', label='mean')
>>> plt.legend()
>>> plt.axis('equal')
>>> plt.show()
================================================================================

circstd:
Firma: (samples, high=6.283185307179586, low=0, axis=None, nan_policy='propagate', *, normalize=False, keepdims=False)

Docstring:
Compute the circular standard deviation of a sample of angle observations.

Given :math:`n` angle observations :math:`x_1, \cdots, x_n` measured in
radians, their `circular standard deviation` is defined by
([2]_, Eq. 2.3.11)

.. math::

   \sqrt{ -2 \log \left| \frac{1}{n} \sum_{k=1}^n e^{i x_k} \right| }

where :math:`i` is the imaginary unit and :math:`|z|` gives the length
of the complex number :math:`z`.  :math:`|z|` in the above expression
is known as the `mean resultant length`.

Parameters
----------
samples : array_like
    Input array of angle observations.  The value of a full angle is
    equal to ``(high - low)``.
high : float, optional
    Upper boundary of the principal value of an angle.  Default is ``2*pi``.
low : float, optional
    Lower boundary of the principal value of an angle.  Default is ``0``.
normalize : boolean, optional
    If ``False`` (the default), the return value is computed from the
    above formula with the input scaled by ``(2*pi)/(high-low)`` and
    the output scaled (back) by ``(high-low)/(2*pi)``.  If ``True``,
    the output is not scaled and is returned directly.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
circstd : float
    Circular standard deviation, optionally normalized.
    
    If the input array is empty, ``np.nan`` is returned.

See Also
--------

:func:`circmean`
    Circular mean.
:func:`circvar`
    Circular variance.


Notes
-----
In the limit of small angles, the circular standard deviation is close
to the 'linear' standard deviation if ``normalize`` is ``False``.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Mardia, K. V. (1972). 2. In *Statistics of Directional Data*
   (pp. 18-24). Academic Press. :doi:`10.1016/C2013-0-07425-7`.
.. [2] Mardia, K. V. and Jupp, P. E. *Directional Statistics*.
       John Wiley & Sons, 1999.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import circstd
>>> import matplotlib.pyplot as plt
>>> samples_1 = np.array([0.072, -0.158, 0.077, 0.108, 0.286,
...                       0.133, -0.473, -0.001, -0.348, 0.131])
>>> samples_2 = np.array([0.111, -0.879, 0.078, 0.733, 0.421,
...                       0.104, -0.136, -0.867,  0.012,  0.105])
>>> circstd_1 = circstd(samples_1)
>>> circstd_2 = circstd(samples_2)

Plot the samples.

>>> fig, (left, right) = plt.subplots(ncols=2)
>>> for image in (left, right):
...     image.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...                np.sin(np.linspace(0, 2*np.pi, 500)),
...                c='k')
...     image.axis('equal')
...     image.axis('off')
>>> left.scatter(np.cos(samples_1), np.sin(samples_1), c='k', s=15)
>>> left.set_title(f"circular std: {np.round(circstd_1, 2)!r}")
>>> right.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...            np.sin(np.linspace(0, 2*np.pi, 500)),
...            c='k')
>>> right.scatter(np.cos(samples_2), np.sin(samples_2), c='k', s=15)
>>> right.set_title(f"circular std: {np.round(circstd_2, 2)!r}")
>>> plt.show()
================================================================================

circvar:
Firma: (samples, high=6.283185307179586, low=0, axis=None, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the circular variance of a sample of angle observations.

Given :math:`n` angle observations :math:`x_1, \cdots, x_n` measured in
radians, their *circular variance* is defined by ([2]_, Eq. 2.3.3)

.. math::

   1 - \left| \frac{1}{n} \sum_{k=1}^n e^{i x_k} \right|

where :math:`i` is the imaginary unit and :math:`|z|` gives the length
of the complex number :math:`z`.  :math:`|z|` in the above expression
is known as the `mean resultant length`.

Parameters
----------
samples : array_like
    Input array of angle observations.  The value of a full angle is
    equal to ``(high - low)``.
high : float, optional
    Upper boundary of the principal value of an angle.  Default is ``2*pi``.
low : float, optional
    Lower boundary of the principal value of an angle.  Default is ``0``.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
circvar : float
    Circular variance.  The returned value is in the range ``[0, 1]``,
    where ``0`` indicates no variance and ``1`` indicates large variance.
    
    If the input array is empty, ``np.nan`` is returned.

See Also
--------

:func:`circmean`
    Circular mean.
:func:`circstd`
    Circular standard deviation.


Notes
-----
In the limit of small angles, the circular variance is close to
half the 'linear' variance if measured in radians.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Fisher, N.I. *Statistical analysis of circular data*. Cambridge
       University Press, 1993.
.. [2] Mardia, K. V. and Jupp, P. E. *Directional Statistics*.
       John Wiley & Sons, 1999.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import circvar
>>> import matplotlib.pyplot as plt
>>> samples_1 = np.array([0.072, -0.158, 0.077, 0.108, 0.286,
...                       0.133, -0.473, -0.001, -0.348, 0.131])
>>> samples_2 = np.array([0.111, -0.879, 0.078, 0.733, 0.421,
...                       0.104, -0.136, -0.867,  0.012,  0.105])
>>> circvar_1 = circvar(samples_1)
>>> circvar_2 = circvar(samples_2)

Plot the samples.

>>> fig, (left, right) = plt.subplots(ncols=2)
>>> for image in (left, right):
...     image.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...                np.sin(np.linspace(0, 2*np.pi, 500)),
...                c='k')
...     image.axis('equal')
...     image.axis('off')
>>> left.scatter(np.cos(samples_1), np.sin(samples_1), c='k', s=15)
>>> left.set_title(f"circular variance: {np.round(circvar_1, 2)!r}")
>>> right.scatter(np.cos(samples_2), np.sin(samples_2), c='k', s=15)
>>> right.set_title(f"circular variance: {np.round(circvar_2, 2)!r}")
>>> plt.show()
================================================================================

combine_pvalues:
Firma: (pvalues, method='fisher', weights=None, *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Combine p-values from independent tests that bear upon the same hypothesis.

These methods are intended only for combining p-values from hypothesis
tests based upon continuous distributions.

Each method assumes that under the null hypothesis, the p-values are
sampled independently and uniformly from the interval [0, 1]. A test
statistic (different for each method) is computed and a combined
p-value is calculated based upon the distribution of this test statistic
under the null hypothesis.

Parameters
----------
pvalues : array_like
    Array of p-values assumed to come from independent tests based on
    continuous distributions.
method : {'fisher', 'pearson', 'tippett', 'stouffer', 'mudholkar_george'}
    Name of method to use to combine p-values.
    
    The available methods are (see Notes for details):
    
    * 'fisher': Fisher's method (Fisher's combined probability test)
    * 'pearson': Pearson's method
    * 'mudholkar_george': Mudholkar's and George's method
    * 'tippett': Tippett's method
    * 'stouffer': Stouffer's Z-score method
weights : array_like, optional
    Optional array of weights used only for Stouffer's Z-score method.
    Ignored by other methods.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : SignificanceResult
    An object containing attributes:
    
    statistic : float
        The statistic calculated by the specified method.
    pvalue : float
        The combined p-value.

Notes
-----
If this function is applied to tests with a discrete statistics such as
any rank test or contingency-table test, it will yield systematically
wrong results, e.g. Fisher's method will systematically overestimate the
p-value [1]_. This problem becomes less severe for large sample sizes
when the discrete distributions become approximately continuous.

The differences between the methods can be best illustrated by their
statistics and what aspects of a combination of p-values they emphasise
when considering significance [2]_. For example, methods emphasising large
p-values are more sensitive to strong false and true negatives; conversely
methods focussing on small p-values are sensitive to positives.

* The statistics of Fisher's method (also known as Fisher's combined
  probability test) [3]_ is :math:`-2\sum_i \log(p_i)`, which is
  equivalent (as a test statistics) to the product of individual p-values:
  :math:`\prod_i p_i`. Under the null hypothesis, this statistics follows
  a :math:`\chi^2` distribution. This method emphasises small p-values.
* Pearson's method uses :math:`-2\sum_i\log(1-p_i)`, which is equivalent
  to :math:`\prod_i \frac{1}{1-p_i}` [2]_.
  It thus emphasises large p-values.
* Mudholkar and George compromise between Fisher's and Pearson's method by
  averaging their statistics [4]_. Their method emphasises extreme
  p-values, both close to 1 and 0.
* Stouffer's method [5]_ uses Z-scores and the statistic:
  :math:`\sum_i \Phi^{-1} (p_i)`, where :math:`\Phi` is the CDF of the
  standard normal distribution. The advantage of this method is that it is
  straightforward to introduce weights, which can make Stouffer's method
  more powerful than Fisher's method when the p-values are from studies
  of different size [6]_ [7]_.
* Tippett's method uses the smallest p-value as a statistic.
  (Mind that this minimum is not the combined p-value.)

Fisher's method may be extended to combine p-values from dependent tests
[8]_. Extensions such as Brown's method and Kost's method are not currently
implemented.

.. versionadded:: 0.15.0

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Kincaid, W. M., "The Combination of Tests Based on Discrete
       Distributions." Journal of the American Statistical Association 57,
       no. 297 (1962), 10-19.
.. [2] Heard, N. and Rubin-Delanchey, P. "Choosing between methods of
       combining p-values."  Biometrika 105.1 (2018): 239-246.
.. [3] https://en.wikipedia.org/wiki/Fisher%27s_method
.. [4] George, E. O., and G. S. Mudholkar. "On the convolution of logistic
       random variables." Metrika 30.1 (1983): 1-13.
.. [5] https://en.wikipedia.org/wiki/Fisher%27s_method#Relation_to_Stouffer.27s_Z-score_method
.. [6] Whitlock, M. C. "Combining probability from independent tests: the
       weighted Z-method is superior to Fisher's approach." Journal of
       Evolutionary Biology 18, no. 5 (2005): 1368-1373.
.. [7] Zaykin, Dmitri V. "Optimally weighted Z-test is a powerful method
       for combining probabilities in meta-analysis." Journal of
       Evolutionary Biology 24, no. 8 (2011): 1836-1841.
.. [8] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method

Examples
--------
Suppose we wish to combine p-values from four independent tests
of the same null hypothesis using Fisher's method (default).

>>> from scipy.stats import combine_pvalues
>>> pvalues = [0.1, 0.05, 0.02, 0.3]
>>> combine_pvalues(pvalues)
SignificanceResult(statistic=20.828626352604235, pvalue=0.007616871850449092)

When the individual p-values carry different weights, consider Stouffer's
method.

>>> weights = [1, 2, 3, 4]
>>> res = combine_pvalues(pvalues, method='stouffer', weights=weights)
>>> res.pvalue
0.009578891494533616
================================================================================

cosine:
Firma: (*args, **kwds)

Docstring:
A cosine continuous random variable.

As an instance of the `rv_continuous` class, `cosine` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The cosine distribution is an approximation to the normal distribution.
The probability density function for `cosine` is:

.. math::

    f(x) = \frac{1}{2\pi} (1+\cos(x))

for :math:`-\pi \le x \le \pi`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``cosine.pdf(x, loc, scale)`` is identically
equivalent to ``cosine.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import cosine
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = cosine.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(cosine.ppf(0.01),
...                 cosine.ppf(0.99), 100)
>>> ax.plot(x, cosine.pdf(x),
...        'r-', lw=5, alpha=0.6, label='cosine pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = cosine()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = cosine.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], cosine.cdf(vals))
True

Generate random numbers:

>>> r = cosine.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

cramervonmises:
Firma: (rvs, cdf, args=(), *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform the one-sample Cramér-von Mises test for goodness of fit.

This performs a test of the goodness of fit of a cumulative distribution
function (cdf) :math:`F` compared to the empirical distribution function
:math:`F_n` of observed random variates :math:`X_1, ..., X_n` that are
assumed to be independent and identically distributed ([1]_).
The null hypothesis is that the :math:`X_i` have cumulative distribution
:math:`F`.

Parameters
----------
rvs : array_like
    A 1-D array of observed values of the random variables :math:`X_i`.
    The sample must contain at least two observations.
cdf : str or callable
    The cumulative distribution function :math:`F` to test the
    observations against. If a string, it should be the name of a
    distribution in `scipy.stats`. If a callable, that callable is used
    to calculate the cdf: ``cdf(x, *args) -> float``.
args : tuple, optional
    Distribution parameters. These are assumed to be known; see Notes.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : object with attributes
    statistic : float
        Cramér-von Mises statistic.
    pvalue : float
        The p-value.

See Also
--------

:func:`kstest`, :func:`cramervonmises_2samp`
    ..

Notes
-----
.. versionadded:: 1.6.0

The p-value relies on the approximation given by equation 1.8 in [2]_.
It is important to keep in mind that the p-value is only accurate if
one tests a simple hypothesis, i.e. the parameters of the reference
distribution are known. If the parameters are estimated from the data
(composite hypothesis), the computed p-value is not reliable.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Cramér-von Mises criterion, Wikipedia,
       https://en.wikipedia.org/wiki/Cram%C3%A9r%E2%80%93von_Mises_criterion
.. [2] Csörgő, S. and Faraway, J. (1996). The Exact and Asymptotic
       Distribution of Cramér-von Mises Statistics. Journal of the
       Royal Statistical Society, pp. 221-234.

Examples
--------
Suppose we wish to test whether data generated by ``scipy.stats.norm.rvs``
were, in fact, drawn from the standard normal distribution. We choose a
significance level of ``alpha=0.05``.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng(165417232101553420507139617764912913465)
>>> x = stats.norm.rvs(size=500, random_state=rng)
>>> res = stats.cramervonmises(x, 'norm')
>>> res.statistic, res.pvalue
(0.1072085112565724, 0.5508482238203407)

The p-value exceeds our chosen significance level, so we do not
reject the null hypothesis that the observed sample is drawn from the
standard normal distribution.

Now suppose we wish to check whether the same samples shifted by 2.1 is
consistent with being drawn from a normal distribution with a mean of 2.

>>> y = x + 2.1
>>> res = stats.cramervonmises(y, 'norm', args=(2,))
>>> res.statistic, res.pvalue
(0.8364446265294695, 0.00596286797008283)

Here we have used the `args` keyword to specify the mean (``loc``)
of the normal distribution to test the data against. This is equivalent
to the following, in which we create a frozen normal distribution with
mean 2.1, then pass its ``cdf`` method as an argument.

>>> frozen_dist = stats.norm(loc=2)
>>> res = stats.cramervonmises(y, frozen_dist.cdf)
>>> res.statistic, res.pvalue
(0.8364446265294695, 0.00596286797008283)

In either case, we would reject the null hypothesis that the observed
sample is drawn from a normal distribution with a mean of 2 (and default
variance of 1) because the p-value is less than our chosen
significance level.
================================================================================

cramervonmises_2samp:
Firma: (x, y, method='auto', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform the two-sample Cramér-von Mises test for goodness of fit.

This is the two-sample version of the Cramér-von Mises test ([1]_):
for two independent samples :math:`X_1, ..., X_n` and
:math:`Y_1, ..., Y_m`, the null hypothesis is that the samples
come from the same (unspecified) continuous distribution.

Parameters
----------
x : array_like
    A 1-D array of observed values of the random variables :math:`X_i`.
    Must contain at least two observations.
y : array_like
    A 1-D array of observed values of the random variables :math:`Y_i`.
    Must contain at least two observations.
method : {'auto', 'asymptotic', 'exact'}, optional
    The method used to compute the p-value, see Notes for details.
    The default is 'auto'.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : object with attributes
    statistic : float
        Cramér-von Mises statistic.
    pvalue : float
        The p-value.

See Also
--------

:func:`cramervonmises`, :func:`anderson_ksamp`, :func:`epps_singleton_2samp`, :func:`ks_2samp`
    ..

Notes
-----
.. versionadded:: 1.7.0

The statistic is computed according to equation 9 in [2]_. The
calculation of the p-value depends on the keyword `method`:

- ``asymptotic``: The p-value is approximated by using the limiting
  distribution of the test statistic.
- ``exact``: The exact p-value is computed by enumerating all
  possible combinations of the test statistic, see [2]_.

If ``method='auto'``, the exact approach is used
if both samples contain equal to or less than 20 observations,
otherwise the asymptotic distribution is used.

If the underlying distribution is not continuous, the p-value is likely to
be conservative (Section 6.2 in [3]_). When ranking the data to compute
the test statistic, midranks are used if there are ties.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://en.wikipedia.org/wiki/Cramer-von_Mises_criterion
.. [2] Anderson, T.W. (1962). On the distribution of the two-sample
       Cramer-von-Mises criterion. The Annals of Mathematical
       Statistics, pp. 1148-1159.
.. [3] Conover, W.J., Practical Nonparametric Statistics, 1971.

Examples
--------
Suppose we wish to test whether two samples generated by
``scipy.stats.norm.rvs`` have the same distribution. We choose a
significance level of alpha=0.05.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = stats.norm.rvs(size=100, random_state=rng)
>>> y = stats.norm.rvs(size=70, random_state=rng)
>>> res = stats.cramervonmises_2samp(x, y)
>>> res.statistic, res.pvalue
(0.29376470588235293, 0.1412873014573014)

The p-value exceeds our chosen significance level, so we do not
reject the null hypothesis that the observed samples are drawn from the
same distribution.

For small sample sizes, one can compute the exact p-values:

>>> x = stats.norm.rvs(size=7, random_state=rng)
>>> y = stats.t.rvs(df=2, size=6, random_state=rng)
>>> res = stats.cramervonmises_2samp(x, y, method='exact')
>>> res.statistic, res.pvalue
(0.197802197802198, 0.31643356643356646)

The p-value based on the asymptotic distribution is a good approximation
even though the sample size is small.

>>> res = stats.cramervonmises_2samp(x, y, method='asymptotic')
>>> res.statistic, res.pvalue
(0.197802197802198, 0.2966041181527128)

Independent of the method, one would not reject the null hypothesis at the
chosen significance level in this example.
================================================================================

crystalball:
Firma: (*args, **kwds)

Docstring:
Crystalball distribution

As an instance of the `rv_continuous` class, `crystalball` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(beta, m, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, beta, m, loc=0, scale=1)
    Probability density function.
logpdf(x, beta, m, loc=0, scale=1)
    Log of the probability density function.
cdf(x, beta, m, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, beta, m, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, beta, m, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, beta, m, loc=0, scale=1)
    Log of the survival function.
ppf(q, beta, m, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, beta, m, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, beta, m, loc=0, scale=1)
    Non-central moment of the specified order.
stats(beta, m, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(beta, m, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(beta, m), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(beta, m, loc=0, scale=1)
    Median of the distribution.
mean(beta, m, loc=0, scale=1)
    Mean of the distribution.
var(beta, m, loc=0, scale=1)
    Variance of the distribution.
std(beta, m, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, beta, m, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `crystalball` is:

.. math::

    f(x, \beta, m) =  \begin{cases}
                        N \exp(-x^2 / 2),  &\text{for } x > -\beta\\
                        N A (B - x)^{-m}  &\text{for } x \le -\beta
                      \end{cases}

where :math:`A = (m / |\beta|)^m  \exp(-\beta^2 / 2)`,
:math:`B = m/|\beta| - |\beta|` and :math:`N` is a normalisation constant.

`crystalball` takes :math:`\beta > 0` and :math:`m > 1` as shape
parameters.  :math:`\beta` defines the point where the pdf changes
from a power-law to a Gaussian distribution.  :math:`m` is the power
of the power-law tail.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``crystalball.pdf(x, beta, m, loc, scale)`` is identically
equivalent to ``crystalball.pdf(y, beta, m) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

.. versionadded:: 0.19.0

References
----------
.. [1] "Crystal Ball Function",
       https://en.wikipedia.org/wiki/Crystal_Ball_function

Examples
--------
>>> import numpy as np
>>> from scipy.stats import crystalball
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> beta, m = 2, 3
>>> mean, var, skew, kurt = crystalball.stats(beta, m, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(crystalball.ppf(0.01, beta, m),
...                 crystalball.ppf(0.99, beta, m), 100)
>>> ax.plot(x, crystalball.pdf(x, beta, m),
...        'r-', lw=5, alpha=0.6, label='crystalball pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = crystalball(beta, m)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = crystalball.ppf([0.001, 0.5, 0.999], beta, m)
>>> np.allclose([0.001, 0.5, 0.999], crystalball.cdf(vals, beta, m))
True

Generate random numbers:

>>> r = crystalball.rvs(beta, m, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

cumfreq:
Firma: (a, numbins=10, defaultreallimits=None, weights=None)

Docstring:
Return a cumulative frequency histogram, using the histogram function.

A cumulative histogram is a mapping that counts the cumulative number of
observations in all of the bins up to the specified bin.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
cumcount : ndarray
    Binned values of cumulative frequency.
lowerlimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = [1, 4, 2, 1, 3, 1]
>>> res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))
>>> res.cumcount
array([ 1.,  2.,  3.,  3.])
>>> res.extrapoints
3

Create a normal distribution with 1000 random values

>>> samples = stats.norm.rvs(size=1000, random_state=rng)

Calculate cumulative frequencies

>>> res = stats.cumfreq(samples, numbins=25)

Calculate space of values for x

>>> x = res.lowerlimit + np.linspace(0, res.binsize*res.cumcount.size,
...                                  res.cumcount.size)

Plot histogram and cumulative histogram

>>> fig = plt.figure(figsize=(10, 4))
>>> ax1 = fig.add_subplot(1, 2, 1)
>>> ax2 = fig.add_subplot(1, 2, 2)
>>> ax1.hist(samples, bins=25)
>>> ax1.set_title('Histogram')
>>> ax2.bar(x, res.cumcount, width=res.binsize)
>>> ax2.set_title('Cumulative histogram')
>>> ax2.set_xlim([x.min(), x.max()])

>>> plt.show()
================================================================================

describe:
Firma: (a, axis=0, ddof=1, bias=True, nan_policy='propagate')

Docstring:
Compute several descriptive statistics of the passed array.

Parameters
----------
a : array_like
    Input data.
axis : int or None, optional
    Axis along which statistics are calculated. Default is 0.
    If None, compute over the whole array `a`.
ddof : int, optional
    Delta degrees of freedom (only for variance).  Default is 1.
bias : bool, optional
    If False, then the skewness and kurtosis calculations are corrected
    for statistical bias.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

Returns
-------
nobs : int or ndarray of ints
    Number of observations (length of data along `axis`).
    When 'omit' is chosen as nan_policy, the length along each axis
    slice is counted separately.
minmax: tuple of ndarrays or floats
    Minimum and maximum value of `a` along the given axis.
mean : ndarray or float
    Arithmetic mean of `a` along the given axis.
variance : ndarray or float
    Unbiased variance of `a` along the given axis; denominator is number
    of observations minus one.
skewness : ndarray or float
    Skewness of `a` along the given axis, based on moment calculations
    with denominator equal to the number of observations, i.e. no degrees
    of freedom correction.
kurtosis : ndarray or float
    Kurtosis (Fisher) of `a` along the given axis.  The kurtosis is
    normalized so that it is zero for the normal distribution.  No
    degrees of freedom are used.

Raises
------
ValueError
    If size of `a` is 0.

See Also
--------
skew, kurtosis

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> a = np.arange(10)
>>> stats.describe(a)
DescribeResult(nobs=10, minmax=(0, 9), mean=4.5,
               variance=9.166666666666666, skewness=0.0,
               kurtosis=-1.2242424242424244)
>>> b = [[1, 2], [3, 4]]
>>> stats.describe(b)
DescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])),
               mean=array([2., 3.]), variance=array([2., 2.]),
               skewness=array([0., 0.]), kurtosis=array([-2., -2.]))
================================================================================

dgamma:
Firma: (*args, **kwds)

Docstring:
A double gamma continuous random variable.

The double gamma distribution is also known as the reflected gamma
distribution [1]_.

As an instance of the `rv_continuous` class, `dgamma` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `dgamma` is:

.. math::

    f(x, a) = \frac{1}{2\Gamma(a)} |x|^{a-1} \exp(-|x|)

for a real number :math:`x` and :math:`a > 0`. :math:`\Gamma` is the
gamma function (`scipy.special.gamma`).

`dgamma` takes ``a`` as a shape parameter for :math:`a`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``dgamma.pdf(x, a, loc, scale)`` is identically
equivalent to ``dgamma.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Johnson, Kotz, and Balakrishnan, "Continuous Univariate
       Distributions, Volume 1", Second Edition, John Wiley and Sons
       (1994).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import dgamma
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 1.1
>>> mean, var, skew, kurt = dgamma.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(dgamma.ppf(0.01, a),
...                 dgamma.ppf(0.99, a), 100)
>>> ax.plot(x, dgamma.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='dgamma pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = dgamma(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = dgamma.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], dgamma.cdf(vals, a))
True

Generate random numbers:

>>> r = dgamma.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

differential_entropy:
Firma: (values: Union[collections.abc.Buffer, numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[bool | int | float | complex | str | bytes]], *, window_length: int | None = None, base: float | None = None, axis: int = 0, method: str = 'auto', nan_policy='propagate', keepdims=False) -> numpy.number | numpy.ndarray

Docstring:
Given a sample of a distribution, estimate the differential entropy.

Several estimation methods are available using the `method` parameter. By
default, a method is selected based the size of the sample.

Parameters
----------
values : sequence
    Sample from a continuous distribution.
window_length : int, optional
    Window length for computing Vasicek estimate. Must be an integer
    between 1 and half of the sample size. If ``None`` (the default), it
    uses the heuristic value
    
    .. math::
        \left \lfloor \sqrt{n} + 0.5 \right \rfloor
    
    where :math:`n` is the sample size. This heuristic was originally
    proposed in [2]_ and has become common in the literature.
base : float, optional
    The logarithmic base to use, defaults to ``e`` (natural logarithm).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
method : {'vasicek', 'van es', 'ebrahimi', 'correa', 'auto'}, optional
    The method used to estimate the differential entropy from the sample.
    Default is ``'auto'``.  See Notes for more information.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
entropy : float
    The calculated differential entropy.

Notes
-----
This function will converge to the true differential entropy in the limit

.. math::
    n \to \infty, \quad m \to \infty, \quad \frac{m}{n} \to 0

The optimal choice of ``window_length`` for a given sample size depends on
the (unknown) distribution. Typically, the smoother the density of the
distribution, the larger the optimal value of ``window_length`` [1]_.

The following options are available for the `method` parameter.

* ``'vasicek'`` uses the estimator presented in [1]_. This is
  one of the first and most influential estimators of differential entropy.
* ``'van es'`` uses the bias-corrected estimator presented in [3]_, which
  is not only consistent but, under some conditions, asymptotically normal.
* ``'ebrahimi'`` uses an estimator presented in [4]_, which was shown
  in simulation to have smaller bias and mean squared error than
  the Vasicek estimator.
* ``'correa'`` uses the estimator presented in [5]_ based on local linear
  regression. In a simulation study, it had consistently smaller mean
  square error than the Vasiceck estimator, but it is more expensive to
  compute.
* ``'auto'`` selects the method automatically (default). Currently,
  this selects ``'van es'`` for very small samples (<10), ``'ebrahimi'``
  for moderate sample sizes (11-1000), and ``'vasicek'`` for larger
  samples, but this behavior is subject to change in future versions.

All estimators are implemented as described in [6]_.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Vasicek, O. (1976). A test for normality based on sample entropy.
       Journal of the Royal Statistical Society:
       Series B (Methodological), 38(1), 54-59.
.. [2] Crzcgorzewski, P., & Wirczorkowski, R. (1999). Entropy-based
       goodness-of-fit test for exponentiality. Communications in
       Statistics-Theory and Methods, 28(5), 1183-1202.
.. [3] Van Es, B. (1992). Estimating functionals related to a density by a
       class of statistics based on spacings. Scandinavian Journal of
       Statistics, 61-72.
.. [4] Ebrahimi, N., Pflughoeft, K., & Soofi, E. S. (1994). Two measures
       of sample entropy. Statistics & Probability Letters, 20(3), 225-234.
.. [5] Correa, J. C. (1995). A new estimator of entropy. Communications
       in Statistics-Theory and Methods, 24(10), 2439-2449.
.. [6] Noughabi, H. A. (2015). Entropy Estimation Using Numerical Methods.
       Annals of Data Science, 2(2), 231-241.
       https://link.springer.com/article/10.1007/s40745-015-0045-9

Examples
--------
>>> import numpy as np
>>> from scipy.stats import differential_entropy, norm

Entropy of a standard normal distribution:

>>> rng = np.random.default_rng()
>>> values = rng.standard_normal(100)
>>> differential_entropy(values)
1.3407817436640392

Compare with the true entropy:

>>> float(norm.entropy())
1.4189385332046727

For several sample sizes between 5 and 1000, compare the accuracy of
the ``'vasicek'``, ``'van es'``, and ``'ebrahimi'`` methods. Specifically,
compare the root mean squared error (over 1000 trials) between the estimate
and the true differential entropy of the distribution.

>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>>
>>>
>>> def rmse(res, expected):
...     '''Root mean squared error'''
...     return np.sqrt(np.mean((res - expected)**2))
>>>
>>>
>>> a, b = np.log10(5), np.log10(1000)
>>> ns = np.round(np.logspace(a, b, 10)).astype(int)
>>> reps = 1000  # number of repetitions for each sample size
>>> expected = stats.expon.entropy()
>>>
>>> method_errors = {'vasicek': [], 'van es': [], 'ebrahimi': []}
>>> for method in method_errors:
...     for n in ns:
...        rvs = stats.expon.rvs(size=(reps, n), random_state=rng)
...        res = stats.differential_entropy(rvs, method=method, axis=-1)
...        error = rmse(res, expected)
...        method_errors[method].append(error)
>>>
>>> for method, errors in method_errors.items():
...     plt.loglog(ns, errors, label=method)
>>>
>>> plt.legend()
>>> plt.xlabel('sample size')
>>> plt.ylabel('RMSE (1000 trials)')
>>> plt.title('Entropy Estimator Error (Exponential Distribution)')
================================================================================

directional_stats:
Firma: (samples, *, axis=0, normalize=True)

Docstring:
Computes sample statistics for directional data.

Computes the directional mean (also called the mean direction vector) and
mean resultant length of a sample of vectors.

The directional mean is a measure of "preferred direction" of vector data.
It is analogous to the sample mean, but it is for use when the length of
the data is irrelevant (e.g. unit vectors).

The mean resultant length is a value between 0 and 1 used to quantify the
dispersion of directional data: the smaller the mean resultant length, the
greater the dispersion. Several definitions of directional variance
involving the mean resultant length are given in [1]_ and [2]_.

Parameters
----------
samples : array_like
    Input array. Must be at least two-dimensional, and the last axis of the
    input must correspond with the dimensionality of the vector space.
    When the input is exactly two dimensional, this means that each row
    of the data is a vector observation.
axis : int, default: 0
    Axis along which the directional mean is computed.
normalize: boolean, default: True
    If True, normalize the input to ensure that each observation is a
    unit vector. It the observations are already unit vectors, consider
    setting this to False to avoid unnecessary computation.

Returns
-------
res : DirectionalStats
    An object containing attributes:

    mean_direction : ndarray
        Directional mean.
    mean_resultant_length : ndarray
        The mean resultant length [1]_.

See Also
--------
circmean: circular mean; i.e. directional mean for 2D *angles*
circvar: circular variance; i.e. directional variance for 2D *angles*

Notes
-----
This uses a definition of directional mean from [1]_.
Assuming the observations are unit vectors, the calculation is as follows.

.. code-block:: python

    mean = samples.mean(axis=0)
    mean_resultant_length = np.linalg.norm(mean)
    mean_direction = mean / mean_resultant_length

This definition is appropriate for *directional* data (i.e. vector data
for which the magnitude of each observation is irrelevant) but not
for *axial* data (i.e. vector data for which the magnitude and *sign* of
each observation is irrelevant).

Several definitions of directional variance involving the mean resultant
length ``R`` have been proposed, including ``1 - R`` [1]_, ``1 - R**2``
[2]_, and ``2 * (1 - R)`` [2]_. Rather than choosing one, this function
returns ``R`` as attribute `mean_resultant_length` so the user can compute
their preferred measure of dispersion.

References
----------
.. [1] Mardia, Jupp. (2000). *Directional Statistics*
   (p. 163). Wiley.

.. [2] https://en.wikipedia.org/wiki/Directional_statistics

Examples
--------
>>> import numpy as np
>>> from scipy.stats import directional_stats
>>> data = np.array([[3, 4],    # first observation, 2D vector space
...                  [6, -8]])  # second observation
>>> dirstats = directional_stats(data)
>>> dirstats.mean_direction
array([1., 0.])

In contrast, the regular sample mean of the vectors would be influenced
by the magnitude of each observation. Furthermore, the result would not be
a unit vector.

>>> data.mean(axis=0)
array([4.5, -2.])

An exemplary use case for `directional_stats` is to find a *meaningful*
center for a set of observations on a sphere, e.g. geographical locations.

>>> data = np.array([[0.8660254, 0.5, 0.],
...                  [0.8660254, -0.5, 0.]])
>>> dirstats = directional_stats(data)
>>> dirstats.mean_direction
array([1., 0., 0.])

The regular sample mean on the other hand yields a result which does not
lie on the surface of the sphere.

>>> data.mean(axis=0)
array([0.8660254, 0., 0.])

The function also returns the mean resultant length, which
can be used to calculate a directional variance. For example, using the
definition ``Var(z) = 1 - R`` from [2]_ where ``R`` is the
mean resultant length, we can calculate the directional variance of the
vectors in the above example as:

>>> 1 - dirstats.mean_resultant_length
0.13397459716167093
================================================================================

dirichlet:
Firma: (alpha, seed=None)

Docstring:
A Dirichlet random variable.

The ``alpha`` keyword specifies the concentration parameters of the
distribution.

.. versionadded:: 0.15.0

Methods
-------
pdf(x, alpha)
    Probability density function.
logpdf(x, alpha)
    Log of the probability density function.
rvs(alpha, size=1, random_state=None)
    Draw random samples from a Dirichlet distribution.
mean(alpha)
    The mean of the Dirichlet distribution
var(alpha)
    The variance of the Dirichlet distribution
cov(alpha)
    The covariance of the Dirichlet distribution
entropy(alpha)
    Compute the differential entropy of the Dirichlet distribution.

Parameters
----------
alpha : array_like
    The concentration parameters. The number of entries determines the
    dimensionality of the distribution.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
Each :math:`\alpha` entry must be positive. The distribution has only
support on the simplex defined by

.. math::
    \sum_{i=1}^{K} x_i = 1

where :math:`0 < x_i < 1`.

If the quantiles don't lie within the simplex, a ValueError is raised.

The probability density function for `dirichlet` is

.. math::

    f(x) = \frac{1}{\mathrm{B}(\boldsymbol\alpha)} \prod_{i=1}^K x_i^{\alpha_i - 1}

where

.. math::

    \mathrm{B}(\boldsymbol\alpha) = \frac{\prod_{i=1}^K \Gamma(\alpha_i)}
                                 {\Gamma\bigl(\sum_{i=1}^K \alpha_i\bigr)}

and :math:`\boldsymbol\alpha=(\alpha_1,\ldots,\alpha_K)`, the
concentration parameters and :math:`K` is the dimension of the space
where :math:`x` takes values.

Note that the `dirichlet` interface is somewhat inconsistent.
The array returned by the rvs function is transposed
with respect to the format expected by the pdf and logpdf.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import dirichlet

Generate a dirichlet random variable

>>> quantiles = np.array([0.2, 0.2, 0.6])  # specify quantiles
>>> alpha = np.array([0.4, 5, 15])  # specify concentration parameters
>>> dirichlet.pdf(quantiles, alpha)
0.2843831684937255

The same PDF but following a log scale

>>> dirichlet.logpdf(quantiles, alpha)
-1.2574327653159187

Once we specify the dirichlet distribution
we can then calculate quantities of interest

>>> dirichlet.mean(alpha)  # get the mean of the distribution
array([0.01960784, 0.24509804, 0.73529412])
>>> dirichlet.var(alpha) # get variance
array([0.00089829, 0.00864603, 0.00909517])
>>> dirichlet.entropy(alpha)  # calculate the differential entropy
-4.3280162474082715

We can also return random samples from the distribution

>>> dirichlet.rvs(alpha, size=1, random_state=1)
array([[0.00766178, 0.24670518, 0.74563305]])
>>> dirichlet.rvs(alpha, size=2, random_state=2)
array([[0.01639427, 0.1292273 , 0.85437844],
       [0.00156917, 0.19033695, 0.80809388]])

Alternatively, the object may be called (as a function) to fix
concentration parameters, returning a "frozen" Dirichlet
random variable:

>>> rv = dirichlet(alpha)
>>> # Frozen object with the same methods but holding the given
>>> # concentration parameters fixed.
================================================================================

dirichlet_multinomial:
Firma: (alpha, n, seed=None)

Docstring:
A Dirichlet multinomial random variable.

The Dirichlet multinomial distribution is a compound probability
distribution: it is the multinomial distribution with number of trials
`n` and class probabilities ``p`` randomly sampled from a Dirichlet
distribution with concentration parameters ``alpha``.

Methods
-------
logpmf(x, alpha, n):
    Log of the probability mass function.
pmf(x, alpha, n):
    Probability mass function.
mean(alpha, n):
    Mean of the Dirichlet multinomial distribution.
var(alpha, n):
    Variance of the Dirichlet multinomial distribution.
cov(alpha, n):
    The covariance of the Dirichlet multinomial distribution.

Parameters
----------
alpha : array_like
    The concentration parameters. The number of entries along the last axis
    determines the dimensionality of the distribution. Each entry must be
    strictly positive.
n : int or array_like
    The number of trials. Each element must be a strictly positive integer.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

See Also
--------
scipy.stats.dirichlet : The dirichlet distribution.
scipy.stats.multinomial : The multinomial distribution.

References
----------
.. [1] Dirichlet-multinomial distribution, Wikipedia,
       https://www.wikipedia.org/wiki/Dirichlet-multinomial_distribution

Examples
--------
>>> from scipy.stats import dirichlet_multinomial

Get the PMF

>>> n = 6  # number of trials
>>> alpha = [3, 4, 5]  # concentration parameters
>>> x = [1, 2, 3]  # counts
>>> dirichlet_multinomial.pmf(x, alpha, n)
0.08484162895927604

If the sum of category counts does not equal the number of trials,
the probability mass is zero.

>>> dirichlet_multinomial.pmf(x, alpha, n=7)
0.0

Get the log of the PMF

>>> dirichlet_multinomial.logpmf(x, alpha, n)
-2.4669689491013327

Get the mean

>>> dirichlet_multinomial.mean(alpha, n)
array([1.5, 2. , 2.5])

Get the variance

>>> dirichlet_multinomial.var(alpha, n)
array([1.55769231, 1.84615385, 2.01923077])

Get the covariance

>>> dirichlet_multinomial.cov(alpha, n)
array([[ 1.55769231, -0.69230769, -0.86538462],
       [-0.69230769,  1.84615385, -1.15384615],
       [-0.86538462, -1.15384615,  2.01923077]])

Alternatively, the object may be called (as a function) to fix the
`alpha` and `n` parameters, returning a "frozen" Dirichlet multinomial
random variable.

>>> dm = dirichlet_multinomial(alpha, n)
>>> dm.pmf(x)
0.08484162895927579

All methods are fully vectorized. Each element of `x` and `alpha` is
a vector (along the last axis), each element of `n` is an
integer (scalar), and the result is computed element-wise.

>>> x = [[1, 2, 3], [4, 5, 6]]
>>> alpha = [[1, 2, 3], [4, 5, 6]]
>>> n = [6, 15]
>>> dirichlet_multinomial.pmf(x, alpha, n)
array([0.06493506, 0.02626937])

>>> dirichlet_multinomial.cov(alpha, n).shape  # both covariance matrices
(2, 3, 3)

Broadcasting according to standard NumPy conventions is supported. Here,
we have four sets of concentration parameters (each a two element vector)
for each of three numbers of trials (each a scalar).

>>> alpha = [[3, 4], [4, 5], [5, 6], [6, 7]]
>>> n = [[6], [7], [8]]
>>> dirichlet_multinomial.mean(alpha, n).shape
(3, 4, 2)
================================================================================

dlaplace:
Firma: (*args, **kwds)

Docstring:
A  Laplacian discrete random variable.

As an instance of the `rv_discrete` class, `dlaplace` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, a, loc=0)
    Probability mass function.
logpmf(k, a, loc=0)
    Log of the probability mass function.
cdf(k, a, loc=0)
    Cumulative distribution function.
logcdf(k, a, loc=0)
    Log of the cumulative distribution function.
sf(k, a, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, a, loc=0)
    Log of the survival function.
ppf(q, a, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(a, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(a,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0)
    Median of the distribution.
mean(a, loc=0)
    Mean of the distribution.
var(a, loc=0)
    Variance of the distribution.
std(a, loc=0)
    Standard deviation of the distribution.
interval(confidence, a, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `dlaplace` is:

.. math::

    f(k) = \tanh(a/2) \exp(-a |k|)

for integers :math:`k` and :math:`a > 0`.

`dlaplace` takes :math:`a` as shape parameter.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``dlaplace.pmf(k, a, loc)`` is identically
equivalent to ``dlaplace.pmf(k - loc, a)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import dlaplace
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 0.8
>>> mean, var, skew, kurt = dlaplace.stats(a, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(dlaplace.ppf(0.01, a),
...               dlaplace.ppf(0.99, a))
>>> ax.plot(x, dlaplace.pmf(x, a), 'bo', ms=8, label='dlaplace pmf')
>>> ax.vlines(x, 0, dlaplace.pmf(x, a), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = dlaplace(a)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = dlaplace.cdf(x, a)
>>> np.allclose(x, dlaplace.ppf(prob, a))
True

Generate random numbers:

>>> r = dlaplace.rvs(a, size=1000)
================================================================================

dpareto_lognorm:
Firma: (*args, **kwds)

Docstring:
A double Pareto lognormal continuous random variable.

As an instance of the `rv_continuous` class, `dpareto_lognorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(u, s, a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, u, s, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, u, s, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, u, s, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, u, s, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, u, s, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, u, s, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, u, s, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, u, s, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, u, s, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(u, s, a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(u, s, a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(u, s, a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(u, s, a, b, loc=0, scale=1)
    Median of the distribution.
mean(u, s, a, b, loc=0, scale=1)
    Mean of the distribution.
var(u, s, a, b, loc=0, scale=1)
    Variance of the distribution.
std(u, s, a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, u, s, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `dpareto_lognorm` is:

.. math::

    f(x, \mu, \sigma, \alpha, \beta) =
    \frac{\alpha \beta}{(\alpha + \beta) x}
    \phi\left( \frac{\log x - \mu}{\sigma} \right)
    \left( R(y_1) + R(y_2) \right)

where :math:`R(t) = \frac{1 - \Phi(t)}{\phi(t)}`,
:math:`\phi` and :math:`\Phi` are the normal PDF and CDF, respectively,
:math:`y_1 = \alpha \sigma - \frac{\log x - \mu}{\sigma}`,
and :math:`y_2 = \beta \sigma + \frac{\log x - \mu}{\sigma}`
for real numbers :math:`x` and :math:`\mu`, :math:`\sigma > 0`,
:math:`\alpha > 0`, and :math:`\beta > 0` [1]_.

`dpareto_lognorm` takes
``u`` as a shape parameter for :math:`\mu`,
``s`` as a shape parameter for :math:`\sigma`,
``a`` as a shape parameter for :math:`\alpha`, and
``b`` as a shape parameter for :math:`\beta`.

A random variable :math:`X` distributed according to the PDF above
can be represented as :math:`X = U \frac{V_1}{V_2}` where :math:`U`,
:math:`V_1`, and :math:`V_2` are independent, :math:`U` is lognormally
distributed such that :math:`\log U \sim N(\mu, \sigma^2)`, and
:math:`V_1` and :math:`V_2` follow Pareto distributions with parameters
:math:`\alpha` and :math:`\beta`, respectively [2]_.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``dpareto_lognorm.pdf(x, u, s, a, b, loc, scale)`` is identically
equivalent to ``dpareto_lognorm.pdf(y, u, s, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Hajargasht, Gholamreza, and William E. Griffiths. "Pareto-lognormal
       distributions: Inequality, poverty, and estimation from grouped income
       data." Economic Modelling 33 (2013): 593-604.
.. [2] Reed, William J., and Murray Jorgensen. "The double Pareto-lognormal
       distribution - a new parametric model for size distributions."
       Communications in Statistics - Theory and Methods 33.8 (2004): 1733-1753.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import dpareto_lognorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> u, s, a, b = 3, 1.2, 1.5, 2
>>> mean, var, skew, kurt = dpareto_lognorm.stats(u, s, a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(dpareto_lognorm.ppf(0.01, u, s, a, b),
...                 dpareto_lognorm.ppf(0.99, u, s, a, b), 100)
>>> ax.plot(x, dpareto_lognorm.pdf(x, u, s, a, b),
...        'r-', lw=5, alpha=0.6, label='dpareto_lognorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = dpareto_lognorm(u, s, a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = dpareto_lognorm.ppf([0.001, 0.5, 0.999], u, s, a, b)
>>> np.allclose([0.001, 0.5, 0.999], dpareto_lognorm.cdf(vals, u, s, a, b))
True

Generate random numbers:

>>> r = dpareto_lognorm.rvs(u, s, a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

dunnett:
Firma: (*samples: 'npt.ArrayLike', control: 'npt.ArrayLike', alternative: Literal['two-sided', 'less', 'greater'] = 'two-sided', rng: int | numpy.integer | numpy.random._generator.Generator | numpy.random.mtrand.RandomState | None = None) -> scipy.stats._multicomp.DunnettResult

Docstring:
Dunnett's test: multiple comparisons of means against a control group.

This is an implementation of Dunnett's original, single-step test as
described in [1]_.

Parameters
----------
sample1, sample2, ... : 1D array_like
    The sample measurements for each experimental group.
control : 1D array_like
    The sample measurements for the control group.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.

    The null hypothesis is that the means of the distributions underlying
    the samples and control are equal. The following alternative
    hypotheses are available (default is 'two-sided'):

    * 'two-sided': the means of the distributions underlying the samples
      and control are unequal.
    * 'less': the means of the distributions underlying the samples
      are less than the mean of the distribution underlying the control.
    * 'greater': the means of the distributions underlying the
      samples are greater than the mean of the distribution underlying
      the control.
rng : `numpy.random.Generator`, optional
    Pseudorandom number generator state. When `rng` is None, a new
    `numpy.random.Generator` is created using entropy from the
    operating system. Types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.

    .. versionchanged:: 1.15.0

        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this keyword was changed from `random_state` to
        `rng`. For an interim period, both keywords will continue to work, although
        only one may be specified at a time. After the interim period, function
        calls using the `random_state` keyword will emit warnings. Following a
        deprecation period, the `random_state` keyword will be removed.

Returns
-------
res : `~scipy.stats._result_classes.DunnettResult`
    An object containing attributes:

    statistic : float ndarray
        The computed statistic of the test for each comparison. The element
        at index ``i`` is the statistic for the comparison between
        groups ``i`` and the control.
    pvalue : float ndarray
        The computed p-value of the test for each comparison. The element
        at index ``i`` is the p-value for the comparison between
        group ``i`` and the control.

    And the following method:

    confidence_interval(confidence_level=0.95) :
        Compute the difference in means of the groups
        with the control +- the allowance.

See Also
--------
tukey_hsd : performs pairwise comparison of means.
:ref:`hypothesis_dunnett` : Extended example

Notes
-----
Like the independent-sample t-test, Dunnett's test [1]_ is used to make
inferences about the means of distributions from which samples were drawn.
However, when multiple t-tests are performed at a fixed significance level,
the "family-wise error rate" - the probability of incorrectly rejecting the
null hypothesis in at least one test - will exceed the significance level.
Dunnett's test is designed to perform multiple comparisons while
controlling the family-wise error rate.

Dunnett's test compares the means of multiple experimental groups
against a single control group. Tukey's Honestly Significant Difference Test
is another multiple-comparison test that controls the family-wise error
rate, but `tukey_hsd` performs *all* pairwise comparisons between groups.
When pairwise comparisons between experimental groups are not needed,
Dunnett's test is preferable due to its higher power.

The use of this test relies on several assumptions.

1. The observations are independent within and among groups.
2. The observations within each group are normally distributed.
3. The distributions from which the samples are drawn have the same finite
   variance.

References
----------
.. [1] Dunnett, Charles W. (1955) "A Multiple Comparison Procedure for
       Comparing Several Treatments with a Control." Journal of the American
       Statistical Association, 50:272, 1096-1121,
       :doi:`10.1080/01621459.1955.10501294`
.. [2] Thomson, M. L., & Short, M. D. (1969). Mucociliary function in
       health, chronic obstructive airway disease, and asbestosis. Journal
       of applied physiology, 26(5), 535-539.
       :doi:`10.1152/jappl.1969.26.5.535`

Examples
--------
We'll use data from [2]_, Table 1. The null hypothesis is that the means of
the distributions underlying the samples and control are equal.

First, we test that the means of the distributions underlying the samples
and control are unequal (``alternative='two-sided'``, the default).

>>> import numpy as np
>>> from scipy.stats import dunnett
>>> samples = [[3.8, 2.7, 4.0, 2.4], [2.8, 3.4, 3.7, 2.2, 2.0]]
>>> control = [2.9, 3.0, 2.5, 2.6, 3.2]
>>> res = dunnett(*samples, control=control)
>>> res.statistic
array([ 0.90874545, -0.05007117])
>>> res.pvalue
array([0.58325114, 0.99819341])

Now, we test that the means of the distributions underlying the samples are
greater than the mean of the distribution underlying the control.

>>> res = dunnett(*samples, control=control, alternative='greater')
>>> res.statistic
array([ 0.90874545, -0.05007117])
>>> res.pvalue
array([0.30230596, 0.69115597])

For a more detailed example, see :ref:`hypothesis_dunnett`.
================================================================================

dweibull:
Firma: (*args, **kwds)

Docstring:
A double Weibull continuous random variable.

As an instance of the `rv_continuous` class, `dweibull` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `dweibull` is given by

.. math::

    f(x, c) = c / 2 |x|^{c-1} \exp(-|x|^c)

for a real number :math:`x` and :math:`c > 0`.

`dweibull` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``dweibull.pdf(x, c, loc, scale)`` is identically
equivalent to ``dweibull.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import dweibull
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 2.07
>>> mean, var, skew, kurt = dweibull.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(dweibull.ppf(0.01, c),
...                 dweibull.ppf(0.99, c), 100)
>>> ax.plot(x, dweibull.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='dweibull pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = dweibull(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = dweibull.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], dweibull.cdf(vals, c))
True

Generate random numbers:

>>> r = dweibull.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

ecdf:
Firma: (sample: 'npt.ArrayLike | CensoredData') -> scipy.stats._survival.ECDFResult

Docstring:
Empirical cumulative distribution function of a sample.

The empirical cumulative distribution function (ECDF) is a step function
estimate of the CDF of the distribution underlying a sample. This function
returns objects representing both the empirical distribution function and
its complement, the empirical survival function.

Parameters
----------
sample : 1D array_like or `scipy.stats.CensoredData`
    Besides array_like, instances of `scipy.stats.CensoredData` containing
    uncensored and right-censored observations are supported. Currently,
    other instances of `scipy.stats.CensoredData` will result in a
    ``NotImplementedError``.

Returns
-------
res : `~scipy.stats._result_classes.ECDFResult`
    An object with the following attributes.

    cdf : `~scipy.stats._result_classes.EmpiricalDistributionFunction`
        An object representing the empirical cumulative distribution
        function.
    sf : `~scipy.stats._result_classes.EmpiricalDistributionFunction`
        An object representing the empirical survival function.

    The `cdf` and `sf` attributes themselves have the following attributes.

    quantiles : ndarray
        The unique values in the sample that defines the empirical CDF/SF.
    probabilities : ndarray
        The point estimates of the probabilities corresponding with
        `quantiles`.

    And the following methods:

    evaluate(x) :
        Evaluate the CDF/SF at the argument.

    plot(ax) :
        Plot the CDF/SF on the provided axes.

    confidence_interval(confidence_level=0.95) :
        Compute the confidence interval around the CDF/SF at the values in
        `quantiles`.

Notes
-----
When each observation of the sample is a precise measurement, the ECDF
steps up by ``1/len(sample)`` at each of the observations [1]_.

When observations are lower bounds, upper bounds, or both upper and lower
bounds, the data is said to be "censored", and `sample` may be provided as
an instance of `scipy.stats.CensoredData`.

For right-censored data, the ECDF is given by the Kaplan-Meier estimator
[2]_; other forms of censoring are not supported at this time.

Confidence intervals are computed according to the Greenwood formula or the
more recent "Exponential Greenwood" formula as described in [4]_.

References
----------
.. [1] Conover, William Jay. Practical nonparametric statistics. Vol. 350.
       John Wiley & Sons, 1999.

.. [2] Kaplan, Edward L., and Paul Meier. "Nonparametric estimation from
       incomplete observations." Journal of the American statistical
       association 53.282 (1958): 457-481.

.. [3] Goel, Manish Kumar, Pardeep Khanna, and Jugal Kishore.
       "Understanding survival analysis: Kaplan-Meier estimate."
       International journal of Ayurveda research 1.4 (2010): 274.

.. [4] Sawyer, Stanley. "The Greenwood and Exponential Greenwood Confidence
       Intervals in Survival Analysis."
       https://www.math.wustl.edu/~sawyer/handouts/greenwood.pdf

Examples
--------
**Uncensored Data**

As in the example from [1]_ page 79, five boys were selected at random from
those in a single high school. Their one-mile run times were recorded as
follows.

>>> sample = [6.23, 5.58, 7.06, 6.42, 5.20]  # one-mile run times (minutes)

The empirical distribution function, which approximates the distribution
function of one-mile run times of the population from which the boys were
sampled, is calculated as follows.

>>> from scipy import stats
>>> res = stats.ecdf(sample)
>>> res.cdf.quantiles
array([5.2 , 5.58, 6.23, 6.42, 7.06])
>>> res.cdf.probabilities
array([0.2, 0.4, 0.6, 0.8, 1. ])

To plot the result as a step function:

>>> import matplotlib.pyplot as plt
>>> ax = plt.subplot()
>>> res.cdf.plot(ax)
>>> ax.set_xlabel('One-Mile Run Time (minutes)')
>>> ax.set_ylabel('Empirical CDF')
>>> plt.show()

**Right-censored Data**

As in the example from [1]_ page 91, the lives of ten car fanbelts were
tested. Five tests concluded because the fanbelt being tested broke, but
the remaining tests concluded for other reasons (e.g. the study ran out of
funding, but the fanbelt was still functional). The mileage driven
with the fanbelts were recorded as follows.

>>> broken = [77, 47, 81, 56, 80]  # in thousands of miles driven
>>> unbroken = [62, 60, 43, 71, 37]

Precise survival times of the fanbelts that were still functional at the
end of the tests are unknown, but they are known to exceed the values
recorded in ``unbroken``. Therefore, these observations are said to be
"right-censored", and the data is represented using
`scipy.stats.CensoredData`.

>>> sample = stats.CensoredData(uncensored=broken, right=unbroken)

The empirical survival function is calculated as follows.

>>> res = stats.ecdf(sample)
>>> res.sf.quantiles
array([37., 43., 47., 56., 60., 62., 71., 77., 80., 81.])
>>> res.sf.probabilities
array([1.   , 1.   , 0.875, 0.75 , 0.75 , 0.75 , 0.75 , 0.5  , 0.25 , 0.   ])

To plot the result as a step function:

>>> ax = plt.subplot()
>>> res.sf.plot(ax)
>>> ax.set_xlabel('Fanbelt Survival Time (thousands of miles)')
>>> ax.set_ylabel('Empirical SF')
>>> plt.show()
================================================================================

energy_distance:
Firma: (u_values, v_values, u_weights=None, v_weights=None)

Docstring:
Compute the energy distance between two 1D distributions.

.. versionadded:: 1.0.0

Parameters
----------
u_values, v_values : array_like
    Values observed in the (empirical) distribution.
u_weights, v_weights : array_like, optional
    Weight for each value. If unspecified, each value is assigned the same
    weight.
    `u_weights` (resp. `v_weights`) must have the same length as
    `u_values` (resp. `v_values`). If the weight sum differs from 1, it
    must still be positive and finite so that the weights can be normalized
    to sum to 1.

Returns
-------
distance : float
    The computed distance between the distributions.

Notes
-----
The energy distance between two distributions :math:`u` and :math:`v`, whose
respective CDFs are :math:`U` and :math:`V`, equals to:

.. math::

    D(u, v) = \left( 2\mathbb E|X - Y| - \mathbb E|X - X'| -
    \mathbb E|Y - Y'| \right)^{1/2}

where :math:`X` and :math:`X'` (resp. :math:`Y` and :math:`Y'`) are
independent random variables whose probability distribution is :math:`u`
(resp. :math:`v`).

Sometimes the square of this quantity is referred to as the "energy
distance" (e.g. in [2]_, [4]_), but as noted in [1]_ and [3]_, only the
definition above satisfies the axioms of a distance function (metric).

As shown in [2]_, for one-dimensional real-valued variables, the energy
distance is linked to the non-distribution-free version of the Cramér-von
Mises distance:

.. math::

    D(u, v) = \sqrt{2} l_2(u, v) = \left( 2 \int_{-\infty}^{+\infty} (U-V)^2
    \right)^{1/2}

Note that the common Cramér-von Mises criterion uses the distribution-free
version of the distance. See [2]_ (section 2), for more details about both
versions of the distance.

The input distributions can be empirical, therefore coming from samples
whose values are effectively inputs of the function, or they can be seen as
generalized functions, in which case they are weighted sums of Dirac delta
functions located at the specified values.

References
----------
.. [1] Rizzo, Szekely "Energy distance." Wiley Interdisciplinary Reviews:
       Computational Statistics, 8(1):27-38 (2015).
.. [2] Szekely "E-statistics: The energy of statistical samples." Bowling
       Green State University, Department of Mathematics and Statistics,
       Technical Report 02-16 (2002).
.. [3] "Energy distance", https://en.wikipedia.org/wiki/Energy_distance
.. [4] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,
       Munos "The Cramer Distance as a Solution to Biased Wasserstein
       Gradients" (2017). :arXiv:`1705.10743`.

Examples
--------
>>> from scipy.stats import energy_distance
>>> energy_distance([0], [2])
2.0000000000000004
>>> energy_distance([0, 8], [0, 8], [3, 1], [2, 2])
1.0000000000000002
>>> energy_distance([0.7, 7.4, 2.4, 6.8], [1.4, 8. ],
...                 [2.1, 4.2, 7.4, 8. ], [7.6, 8.8])
0.88003340976158217
================================================================================

entropy:
Firma: (pk: Union[collections.abc.Buffer, numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[bool | int | float | complex | str | bytes]], qk: Union[collections.abc.Buffer, numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[bool | int | float | complex | str | bytes], NoneType] = None, base: float | None = None, axis: int = 0, *, nan_policy='propagate', keepdims=False) -> numpy.number | numpy.ndarray

Docstring:
Calculate the Shannon entropy/relative entropy of given distribution(s).

If only probabilities `pk` are given, the Shannon entropy is calculated as
``H = -sum(pk * log(pk))``.

If `qk` is not None, then compute the relative entropy
``D = sum(pk * log(pk / qk))``. This quantity is also known
as the Kullback-Leibler divergence.

This routine will normalize `pk` and `qk` if they don't sum to 1.

Parameters
----------
pk : array_like
    Defines the (discrete) distribution. Along each axis-slice of ``pk``,
    element ``i`` is the  (possibly unnormalized) probability of event
    ``i``.
qk : array_like, optional
    Sequence against which the relative entropy is computed. Should be in
    the same format as `pk`.
base : float, optional
    The logarithmic base to use, defaults to ``e`` (natural logarithm).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
S : {float, array_like}
    The calculated entropy.

Notes
-----
Informally, the Shannon entropy quantifies the expected uncertainty
inherent in the possible outcomes of a discrete random variable.
For example,
if messages consisting of sequences of symbols from a set are to be
encoded and transmitted over a noiseless channel, then the Shannon entropy
``H(pk)`` gives a tight lower bound for the average number of units of
information needed per symbol if the symbols occur with frequencies
governed by the discrete distribution `pk` [1]_. The choice of base
determines the choice of units; e.g., ``e`` for nats, ``2`` for bits, etc.

The relative entropy, ``D(pk|qk)``, quantifies the increase in the average
number of units of information needed per symbol if the encoding is
optimized for the probability distribution `qk` instead of the true
distribution `pk`. Informally, the relative entropy quantifies the expected
excess in surprise experienced if one believes the true distribution is
`qk` when it is actually `pk`.

A related quantity, the cross entropy ``CE(pk, qk)``, satisfies the
equation ``CE(pk, qk) = H(pk) + D(pk|qk)`` and can also be calculated with
the formula ``CE = -sum(pk * log(qk))``. It gives the average
number of units of information needed per symbol if an encoding is
optimized for the probability distribution `qk` when the true distribution
is `pk`. It is not computed directly by `entropy`, but it can be computed
using two calls to the function (see Examples).

See [2]_ for more information.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Shannon, C.E. (1948), A Mathematical Theory of Communication.
       Bell System Technical Journal, 27: 379-423.
       https://doi.org/10.1002/j.1538-7305.1948.tb01338.x
.. [2] Thomas M. Cover and Joy A. Thomas. 2006. Elements of Information
       Theory (Wiley Series in Telecommunications and Signal Processing).
       Wiley-Interscience, USA.

Examples
--------
The outcome of a fair coin is the most uncertain:

>>> import numpy as np
>>> from scipy.stats import entropy
>>> base = 2  # work in units of bits
>>> pk = np.array([1/2, 1/2])  # fair coin
>>> H = entropy(pk, base=base)
>>> H
1.0
>>> H == -np.sum(pk * np.log(pk)) / np.log(base)
True

The outcome of a biased coin is less uncertain:

>>> qk = np.array([9/10, 1/10])  # biased coin
>>> entropy(qk, base=base)
0.46899559358928117

The relative entropy between the fair coin and biased coin is calculated
as:

>>> D = entropy(pk, qk, base=base)
>>> D
0.7369655941662062
>>> np.isclose(D, np.sum(pk * np.log(pk/qk)) / np.log(base), rtol=4e-16, atol=0)
True

The cross entropy can be calculated as the sum of the entropy and
relative entropy`:

>>> CE = entropy(pk, base=base) + entropy(pk, qk, base=base)
>>> CE
1.736965594166206
>>> CE == -np.sum(pk * np.log(qk)) / np.log(base)
True
================================================================================

epps_singleton_2samp:
Firma: (x, y, t=(0.4, 0.8), *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Compute the Epps-Singleton (ES) test statistic.

Test the null hypothesis that two samples have the same underlying
probability distribution.

Parameters
----------
x, y : array-like
    The two samples of observations to be tested. Input must not have more
    than one dimension. Samples can have different lengths, but both
    must have at least five observations.
t : array-like, optional
    The points (t1, ..., tn) where the empirical characteristic function is
    to be evaluated. It should be positive distinct numbers. The default
    value (0.4, 0.8) is proposed in [1]_. Input must not have more than
    one dimension.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The associated p-value based on the asymptotic chi2-distribution.

See Also
--------

:func:`ks_2samp`, :func:`anderson_ksamp`
    ..

Notes
-----
Testing whether two samples are generated by the same underlying
distribution is a classical question in statistics. A widely used test is
the Kolmogorov-Smirnov (KS) test which relies on the empirical
distribution function. Epps and Singleton introduce a test based on the
empirical characteristic function in [1]_.

One advantage of the ES test compared to the KS test is that is does
not assume a continuous distribution. In [1]_, the authors conclude
that the test also has a higher power than the KS test in many
examples. They recommend the use of the ES test for discrete samples as
well as continuous samples with at least 25 observations each, whereas
`anderson_ksamp` is recommended for smaller sample sizes in the
continuous case.

The p-value is computed from the asymptotic distribution of the test
statistic which follows a `chi2` distribution. If the sample size of both
`x` and `y` is below 25, the small sample correction proposed in [1]_ is
applied to the test statistic.

The default values of `t` are determined in [1]_ by considering
various distributions and finding good values that lead to a high power
of the test in general. Table III in [1]_ gives the optimal values for
the distributions tested in that study. The values of `t` are scaled by
the semi-interquartile range in the implementation, see [1]_.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] T. W. Epps and K. J. Singleton, "An omnibus test for the two-sample
   problem using the empirical characteristic function", Journal of
   Statistical Computation and Simulation 26, p. 177--203, 1986.

.. [2] S. J. Goerg and J. Kaiser, "Nonparametric testing of distributions
   - the Epps-Singleton two-sample test using the empirical characteristic
   function", The Stata Journal 9(3), p. 454--465, 2009.
================================================================================

erlang:
Firma: (*args, **kwds)

Docstring:
An Erlang continuous random variable.

As an instance of the `rv_continuous` class, `erlang` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gamma

Notes
-----
The Erlang distribution is a special case of the Gamma distribution, with
the shape parameter `a` an integer.  Note that this restriction is not
enforced by `erlang`. It will, however, generate a warning the first time
a non-integer value is used for the shape parameter.

Refer to `gamma` for examples.
================================================================================

exp:
Firma: (X, /)

Docstring:
Natural exponential of a random variable

Parameters
----------
X : `ContinuousDistribution`
    The random variable :math:`X`.

Returns
-------
Y : `ContinuousDistribution`
    A random variable :math:`Y = \exp(X)`.

Examples
--------
Suppose we have a normally distributed random variable :math:`X`:

>>> import numpy as np
>>> from scipy import stats
>>> X = stats.Normal()

We wish to have a lognormally distributed random variable :math:`Y`,
a random variable whose natural logarithm is :math:`X`.
If :math:`X` is to be the natural logarithm of :math:`Y`, then we
must take :math:`Y` to be the natural exponential of :math:`X`.

>>> Y = stats.exp(X)

To demonstrate that ``X`` represents the logarithm of ``Y``,
we plot a normalized histogram of the logarithm of observations of
``Y`` against the PDF underlying ``X``.

>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng(435383595582522)
>>> y = Y.sample(shape=10000, rng=rng)
>>> ax = plt.gca()
>>> ax.hist(np.log(y), bins=50, density=True)
>>> X.plot(ax=ax)
>>> plt.legend(('PDF of `X`', 'histogram of `log(y)`'))
>>> plt.show()
================================================================================

expectile:
Firma: (a, alpha=0.5, *, weights=None)

Docstring:
Compute the expectile at the specified level.

Expectiles are a generalization of the expectation in the same way as
quantiles are a generalization of the median. The expectile at level
`alpha = 0.5` is the mean (average). See Notes for more details.

Parameters
----------
a : array_like
    Array containing numbers whose expectile is desired.
alpha : float, default: 0.5
    The level of the expectile; e.g., ``alpha=0.5`` gives the mean.
weights : array_like, optional
    An array of weights associated with the values in `a`.
    The `weights` must be broadcastable to the same shape as `a`.
    Default is None, which gives each value a weight of 1.0.
    An integer valued weight element acts like repeating the corresponding
    observation in `a` that many times. See Notes for more details.

Returns
-------
expectile : ndarray
    The empirical expectile at level `alpha`.

See Also
--------
numpy.mean : Arithmetic average
numpy.quantile : Quantile

Notes
-----
In general, the expectile at level :math:`\alpha` of a random variable
:math:`X` with cumulative distribution function (CDF) :math:`F` is given
by the unique solution :math:`t` of:

.. math::

    \alpha E((X - t)_+) = (1 - \alpha) E((t - X)_+) \,.

Here, :math:`(x)_+ = \max(0, x)` is the positive part of :math:`x`.
This equation can be equivalently written as:

.. math::

    \alpha \int_t^\infty (x - t)\mathrm{d}F(x)
    = (1 - \alpha) \int_{-\infty}^t (t - x)\mathrm{d}F(x) \,.

The empirical expectile at level :math:`\alpha` (`alpha`) of a sample
:math:`a_i` (the array `a`) is defined by plugging in the empirical CDF of
`a`. Given sample or case weights :math:`w` (the array `weights`), it
reads :math:`F_a(x) = \frac{1}{\sum_i w_i} \sum_i w_i 1_{a_i \leq x}`
with indicator function :math:`1_{A}`. This leads to the definition of the
empirical expectile at level `alpha` as the unique solution :math:`t` of:

.. math::

    \alpha \sum_{i=1}^n w_i (a_i - t)_+ =
        (1 - \alpha) \sum_{i=1}^n w_i (t - a_i)_+ \,.

For :math:`\alpha=0.5`, this simplifies to the weighted average.
Furthermore, the larger :math:`\alpha`, the larger the value of the
expectile.

As a final remark, the expectile at level :math:`\alpha` can also be
written as a minimization problem. One often used choice is

.. math::

    \operatorname{argmin}_t
    E(\lvert 1_{t\geq X} - \alpha\rvert(t - X)^2) \,.

References
----------
.. [1] W. K. Newey and J. L. Powell (1987), "Asymmetric Least Squares
       Estimation and Testing," Econometrica, 55, 819-847.
.. [2] T. Gneiting (2009). "Making and Evaluating Point Forecasts,"
       Journal of the American Statistical Association, 106, 746 - 762.
       :doi:`10.48550/arXiv.0912.0902`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import expectile
>>> a = [1, 4, 2, -1]
>>> expectile(a, alpha=0.5) == np.mean(a)
True
>>> expectile(a, alpha=0.2)
0.42857142857142855
>>> expectile(a, alpha=0.8)
2.5714285714285716
>>> weights = [1, 3, 1, 1]
================================================================================

expon:
Firma: (*args, **kwds)

Docstring:
An exponential continuous random variable.

As an instance of the `rv_continuous` class, `expon` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `expon` is:

.. math::

    f(x) = \exp(-x)

for :math:`x \ge 0`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``expon.pdf(x, loc, scale)`` is identically
equivalent to ``expon.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

A common parameterization for `expon` is in terms of the rate parameter
``lambda``, such that ``pdf = lambda * exp(-lambda * x)``. This
parameterization corresponds to using ``scale = 1 / lambda``.

The exponential distribution is a special case of the gamma
distributions, with gamma shape parameter ``a = 1``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import expon
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = expon.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(expon.ppf(0.01),
...                 expon.ppf(0.99), 100)
>>> ax.plot(x, expon.pdf(x),
...        'r-', lw=5, alpha=0.6, label='expon pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = expon()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = expon.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], expon.cdf(vals))
True

Generate random numbers:

>>> r = expon.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

exponnorm:
Firma: (*args, **kwds)

Docstring:
An exponentially modified Normal continuous random variable.

Also known as the exponentially modified Gaussian distribution [1]_.

As an instance of the `rv_continuous` class, `exponnorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(K, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, K, loc=0, scale=1)
    Probability density function.
logpdf(x, K, loc=0, scale=1)
    Log of the probability density function.
cdf(x, K, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, K, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, K, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, K, loc=0, scale=1)
    Log of the survival function.
ppf(q, K, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, K, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, K, loc=0, scale=1)
    Non-central moment of the specified order.
stats(K, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(K, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(K,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(K, loc=0, scale=1)
    Median of the distribution.
mean(K, loc=0, scale=1)
    Mean of the distribution.
var(K, loc=0, scale=1)
    Variance of the distribution.
std(K, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, K, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `exponnorm` is:

.. math::

    f(x, K) = \frac{1}{2K} \exp\left(\frac{1}{2 K^2} - x / K \right)
              \text{erfc}\left(-\frac{x - 1/K}{\sqrt{2}}\right)

where :math:`x` is a real number and :math:`K > 0`.

It can be thought of as the sum of a standard normal random variable
and an independent exponentially distributed random variable with rate
``1/K``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``exponnorm.pdf(x, K, loc, scale)`` is identically
equivalent to ``exponnorm.pdf(y, K) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

An alternative parameterization of this distribution (for example, in
the Wikipedia article [1]_) involves three parameters, :math:`\mu`,
:math:`\lambda` and :math:`\sigma`.

In the present parameterization this corresponds to having ``loc`` and
``scale`` equal to :math:`\mu` and :math:`\sigma`, respectively, and
shape parameter :math:`K = 1/(\sigma\lambda)`.

.. versionadded:: 0.16.0

References
----------
.. [1] Exponentially modified Gaussian distribution, Wikipedia,
       https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import exponnorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> K = 1.5
>>> mean, var, skew, kurt = exponnorm.stats(K, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(exponnorm.ppf(0.01, K),
...                 exponnorm.ppf(0.99, K), 100)
>>> ax.plot(x, exponnorm.pdf(x, K),
...        'r-', lw=5, alpha=0.6, label='exponnorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = exponnorm(K)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = exponnorm.ppf([0.001, 0.5, 0.999], K)
>>> np.allclose([0.001, 0.5, 0.999], exponnorm.cdf(vals, K))
True

Generate random numbers:

>>> r = exponnorm.rvs(K, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

exponpow:
Firma: (*args, **kwds)

Docstring:
An exponential power continuous random variable.

As an instance of the `rv_continuous` class, `exponpow` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, b, loc=0, scale=1)
    Probability density function.
logpdf(x, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(b,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(b, loc=0, scale=1)
    Median of the distribution.
mean(b, loc=0, scale=1)
    Mean of the distribution.
var(b, loc=0, scale=1)
    Variance of the distribution.
std(b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `exponpow` is:

.. math::

    f(x, b) = b x^{b-1} \exp(1 + x^b - \exp(x^b))

for :math:`x \ge 0`, :math:`b > 0`.  Note that this is a different
distribution from the exponential power distribution that is also known
under the names "generalized normal" or "generalized Gaussian".

`exponpow` takes ``b`` as a shape parameter for :math:`b`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``exponpow.pdf(x, b, loc, scale)`` is identically
equivalent to ``exponpow.pdf(y, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Exponentialpower.pdf

Examples
--------
>>> import numpy as np
>>> from scipy.stats import exponpow
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> b = 2.7
>>> mean, var, skew, kurt = exponpow.stats(b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(exponpow.ppf(0.01, b),
...                 exponpow.ppf(0.99, b), 100)
>>> ax.plot(x, exponpow.pdf(x, b),
...        'r-', lw=5, alpha=0.6, label='exponpow pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = exponpow(b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = exponpow.ppf([0.001, 0.5, 0.999], b)
>>> np.allclose([0.001, 0.5, 0.999], exponpow.cdf(vals, b))
True

Generate random numbers:

>>> r = exponpow.rvs(b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

exponweib:
Firma: (*args, **kwds)

Docstring:
An exponentiated Weibull continuous random variable.

As an instance of the `rv_continuous` class, `exponweib` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, c, loc=0, scale=1)
    Probability density function.
logpdf(x, a, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, c), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, c, loc=0, scale=1)
    Median of the distribution.
mean(a, c, loc=0, scale=1)
    Mean of the distribution.
var(a, c, loc=0, scale=1)
    Variance of the distribution.
std(a, c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
weibull_min, numpy.random.Generator.weibull

Notes
-----
The probability density function for `exponweib` is:

.. math::

    f(x, a, c) = a c [1-\exp(-x^c)]^{a-1} \exp(-x^c) x^{c-1}

and its cumulative distribution function is:

.. math::

    F(x, a, c) = [1-\exp(-x^c)]^a

for :math:`x > 0`, :math:`a > 0`, :math:`c > 0`.

`exponweib` takes :math:`a` and :math:`c` as shape parameters:

* :math:`a` is the exponentiation parameter,
  with the special case :math:`a=1` corresponding to the
  (non-exponentiated) Weibull distribution `weibull_min`.
* :math:`c` is the shape parameter of the non-exponentiated Weibull law.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``exponweib.pdf(x, a, c, loc, scale)`` is identically
equivalent to ``exponweib.pdf(y, a, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
https://en.wikipedia.org/wiki/Exponentiated_Weibull_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import exponweib
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, c = 2.89, 1.95
>>> mean, var, skew, kurt = exponweib.stats(a, c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(exponweib.ppf(0.01, a, c),
...                 exponweib.ppf(0.99, a, c), 100)
>>> ax.plot(x, exponweib.pdf(x, a, c),
...        'r-', lw=5, alpha=0.6, label='exponweib pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = exponweib(a, c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = exponweib.ppf([0.001, 0.5, 0.999], a, c)
>>> np.allclose([0.001, 0.5, 0.999], exponweib.cdf(vals, a, c))
True

Generate random numbers:

>>> r = exponweib.rvs(a, c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

f:
Firma: (*args, **kwds)

Docstring:
An F continuous random variable.

For the noncentral F distribution, see `ncf`.

As an instance of the `rv_continuous` class, `f` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(dfn, dfd, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, dfn, dfd, loc=0, scale=1)
    Probability density function.
logpdf(x, dfn, dfd, loc=0, scale=1)
    Log of the probability density function.
cdf(x, dfn, dfd, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, dfn, dfd, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, dfn, dfd, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, dfn, dfd, loc=0, scale=1)
    Log of the survival function.
ppf(q, dfn, dfd, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, dfn, dfd, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, dfn, dfd, loc=0, scale=1)
    Non-central moment of the specified order.
stats(dfn, dfd, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(dfn, dfd, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(dfn, dfd), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(dfn, dfd, loc=0, scale=1)
    Median of the distribution.
mean(dfn, dfd, loc=0, scale=1)
    Mean of the distribution.
var(dfn, dfd, loc=0, scale=1)
    Variance of the distribution.
std(dfn, dfd, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, dfn, dfd, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
ncf

Notes
-----
The F distribution with :math:`df_1 > 0` and :math:`df_2 > 0` degrees of freedom is
the distribution of the ratio of two independent chi-squared distributions with
:math:`df_1` and :math:`df_2` degrees of freedom, after rescaling by
:math:`df_2 / df_1`.

The probability density function for `f` is:

.. math::

    f(x, df_1, df_2) = \frac{df_2^{df_2/2} df_1^{df_1/2} x^{df_1 / 2-1}}
                            {(df_2+df_1 x)^{(df_1+df_2)/2}
                             B(df_1/2, df_2/2)}

for :math:`x > 0`.

`f` accepts shape parameters ``dfn`` and ``dfd`` for :math:`df_1`, the degrees of
freedom of the chi-squared distribution in the numerator, and :math:`df_2`, the
degrees of freedom of the chi-squared distribution in the denominator, respectively.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``f.pdf(x, dfn, dfd, loc, scale)`` is identically
equivalent to ``f.pdf(y, dfn, dfd) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import f
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> dfn, dfd = 29, 18
>>> mean, var, skew, kurt = f.stats(dfn, dfd, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(f.ppf(0.01, dfn, dfd),
...                 f.ppf(0.99, dfn, dfd), 100)
>>> ax.plot(x, f.pdf(x, dfn, dfd),
...        'r-', lw=5, alpha=0.6, label='f pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = f(dfn, dfd)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = f.ppf([0.001, 0.5, 0.999], dfn, dfd)
>>> np.allclose([0.001, 0.5, 0.999], f.cdf(vals, dfn, dfd))
True

Generate random numbers:

>>> r = f.rvs(dfn, dfd, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

f_oneway:
Firma: (*samples, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform one-way ANOVA.

The one-way ANOVA tests the null hypothesis that two or more groups have
the same population mean.  The test is applied to samples from two or
more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.  There must be at least
    two arguments.  If the arrays are multidimensional, then all the
    dimensions of the array must be the same except for `axis`.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The computed F statistic of the test.
pvalue : float
    The associated p-value from the F distribution.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Emitted if all values within each of the input arrays are identical.
    In this case the F statistic is either infinite or isn't defined,
    so ``np.inf`` or ``np.nan`` is returned.
RuntimeWarning
    Emitted if the length of any input array is 0, or if all the input
    arrays have length 1.  ``np.nan`` is returned for the F statistic
    and the p-value in these cases.

Notes
-----
The ANOVA test has important assumptions that must be satisfied in order
for the associated p-value to be valid.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. The population standard deviations of the groups are all equal.  This
   property is known as homoscedasticity.

If these assumptions are not true for a given set of data, it may still
be possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) or
the Alexander-Govern test (`scipy.stats.alexandergovern`) although with
some loss of power.

The length of each group must be at least one, and there must be at
least one group with length greater than one.  If these conditions
are not satisfied, a warning is generated and (``np.nan``, ``np.nan``)
is returned.

If all values in each group are identical, and there exist at least two
groups with different values, the function generates a warning and
returns (``np.inf``, 0).

If all values in all groups are the same, function generates a warning
and returns (``np.nan``, ``np.nan``).

The algorithm is from Heiman [2]_, pp.394-7.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] R. Lowry, "Concepts and Applications of Inferential Statistics",
       Chapter 14, 2014, http://vassarstats.net/textbook/

.. [2] G.W. Heiman, "Understanding research methods and statistics: An
       integrated introduction for psychology", Houghton, Mifflin and
       Company, 2001.

.. [3] G.H. McDonald, "Handbook of Biological Statistics", One-way ANOVA.
       http://www.biostathandbook.com/onewayanova.html

Examples
--------
>>> import numpy as np
>>> from scipy.stats import f_oneway

Here are some data [3]_ on a shell measurement (the length of the anterior
adductor muscle scar, standardized by dividing by length) in the mussel
Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon;
Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a
much larger data set used in McDonald et al. (1991).

>>> tillamook = [0.0571, 0.0813, 0.0831, 0.0976, 0.0817, 0.0859, 0.0735,
...              0.0659, 0.0923, 0.0836]
>>> newport = [0.0873, 0.0662, 0.0672, 0.0819, 0.0749, 0.0649, 0.0835,
...            0.0725]
>>> petersburg = [0.0974, 0.1352, 0.0817, 0.1016, 0.0968, 0.1064, 0.105]
>>> magadan = [0.1033, 0.0915, 0.0781, 0.0685, 0.0677, 0.0697, 0.0764,
...            0.0689]
>>> tvarminne = [0.0703, 0.1026, 0.0956, 0.0973, 0.1039, 0.1045]
>>> f_oneway(tillamook, newport, petersburg, magadan, tvarminne)
F_onewayResult(statistic=7.121019471642447, pvalue=0.0002812242314534544)

`f_oneway` accepts multidimensional input arrays.  When the inputs
are multidimensional and `axis` is not given, the test is performed
along the first axis of the input arrays.  For the following data, the
test is performed three times, once for each column.

>>> a = np.array([[9.87, 9.03, 6.81],
...               [7.18, 8.35, 7.00],
...               [8.39, 7.58, 7.68],
...               [7.45, 6.33, 9.35],
...               [6.41, 7.10, 9.33],
...               [8.00, 8.24, 8.44]])
>>> b = np.array([[6.35, 7.30, 7.16],
...               [6.65, 6.68, 7.63],
...               [5.72, 7.73, 6.72],
...               [7.01, 9.19, 7.41],
...               [7.75, 7.87, 8.30],
...               [6.90, 7.97, 6.97]])
>>> c = np.array([[3.31, 8.77, 1.01],
...               [8.25, 3.24, 3.62],
...               [6.32, 8.81, 5.19],
...               [7.48, 8.83, 8.91],
...               [8.59, 6.01, 6.07],
...               [3.07, 9.72, 7.48]])
>>> F = f_oneway(a, b, c)
>>> F.statistic
array([1.75676344, 0.03701228, 3.76439349])
>>> F.pvalue
array([0.20630784, 0.96375203, 0.04733157])
================================================================================

false_discovery_control:
Firma: (ps, *, axis=0, method='bh')

Docstring:
Adjust p-values to control the false discovery rate.

The false discovery rate (FDR) is the expected proportion of rejected null
hypotheses that are actually true.
If the null hypothesis is rejected when the *adjusted* p-value falls below
a specified level, the false discovery rate is controlled at that level.

Parameters
----------
ps : 1D array_like
    The p-values to adjust. Elements must be real numbers between 0 and 1.
axis : int
    The axis along which to perform the adjustment. The adjustment is
    performed independently along each axis-slice. If `axis` is None, `ps`
    is raveled before performing the adjustment.
method : {'bh', 'by'}
    The false discovery rate control procedure to apply: ``'bh'`` is for
    Benjamini-Hochberg [1]_ (Eq. 1), ``'by'`` is for Benjaminini-Yekutieli
    [2]_ (Theorem 1.3). The latter is more conservative, but it is
    guaranteed to control the FDR even when the p-values are not from
    independent tests.

Returns
-------
ps_adusted : array_like
    The adjusted p-values. If the null hypothesis is rejected where these
    fall below a specified level, the false discovery rate is controlled
    at that level.

See Also
--------
combine_pvalues
statsmodels.stats.multitest.multipletests

Notes
-----
In multiple hypothesis testing, false discovery control procedures tend to
offer higher power than familywise error rate control procedures (e.g.
Bonferroni correction [1]_).

If the p-values correspond with independent tests (or tests with
"positive regression dependencies" [2]_), rejecting null hypotheses
corresponding with Benjamini-Hochberg-adjusted p-values below :math:`q`
controls the false discovery rate at a level less than or equal to
:math:`q m_0 / m`, where :math:`m_0` is the number of true null hypotheses
and :math:`m` is the total number of null hypotheses tested. The same is
true even for dependent tests when the p-values are adjusted accorded to
the more conservative Benjaminini-Yekutieli procedure.

The adjusted p-values produced by this function are comparable to those
produced by the R function ``p.adjust`` and the statsmodels function
`statsmodels.stats.multitest.multipletests`. Please consider the latter
for more advanced methods of multiple comparison correction.

References
----------
.. [1] Benjamini, Yoav, and Yosef Hochberg. "Controlling the false
       discovery rate: a practical and powerful approach to multiple
       testing." Journal of the Royal statistical society: series B
       (Methodological) 57.1 (1995): 289-300.

.. [2] Benjamini, Yoav, and Daniel Yekutieli. "The control of the false
       discovery rate in multiple testing under dependency." Annals of
       statistics (2001): 1165-1188.

.. [3] TileStats. FDR - Benjamini-Hochberg explained - Youtube.
       https://www.youtube.com/watch?v=rZKa4tW2NKs.

.. [4] Neuhaus, Karl-Ludwig, et al. "Improved thrombolysis in acute
       myocardial infarction with front-loaded administration of alteplase:
       results of the rt-PA-APSAC patency study (TAPS)." Journal of the
       American College of Cardiology 19.5 (1992): 885-891.

Examples
--------
We follow the example from [1]_.

    Thrombolysis with recombinant tissue-type plasminogen activator (rt-PA)
    and anisoylated plasminogen streptokinase activator (APSAC) in
    myocardial infarction has been proved to reduce mortality. [4]_
    investigated the effects of a new front-loaded administration of rt-PA
    versus those obtained with a standard regimen of APSAC, in a randomized
    multicentre trial in 421 patients with acute myocardial infarction.

There were four families of hypotheses tested in the study, the last of
which was "cardiac and other events after the start of thrombolitic
treatment". FDR control may be desired in this family of hypotheses
because it would not be appropriate to conclude that the front-loaded
treatment is better if it is merely equivalent to the previous treatment.

The p-values corresponding with the 15 hypotheses in this family were

>>> ps = [0.0001, 0.0004, 0.0019, 0.0095, 0.0201, 0.0278, 0.0298, 0.0344,
...       0.0459, 0.3240, 0.4262, 0.5719, 0.6528, 0.7590, 1.000]

If the chosen significance level is 0.05, we may be tempted to reject the
null hypotheses for the tests corresponding with the first nine p-values,
as the first nine p-values fall below the chosen significance level.
However, this would ignore the problem of "multiplicity": if we fail to
correct for the fact that multiple comparisons are being performed, we
are more likely to incorrectly reject true null hypotheses.

One approach to the multiplicity problem is to control the family-wise
error rate (FWER), that is, the rate at which the null hypothesis is
rejected when it is actually true. A common procedure of this kind is the
Bonferroni correction [1]_.  We begin by multiplying the p-values by the
number of hypotheses tested.

>>> import numpy as np
>>> np.array(ps) * len(ps)
array([1.5000e-03, 6.0000e-03, 2.8500e-02, 1.4250e-01, 3.0150e-01,
       4.1700e-01, 4.4700e-01, 5.1600e-01, 6.8850e-01, 4.8600e+00,
       6.3930e+00, 8.5785e+00, 9.7920e+00, 1.1385e+01, 1.5000e+01])

To control the FWER at 5%, we reject only the hypotheses corresponding
with adjusted p-values less than 0.05. In this case, only the hypotheses
corresponding with the first three p-values can be rejected. According to
[1]_, these three hypotheses concerned "allergic reaction" and "two
different aspects of bleeding."

An alternative approach is to control the false discovery rate: the
expected fraction of rejected null hypotheses that are actually true. The
advantage of this approach is that it typically affords greater power: an
increased rate of rejecting the null hypothesis when it is indeed false. To
control the false discovery rate at 5%, we apply the Benjamini-Hochberg
p-value adjustment.

>>> from scipy import stats
>>> stats.false_discovery_control(ps)
array([0.0015    , 0.003     , 0.0095    , 0.035625  , 0.0603    ,
       0.06385714, 0.06385714, 0.0645    , 0.0765    , 0.486     ,
       0.58118182, 0.714875  , 0.75323077, 0.81321429, 1.        ])

Now, the first *four* adjusted p-values fall below 0.05, so we would reject
the null hypotheses corresponding with these *four* p-values. Rejection
of the fourth null hypothesis was particularly important to the original
study as it led to the conclusion that the new treatment had a
"substantially lower in-hospital mortality rate."
================================================================================

fatiguelife:
Firma: (*args, **kwds)

Docstring:
A fatigue-life (Birnbaum-Saunders) continuous random variable.

As an instance of the `rv_continuous` class, `fatiguelife` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `fatiguelife` is:

.. math::

    f(x, c) = \frac{x+1}{2c\sqrt{2\pi x^3}} \exp(-\frac{(x-1)^2}{2x c^2})

for :math:`x >= 0` and :math:`c > 0`.

`fatiguelife` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``fatiguelife.pdf(x, c, loc, scale)`` is identically
equivalent to ``fatiguelife.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] "Birnbaum-Saunders distribution",
       https://en.wikipedia.org/wiki/Birnbaum-Saunders_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import fatiguelife
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 29
>>> mean, var, skew, kurt = fatiguelife.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(fatiguelife.ppf(0.01, c),
...                 fatiguelife.ppf(0.99, c), 100)
>>> ax.plot(x, fatiguelife.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='fatiguelife pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = fatiguelife(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = fatiguelife.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], fatiguelife.cdf(vals, c))
True

Generate random numbers:

>>> r = fatiguelife.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

find_repeats:
Firma: (arr)

Docstring:
Find repeats and repeat counts.

.. deprecated:: 1.15.0

    This function is deprecated as of SciPy 1.15.0 and will be removed
    in SciPy 1.17.0. Please use `numpy.unique` / `numpy.unique_counts` instead.

Parameters
----------
arr : array_like
    Input array. This is cast to float64.

Returns
-------
values : ndarray
    The unique values from the (flattened) input that are repeated.

counts : ndarray
    Number of times the corresponding 'value' is repeated.

Notes
-----
In numpy >= 1.9 `numpy.unique` provides similar functionality. The main
difference is that `find_repeats` only returns repeated values.

Examples
--------
>>> from scipy import stats
>>> stats.find_repeats([2, 1, 2, 3, 2, 2, 5])
RepeatedResults(values=array([2.]), counts=array([4]))

>>> stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])
RepeatedResults(values=array([4.,  5.]), counts=array([2, 2]))
================================================================================

fisher_exact:
Firma: (table, alternative=None, *, method=None)

Docstring:
Perform a Fisher exact test on a contingency table.

For a 2x2 table,
the null hypothesis is that the true odds ratio of the populations
underlying the observations is one, and the observations were sampled
from these populations under a condition: the marginals of the
resulting table must equal those of the observed table.
The statistic is the unconditional maximum likelihood estimate of the odds
ratio, and the p-value is the probability under the null hypothesis of
obtaining a table at least as extreme as the one that was actually
observed.

For other table sizes, or if `method` is provided, the null hypothesis
is that the rows and columns of the tables have fixed sums and are
independent; i.e., the table was sampled from a `scipy.stats.random_table`
distribution with the observed marginals. The statistic is the
probability mass of this distribution evaluated at `table`, and the
p-value is the percentage of the population of tables with statistic at
least as extreme (small) as that of `table`. There is only one alternative
hypothesis available: the rows and columns are not independent.

There are other possible choices of statistic and two-sided
p-value definition associated with Fisher's exact test; please see the
Notes for more information.

Parameters
----------
table : array_like of ints
    A contingency table.  Elements must be non-negative integers.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis for 2x2 tables; unused for other
    table sizes.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the odds ratio of the underlying population is not one
    * 'less': the odds ratio of the underlying population is less than one
    * 'greater': the odds ratio of the underlying population is greater
      than one

    See the Notes for more details.

method : ResamplingMethod, optional
    Defines the method used to compute the p-value.
    If `method` is an instance of `PermutationMethod`/`MonteCarloMethod`,
    the p-value is computed using
    `scipy.stats.permutation_test`/`scipy.stats.monte_carlo_test` with the
    provided configuration options and other appropriate settings.
    Note that if `method` is an instance of `MonteCarloMethod`, the ``rvs``
    attribute must be left unspecified; Monte Carlo samples are always drawn
    using the ``rvs`` method of `scipy.stats.random_table`.
    Otherwise, the p-value is computed as documented in the notes.

    .. versionadded:: 1.15.0

Returns
-------
res : SignificanceResult
    An object containing attributes:

    statistic : float
        For a 2x2 table with default `method`, this is the odds ratio - the
        prior odds ratio not a posterior estimate. In all other cases, this
        is the probability density of obtaining the observed table under the
        null hypothesis of independence with marginals fixed.
    pvalue : float
        The probability under the null hypothesis of obtaining a
        table at least as extreme as the one that was actually observed.

Raises
------
ValueError
    If `table` is not two-dimensional or has negative entries.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.  This can be used as an alternative to
    `fisher_exact` when the numbers in the table are large.
contingency.odds_ratio : Compute the odds ratio (sample or conditional
    MLE) for a 2x2 contingency table.
barnard_exact : Barnard's exact test, which is a more powerful alternative
    than Fisher's exact test for 2x2 contingency tables.
boschloo_exact : Boschloo's exact test, which is a more powerful
    alternative than Fisher's exact test for 2x2 contingency tables.
:ref:`hypothesis_fisher_exact` : Extended example

Notes
-----
*Null hypothesis and p-values*

The null hypothesis is that the true odds ratio of the populations
underlying the observations is one, and the observations were sampled at
random from these populations under a condition: the marginals of the
resulting table must equal those of the observed table. Equivalently,
the null hypothesis is that the input table is from the hypergeometric
distribution with parameters (as used in `hypergeom`)
``M = a + b + c + d``, ``n = a + b`` and ``N = a + c``, where the
input table is ``[[a, b], [c, d]]``.  This distribution has support
``max(0, N + n - M) <= x <= min(N, n)``, or, in terms of the values
in the input table, ``min(0, a - d) <= x <= a + min(b, c)``.  ``x``
can be interpreted as the upper-left element of a 2x2 table, so the
tables in the distribution have form::

    [  x           n - x     ]
    [N - x    M - (n + N) + x]

For example, if::

    table = [6  2]
            [1  4]

then the support is ``2 <= x <= 7``, and the tables in the distribution
are::

    [2 6]   [3 5]   [4 4]   [5 3]   [6 2]  [7 1]
    [5 0]   [4 1]   [3 2]   [2 3]   [1 4]  [0 5]

The probability of each table is given by the hypergeometric distribution
``hypergeom.pmf(x, M, n, N)``.  For this example, these are (rounded to
three significant digits)::

    x       2      3      4      5       6        7
    p  0.0163  0.163  0.408  0.326  0.0816  0.00466

These can be computed with::

    >>> import numpy as np
    >>> from scipy.stats import hypergeom
    >>> table = np.array([[6, 2], [1, 4]])
    >>> M = table.sum()
    >>> n = table[0].sum()
    >>> N = table[:, 0].sum()
    >>> start, end = hypergeom.support(M, n, N)
    >>> hypergeom.pmf(np.arange(start, end+1), M, n, N)
    array([0.01631702, 0.16317016, 0.40792541, 0.32634033, 0.08158508,
           0.004662  ])

The two-sided p-value is the probability that, under the null hypothesis,
a random table would have a probability equal to or less than the
probability of the input table.  For our example, the probability of
the input table (where ``x = 6``) is 0.0816.  The x values where the
probability does not exceed this are 2, 6 and 7, so the two-sided p-value
is ``0.0163 + 0.0816 + 0.00466 ~= 0.10256``::

    >>> from scipy.stats import fisher_exact
    >>> res = fisher_exact(table, alternative='two-sided')
    >>> res.pvalue
    0.10256410256410257

The one-sided p-value for ``alternative='greater'`` is the probability
that a random table has ``x >= a``, which in our example is ``x >= 6``,
or ``0.0816 + 0.00466 ~= 0.08626``::

    >>> res = fisher_exact(table, alternative='greater')
    >>> res.pvalue
    0.08624708624708627

This is equivalent to computing the survival function of the
distribution at ``x = 5`` (one less than ``x`` from the input table,
because we want to include the probability of ``x = 6`` in the sum)::

    >>> hypergeom.sf(5, M, n, N)
    0.08624708624708627

For ``alternative='less'``, the one-sided p-value is the probability
that a random table has ``x <= a``, (i.e. ``x <= 6`` in our example),
or ``0.0163 + 0.163 + 0.408 + 0.326 + 0.0816 ~= 0.9949``::

    >>> res = fisher_exact(table, alternative='less')
    >>> res.pvalue
    0.9953379953379957

This is equivalent to computing the cumulative distribution function
of the distribution at ``x = 6``:

    >>> hypergeom.cdf(6, M, n, N)
    0.9953379953379957

*Odds ratio*

The calculated odds ratio is different from the value computed by the
R function ``fisher.test``.  This implementation returns the "sample"
or "unconditional" maximum likelihood estimate, while ``fisher.test``
in R uses the conditional maximum likelihood estimate.  To compute the
conditional maximum likelihood estimate of the odds ratio, use
`scipy.stats.contingency.odds_ratio`.

References
----------
.. [1] Fisher, Sir Ronald A, "The Design of Experiments:
       Mathematics of a Lady Tasting Tea." ISBN 978-0-486-41151-4, 1935.
.. [2] "Fisher's exact test",
       https://en.wikipedia.org/wiki/Fisher's_exact_test

Examples
--------

>>> from scipy.stats import fisher_exact
>>> res = fisher_exact([[8, 2], [1, 5]])
>>> res.statistic
20.0
>>> res.pvalue
0.034965034965034975

For tables with shape other than ``(2, 2)``, provide an instance of
`scipy.stats.MonteCarloMethod` or `scipy.stats.PermutationMethod` for the
`method` parameter:

>>> import numpy as np
>>> from scipy.stats import MonteCarloMethod
>>> rng = np.random.default_rng(4507195762371367)
>>> method = MonteCarloMethod(rng=rng)
>>> fisher_exact([[8, 2, 3], [1, 5, 4]], method=method)
SignificanceResult(statistic=np.float64(0.005782), pvalue=np.float64(0.0603))

For a more detailed example, see :ref:`hypothesis_fisher_exact`.
================================================================================

fisk:
Firma: (*args, **kwds)

Docstring:
A Fisk continuous random variable.

The Fisk distribution is also known as the log-logistic distribution.

As an instance of the `rv_continuous` class, `fisk` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
burr

Notes
-----
The probability density function for `fisk` is:

.. math::

    f(x, c) = \frac{c x^{c-1}}
                   {(1 + x^c)^2}

for :math:`x >= 0` and :math:`c > 0`.

Please note that the above expression can be transformed into the following
one, which is also commonly used:

.. math::

    f(x, c) = \frac{c x^{-c-1}}
                   {(1 + x^{-c})^2}

`fisk` takes ``c`` as a shape parameter for :math:`c`.

`fisk` is a special case of `burr` or `burr12` with ``d=1``.

Suppose ``X`` is a logistic random variable with location ``l``
and scale ``s``. Then ``Y = exp(X)`` is a Fisk (log-logistic)
random variable with ``scale = exp(l)`` and shape ``c = 1/s``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``fisk.pdf(x, c, loc, scale)`` is identically
equivalent to ``fisk.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import fisk
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 3.09
>>> mean, var, skew, kurt = fisk.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(fisk.ppf(0.01, c),
...                 fisk.ppf(0.99, c), 100)
>>> ax.plot(x, fisk.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='fisk pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = fisk(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = fisk.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], fisk.cdf(vals, c))
True

Generate random numbers:

>>> r = fisk.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

fit:
Firma: (dist, data, bounds=None, *, guess=None, method='mle', optimizer=<function differential_evolution at 0x00000255C3447920>)

Docstring:
Fit a discrete or continuous distribution to data

Given a distribution, data, and bounds on the parameters of the
distribution, return maximum likelihood estimates of the parameters.

Parameters
----------
dist : `scipy.stats.rv_continuous` or `scipy.stats.rv_discrete`
    The object representing the distribution to be fit to the data.
data : 1D array_like
    The data to which the distribution is to be fit. If the data contain
    any of ``np.nan``, ``np.inf``, or -``np.inf``, the fit method will
    raise a ``ValueError``.
bounds : dict or sequence of tuples, optional
    If a dictionary, each key is the name of a parameter of the
    distribution, and the corresponding value is a tuple containing the
    lower and upper bound on that parameter.  If the distribution is
    defined only for a finite range of values of that parameter, no entry
    for that parameter is required; e.g., some distributions have
    parameters which must be on the interval [0, 1]. Bounds for parameters
    location (``loc``) and scale (``scale``) are optional; by default,
    they are fixed to 0 and 1, respectively.

    If a sequence, element *i* is a tuple containing the lower and upper
    bound on the *i*\ th parameter of the distribution. In this case,
    bounds for *all* distribution shape parameters must be provided.
    Optionally, bounds for location and scale may follow the
    distribution shape parameters.

    If a shape is to be held fixed (e.g. if it is known), the
    lower and upper bounds may be equal. If a user-provided lower or upper
    bound is beyond a bound of the domain for which the distribution is
    defined, the bound of the distribution's domain will replace the
    user-provided value. Similarly, parameters which must be integral
    will be constrained to integral values within the user-provided bounds.
guess : dict or array_like, optional
    If a dictionary, each key is the name of a parameter of the
    distribution, and the corresponding value is a guess for the value
    of the parameter.

    If a sequence, element *i* is a guess for the *i*\ th parameter of the
    distribution. In this case, guesses for *all* distribution shape
    parameters must be provided.

    If `guess` is not provided, guesses for the decision variables will
    not be passed to the optimizer. If `guess` is provided, guesses for
    any missing parameters will be set at the mean of the lower and
    upper bounds. Guesses for parameters which must be integral will be
    rounded to integral values, and guesses that lie outside the
    intersection of the user-provided bounds and the domain of the
    distribution will be clipped.
method : {'mle', 'mse'}
    With ``method="mle"`` (default), the fit is computed by minimizing
    the negative log-likelihood function. A large, finite penalty
    (rather than infinite negative log-likelihood) is applied for
    observations beyond the support of the distribution.
    With ``method="mse"``, the fit is computed by minimizing
    the negative log-product spacing function. The same penalty is applied
    for observations beyond the support. We follow the approach of [1]_,
    which is generalized for samples with repeated observations.
optimizer : callable, optional
    `optimizer` is a callable that accepts the following positional
    argument.

    fun : callable
        The objective function to be optimized. `fun` accepts one argument
        ``x``, candidate shape parameters of the distribution, and returns
        the objective function value given ``x``, `dist`, and the provided
        `data`.
        The job of `optimizer` is to find values of the decision variables
        that minimizes `fun`.

    `optimizer` must also accept the following keyword argument.

    bounds : sequence of tuples
        The bounds on values of the decision variables; each element will
        be a tuple containing the lower and upper bound on a decision
        variable.

    If `guess` is provided, `optimizer` must also accept the following
    keyword argument.

    x0 : array_like
        The guesses for each decision variable.

    If the distribution has any shape parameters that must be integral or
    if the distribution is discrete and the location parameter is not
    fixed, `optimizer` must also accept the following keyword argument.

    integrality : array_like of bools
        For each decision variable, True if the decision variable
        must be constrained to integer values and False if the decision
        variable is continuous.

    `optimizer` must return an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal values of
    the decision variables in an attribute ``x``. If attributes
    ``fun``, ``status``, or ``message`` are provided, they will be
    included in the result object returned by `fit`.

Returns
-------
result : `~scipy.stats._result_classes.FitResult`
    An object with the following fields.

    params : namedtuple
        A namedtuple containing the maximum likelihood estimates of the
        shape parameters, location, and (if applicable) scale of the
        distribution.
    success : bool or None
        Whether the optimizer considered the optimization to terminate
        successfully or not.
    message : str or None
        Any status message provided by the optimizer.

    The object has the following method:

    nllf(params=None, data=None)
        By default, the negative log-likelihood function at the fitted
        `params` for the given `data`. Accepts a tuple containing
        alternative shapes, location, and scale of the distribution and
        an array of alternative data.

    plot(ax=None)
        Superposes the PDF/PMF of the fitted distribution over a normalized
        histogram of the data.

See Also
--------
rv_continuous,  rv_discrete

Notes
-----
Optimization is more likely to converge to the maximum likelihood estimate
when the user provides tight bounds containing the maximum likelihood
estimate. For example, when fitting a binomial distribution to data, the
number of experiments underlying each sample may be known, in which case
the corresponding shape parameter ``n`` can be fixed.

References
----------
.. [1] Shao, Yongzhao, and Marjorie G. Hahn. "Maximum product of spacings
       method: a unified formulation with illustration of strong
       consistency." Illinois Journal of Mathematics 43.3 (1999): 489-499.

Examples
--------
Suppose we wish to fit a distribution to the following data.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> dist = stats.nbinom
>>> shapes = (5, 0.5)
>>> data = dist.rvs(*shapes, size=1000, random_state=rng)

Suppose we do not know how the data were generated, but we suspect that
it follows a negative binomial distribution with parameters *n* and *p*\.
(See `scipy.stats.nbinom`.) We believe that the parameter *n* was fewer
than 30, and we know that the parameter *p* must lie on the interval
[0, 1]. We record this information in a variable `bounds` and pass
this information to `fit`.

>>> bounds = [(0, 30), (0, 1)]
>>> res = stats.fit(dist, data, bounds)

`fit` searches within the user-specified `bounds` for the
values that best match the data (in the sense of maximum likelihood
estimation). In this case, it found shape values similar to those
from which the data were actually generated.

>>> res.params
FitParams(n=5.0, p=0.5028157644634368, loc=0.0)  # may vary

We can visualize the results by superposing the probability mass function
of the distribution (with the shapes fit to the data) over a normalized
histogram of the data.

>>> import matplotlib.pyplot as plt  # matplotlib must be installed to plot
>>> res.plot()
>>> plt.show()

Note that the estimate for *n* was exactly integral; this is because
the domain of the `nbinom` PMF includes only integral *n*, and the `nbinom`
object "knows" that. `nbinom` also knows that the shape *p* must be a
value between 0 and 1. In such a case - when the domain of the distribution
with respect to a parameter is finite - we are not required to specify
bounds for the parameter.

>>> bounds = {'n': (0, 30)}  # omit parameter p using a `dict`
>>> res2 = stats.fit(dist, data, bounds)
>>> res2.params
FitParams(n=5.0, p=0.5016492009232932, loc=0.0)  # may vary

If we wish to force the distribution to be fit with *n* fixed at 6, we can
set both the lower and upper bounds on *n* to 6. Note, however, that the
value of the objective function being optimized is typically worse (higher)
in this case.

>>> bounds = {'n': (6, 6)}  # fix parameter `n`
>>> res3 = stats.fit(dist, data, bounds)
>>> res3.params
FitParams(n=6.0, p=0.5486556076755706, loc=0.0)  # may vary
>>> res3.nllf() > res.nllf()
True  # may vary

Note that the numerical results of the previous examples are typical, but
they may vary because the default optimizer used by `fit`,
`scipy.optimize.differential_evolution`, is stochastic. However, we can
customize the settings used by the optimizer to ensure reproducibility -
or even use a different optimizer entirely - using the `optimizer`
parameter.

>>> from scipy.optimize import differential_evolution
>>> rng = np.random.default_rng(767585560716548)
>>> def optimizer(fun, bounds, *, integrality):
...     return differential_evolution(fun, bounds, strategy='best2bin',
...                                   rng=rng, integrality=integrality)
>>> bounds = [(0, 30), (0, 1)]
>>> res4 = stats.fit(dist, data, bounds, optimizer=optimizer)
>>> res4.params
FitParams(n=5.0, p=0.5015183149259951, loc=0.0)
================================================================================

fligner:
Firma: (*samples, center='median', proportiontocut=0.05, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform Fligner-Killeen test for equality of variance.

Fligner's test tests the null hypothesis that all input samples
are from populations with equal variances.  Fligner-Killeen's test is
distribution free when populations are identical [2]_.

Parameters
----------
sample1, sample2, ... : array_like
    Arrays of sample data.  Need not be the same length.
center : {'mean', 'median', 'trimmed'}, optional
    Keyword argument controlling which function of the data is used in
    computing the test statistic.  The default is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the hypothesis test.

See Also
--------

:func:`bartlett`
    A parametric test for equality of k variances in normal samples
:func:`levene`
    A robust parametric test for equality of k variances
:ref:`hypothesis_fligner`
    Extended example


Notes
-----
As with Levene's test there are three variants of Fligner's test that
differ by the measure of central tendency used in the test.  See `levene`
for more information.

Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power
[3]_.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
       https://cecas.clemson.edu/~cspark/cv/paper/qif/draftqif2.pdf
.. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample
       tests for scale. Journal of the American Statistical Association.
       71(353), 210-213.
.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
.. [4] Conover, W. J., Johnson, M. E. and Johnson M. M. (1981). A
       comparative study of tests for homogeneity of variances, with
       applications to the outer continental shelf bidding data.
       Technometrics, 23(4), 351-361.

Examples
--------
>>> import numpy as np
>>> from scipy import stats

Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

>>> a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
>>> b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
>>> c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
>>> stat, p = stats.fligner(a, b, c)
>>> p
0.00450826080004775

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

>>> [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]

For a more detailed example, see :ref:`hypothesis_fligner`.
================================================================================

foldcauchy:
Firma: (*args, **kwds)

Docstring:
A folded Cauchy continuous random variable.

As an instance of the `rv_continuous` class, `foldcauchy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `foldcauchy` is:

.. math::

    f(x, c) = \frac{1}{\pi (1+(x-c)^2)} + \frac{1}{\pi (1+(x+c)^2)}

for :math:`x \ge 0` and :math:`c \ge 0`.

`foldcauchy` takes ``c`` as a shape parameter for :math:`c`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import foldcauchy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 4.72
>>> mean, var, skew, kurt = foldcauchy.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(foldcauchy.ppf(0.01, c),
...                 foldcauchy.ppf(0.99, c), 100)
>>> ax.plot(x, foldcauchy.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='foldcauchy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = foldcauchy(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = foldcauchy.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], foldcauchy.cdf(vals, c))
True

Generate random numbers:

>>> r = foldcauchy.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

foldnorm:
Firma: (*args, **kwds)

Docstring:
A folded normal continuous random variable.

As an instance of the `rv_continuous` class, `foldnorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `foldnorm` is:

.. math::

    f(x, c) = \sqrt{2/\pi} cosh(c x) \exp(-\frac{x^2+c^2}{2})

for :math:`x \ge 0` and :math:`c \ge 0`.

`foldnorm` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``foldnorm.pdf(x, c, loc, scale)`` is identically
equivalent to ``foldnorm.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import foldnorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 1.95
>>> mean, var, skew, kurt = foldnorm.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(foldnorm.ppf(0.01, c),
...                 foldnorm.ppf(0.99, c), 100)
>>> ax.plot(x, foldnorm.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='foldnorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = foldnorm(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = foldnorm.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], foldnorm.cdf(vals, c))
True

Generate random numbers:

>>> r = foldnorm.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

friedmanchisquare:
Firma: (*samples, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Compute the Friedman test for repeated samples.

The Friedman test tests the null hypothesis that repeated samples of
the same individuals have the same distribution.  It is often used
to test for consistency among samples obtained in different ways.
For example, if two sampling techniques are used on the same set of
individuals, the Friedman test can be used to determine if the two
sampling techniques are consistent.

Parameters
----------
sample1, sample2, sample3... : array_like
    Arrays of observations.  All of the arrays must have the same number
    of elements.  At least three samples must be given.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic, correcting for ties.
pvalue : float
    The associated p-value assuming that the test statistic has a chi
    squared distribution.

See Also
--------

:ref:`hypothesis_friedmanchisquare`
    Extended example


Notes
-----
Due to the assumption that the test statistic has a chi squared
distribution, the p-value is only reliable for n > 10 and more than
6 repeated samples.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://en.wikipedia.org/wiki/Friedman_test
.. [2] Demsar, J. (2006). Statistical comparisons of classifiers over
       multiple data sets. Journal of Machine Learning Research, 7, 1-30.

Examples
--------
>>> import numpy as np
>>> rng = np.random.default_rng(seed=18)
>>> x = rng.random((6, 10))
>>> from scipy.stats import friedmanchisquare
>>> res = friedmanchisquare(x[0], x[1], x[2], x[3], x[4], x[5])
>>> res.statistic, res.pvalue
(11.428571428571416, 0.043514520866727614)

The p-value is less than 0.05; however, as noted above, the results may not
be reliable since we have a small number of repeated samples.

For a more detailed example, see :ref:`hypothesis_friedmanchisquare`.
================================================================================

gamma:
Firma: (*args, **kwds)

Docstring:
A gamma continuous random variable.

As an instance of the `rv_continuous` class, `gamma` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
erlang, expon

Notes
-----
The probability density function for `gamma` is:

.. math::

    f(x, a) = \frac{x^{a-1} e^{-x}}{\Gamma(a)}

for :math:`x \ge 0`, :math:`a > 0`. Here :math:`\Gamma(a)` refers to the
gamma function.

`gamma` takes ``a`` as a shape parameter for :math:`a`.

When :math:`a` is an integer, `gamma` reduces to the Erlang
distribution, and when :math:`a=1` to the exponential distribution.

Gamma distributions are sometimes parameterized with two variables,
with a probability density function of:

.. math::

    f(x, \alpha, \beta) =
    \frac{\beta^\alpha x^{\alpha - 1} e^{-\beta x }}{\Gamma(\alpha)}

Note that this parameterization is equivalent to the above, with
``scale = 1 / beta``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gamma.pdf(x, a, loc, scale)`` is identically
equivalent to ``gamma.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gamma
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 1.99
>>> mean, var, skew, kurt = gamma.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gamma.ppf(0.01, a),
...                 gamma.ppf(0.99, a), 100)
>>> ax.plot(x, gamma.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='gamma pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gamma(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gamma.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], gamma.cdf(vals, a))
True

Generate random numbers:

>>> r = gamma.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gausshyper:
Firma: (*args, **kwds)

Docstring:
A Gauss hypergeometric continuous random variable.

As an instance of the `rv_continuous` class, `gausshyper` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, c, z, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, c, z, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, c, z, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, c, z, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, c, z, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, c, z, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, c, z, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, c, z, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, c, z, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, c, z, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, c, z, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, c, z, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b, c, z), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, c, z, loc=0, scale=1)
    Median of the distribution.
mean(a, b, c, z, loc=0, scale=1)
    Mean of the distribution.
var(a, b, c, z, loc=0, scale=1)
    Variance of the distribution.
std(a, b, c, z, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, c, z, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `gausshyper` is:

.. math::

    f(x, a, b, c, z) = C x^{a-1} (1-x)^{b-1} (1+zx)^{-c}

for :math:`0 \le x \le 1`, :math:`a,b > 0`, :math:`c` a real number,
:math:`z > -1`, and :math:`C = \frac{1}{B(a, b) F[2, 1](c, a; a+b; -z)}`.
:math:`F[2, 1]` is the Gauss hypergeometric function
`scipy.special.hyp2f1`.

`gausshyper` takes :math:`a`, :math:`b`, :math:`c` and :math:`z` as shape
parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gausshyper.pdf(x, a, b, c, z, loc, scale)`` is identically
equivalent to ``gausshyper.pdf(y, a, b, c, z) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Armero, C., and M. J. Bayarri. "Prior Assessments for Prediction in
       Queues." *Journal of the Royal Statistical Society*. Series D (The
       Statistician) 43, no. 1 (1994): 139-53. doi:10.2307/2348939

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gausshyper
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b, c, z = 13.8, 3.12, 2.51, 5.18
>>> mean, var, skew, kurt = gausshyper.stats(a, b, c, z, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gausshyper.ppf(0.01, a, b, c, z),
...                 gausshyper.ppf(0.99, a, b, c, z), 100)
>>> ax.plot(x, gausshyper.pdf(x, a, b, c, z),
...        'r-', lw=5, alpha=0.6, label='gausshyper pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gausshyper(a, b, c, z)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gausshyper.ppf([0.001, 0.5, 0.999], a, b, c, z)
>>> np.allclose([0.001, 0.5, 0.999], gausshyper.cdf(vals, a, b, c, z))
True

Generate random numbers:

>>> r = gausshyper.rvs(a, b, c, z, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gaussian_kde:
Firma: (dataset, bw_method=None, weights=None)

Docstring:
Representation of a kernel-density estimate using Gaussian kernels.

Kernel density estimation is a way to estimate the probability density
function (PDF) of a random variable in a non-parametric way.
`gaussian_kde` works for both uni-variate and multi-variate data.   It
includes automatic bandwidth determination.  The estimation works best for
a unimodal distribution; bimodal or multi-modal distributions tend to be
oversmoothed.

Parameters
----------
dataset : array_like
    Datapoints to estimate from. In case of univariate data this is a 1-D
    array, otherwise a 2-D array with shape (# of dims, # of data).
bw_method : str, scalar or callable, optional
    The method used to calculate the estimator bandwidth.  This can be
    'scott', 'silverman', a scalar constant or a callable.  If a scalar,
    this will be used directly as `kde.factor`.  If a callable, it should
    take a `gaussian_kde` instance as only parameter and return a scalar.
    If None (default), 'scott' is used.  See Notes for more details.
weights : array_like, optional
    weights of datapoints. This must be the same shape as dataset.
    If None (default), the samples are assumed to be equally weighted

Attributes
----------
dataset : ndarray
    The dataset with which `gaussian_kde` was initialized.
d : int
    Number of dimensions.
n : int
    Number of datapoints.
neff : int
    Effective number of datapoints.

    .. versionadded:: 1.2.0
factor : float
    The bandwidth factor, obtained from `kde.covariance_factor`. The square
    of `kde.factor` multiplies the covariance matrix of the data in the kde
    estimation.
covariance : ndarray
    The covariance matrix of `dataset`, scaled by the calculated bandwidth
    (`kde.factor`).
inv_cov : ndarray
    The inverse of `covariance`.

Methods
-------
evaluate
__call__
integrate_gaussian
integrate_box_1d
integrate_box
integrate_kde
pdf
logpdf
resample
set_bandwidth
covariance_factor

Notes
-----
Bandwidth selection strongly influences the estimate obtained from the KDE
(much more so than the actual shape of the kernel).  Bandwidth selection
can be done by a "rule of thumb", by cross-validation, by "plug-in
methods" or by other means; see [3]_, [4]_ for reviews.  `gaussian_kde`
uses a rule of thumb, the default is Scott's Rule.

Scott's Rule [1]_, implemented as `scotts_factor`, is::

    n**(-1./(d+4)),

with ``n`` the number of data points and ``d`` the number of dimensions.
In the case of unequally weighted points, `scotts_factor` becomes::

    neff**(-1./(d+4)),

with ``neff`` the effective number of datapoints.
Silverman's Rule [2]_, implemented as `silverman_factor`, is::

    (n * (d + 2) / 4.)**(-1. / (d + 4)).

or in the case of unequally weighted points::

    (neff * (d + 2) / 4.)**(-1. / (d + 4)).

Good general descriptions of kernel density estimation can be found in [1]_
and [2]_, the mathematics for this multi-dimensional implementation can be
found in [1]_.

With a set of weighted samples, the effective number of datapoints ``neff``
is defined by::

    neff = sum(weights)^2 / sum(weights^2)

as detailed in [5]_.

`gaussian_kde` does not currently support data that lies in a
lower-dimensional subspace of the space in which it is expressed. For such
data, consider performing principal component analysis / dimensionality
reduction and using `gaussian_kde` with the transformed data.

References
----------
.. [1] D.W. Scott, "Multivariate Density Estimation: Theory, Practice, and
       Visualization", John Wiley & Sons, New York, Chicester, 1992.
.. [2] B.W. Silverman, "Density Estimation for Statistics and Data
       Analysis", Vol. 26, Monographs on Statistics and Applied Probability,
       Chapman and Hall, London, 1986.
.. [3] B.A. Turlach, "Bandwidth Selection in Kernel Density Estimation: A
       Review", CORE and Institut de Statistique, Vol. 19, pp. 1-33, 1993.
.. [4] D.M. Bashtannyk and R.J. Hyndman, "Bandwidth selection for kernel
       conditional density estimation", Computational Statistics & Data
       Analysis, Vol. 36, pp. 279-298, 2001.
.. [5] Gray P. G., 1969, Journal of the Royal Statistical Society.
       Series A (General), 132, 272

Examples
--------
Generate some random two-dimensional data:

>>> import numpy as np
>>> from scipy import stats
>>> def measure(n):
...     "Measurement model, return two coupled measurements."
...     m1 = np.random.normal(size=n)
...     m2 = np.random.normal(scale=0.5, size=n)
...     return m1+m2, m1-m2

>>> m1, m2 = measure(2000)
>>> xmin = m1.min()
>>> xmax = m1.max()
>>> ymin = m2.min()
>>> ymax = m2.max()

Perform a kernel density estimate on the data:

>>> X, Y = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]
>>> positions = np.vstack([X.ravel(), Y.ravel()])
>>> values = np.vstack([m1, m2])
>>> kernel = stats.gaussian_kde(values)
>>> Z = np.reshape(kernel(positions).T, X.shape)

Plot the results:

>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots()
>>> ax.imshow(np.rot90(Z), cmap=plt.cm.gist_earth_r,
...           extent=[xmin, xmax, ymin, ymax])
>>> ax.plot(m1, m2, 'k.', markersize=2)
>>> ax.set_xlim([xmin, xmax])
>>> ax.set_ylim([ymin, ymax])
>>> plt.show()
================================================================================

genexpon:
Firma: (*args, **kwds)

Docstring:
A generalized exponential continuous random variable.

As an instance of the `rv_continuous` class, `genexpon` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, c, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b, c), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, c, loc=0, scale=1)
    Median of the distribution.
mean(a, b, c, loc=0, scale=1)
    Mean of the distribution.
var(a, b, c, loc=0, scale=1)
    Variance of the distribution.
std(a, b, c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `genexpon` is:

.. math::

    f(x, a, b, c) = (a + b (1 - \exp(-c x)))
                    \exp(-a x - b x + \frac{b}{c}  (1-\exp(-c x)))

for :math:`x \ge 0`, :math:`a, b, c > 0`.

`genexpon` takes :math:`a`, :math:`b` and :math:`c` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genexpon.pdf(x, a, b, c, loc, scale)`` is identically
equivalent to ``genexpon.pdf(y, a, b, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
H.K. Ryu, "An Extension of Marshall and Olkin's Bivariate Exponential
Distribution", Journal of the American Statistical Association, 1993.

N. Balakrishnan, Asit P. Basu (editors), *The Exponential Distribution:
Theory, Methods and Applications*, Gordon and Breach, 1995.
ISBN 10: 2884491929

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genexpon
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b, c = 9.13, 16.2, 3.28
>>> mean, var, skew, kurt = genexpon.stats(a, b, c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genexpon.ppf(0.01, a, b, c),
...                 genexpon.ppf(0.99, a, b, c), 100)
>>> ax.plot(x, genexpon.pdf(x, a, b, c),
...        'r-', lw=5, alpha=0.6, label='genexpon pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genexpon(a, b, c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genexpon.ppf([0.001, 0.5, 0.999], a, b, c)
>>> np.allclose([0.001, 0.5, 0.999], genexpon.cdf(vals, a, b, c))
True

Generate random numbers:

>>> r = genexpon.rvs(a, b, c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

genextreme:
Firma: (*args, **kwds)

Docstring:
A generalized extreme value continuous random variable.

As an instance of the `rv_continuous` class, `genextreme` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gumbel_r

Notes
-----
For :math:`c=0`, `genextreme` is equal to `gumbel_r` with
probability density function

.. math::

    f(x) = \exp(-\exp(-x)) \exp(-x),

where :math:`-\infty < x < \infty`.

For :math:`c \ne 0`, the probability density function for `genextreme` is:

.. math::

    f(x, c) = \exp(-(1-c x)^{1/c}) (1-c x)^{1/c-1},

where :math:`-\infty < x \le 1/c` if :math:`c > 0` and
:math:`1/c \le x < \infty` if :math:`c < 0`.

Note that several sources and software packages use the opposite
convention for the sign of the shape parameter :math:`c`.

`genextreme` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genextreme.pdf(x, c, loc, scale)`` is identically
equivalent to ``genextreme.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genextreme
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = -0.1
>>> mean, var, skew, kurt = genextreme.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genextreme.ppf(0.01, c),
...                 genextreme.ppf(0.99, c), 100)
>>> ax.plot(x, genextreme.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='genextreme pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genextreme(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genextreme.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], genextreme.cdf(vals, c))
True

Generate random numbers:

>>> r = genextreme.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gengamma:
Firma: (*args, **kwds)

Docstring:
A generalized gamma continuous random variable.

As an instance of the `rv_continuous` class, `gengamma` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, c, loc=0, scale=1)
    Probability density function.
logpdf(x, a, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, c), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, c, loc=0, scale=1)
    Median of the distribution.
mean(a, c, loc=0, scale=1)
    Mean of the distribution.
var(a, c, loc=0, scale=1)
    Variance of the distribution.
std(a, c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gamma, invgamma, weibull_min

Notes
-----
The probability density function for `gengamma` is ([1]_):

.. math::

    f(x, a, c) = \frac{|c| x^{c a-1} \exp(-x^c)}{\Gamma(a)}

for :math:`x \ge 0`, :math:`a > 0`, and :math:`c \ne 0`.
:math:`\Gamma` is the gamma function (`scipy.special.gamma`).

`gengamma` takes :math:`a` and :math:`c` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gengamma.pdf(x, a, c, loc, scale)`` is identically
equivalent to ``gengamma.pdf(y, a, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] E.W. Stacy, "A Generalization of the Gamma Distribution",
   Annals of Mathematical Statistics, Vol 33(3), pp. 1187--1192.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gengamma
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, c = 4.42, -3.12
>>> mean, var, skew, kurt = gengamma.stats(a, c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gengamma.ppf(0.01, a, c),
...                 gengamma.ppf(0.99, a, c), 100)
>>> ax.plot(x, gengamma.pdf(x, a, c),
...        'r-', lw=5, alpha=0.6, label='gengamma pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gengamma(a, c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gengamma.ppf([0.001, 0.5, 0.999], a, c)
>>> np.allclose([0.001, 0.5, 0.999], gengamma.cdf(vals, a, c))
True

Generate random numbers:

>>> r = gengamma.rvs(a, c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

genhalflogistic:
Firma: (*args, **kwds)

Docstring:
A generalized half-logistic continuous random variable.

As an instance of the `rv_continuous` class, `genhalflogistic` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `genhalflogistic` is:

.. math::

    f(x, c) = \frac{2 (1 - c x)^{1/(c-1)}}{[1 + (1 - c x)^{1/c}]^2}

for :math:`0 \le x \le 1/c`, and :math:`c > 0`.

`genhalflogistic` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genhalflogistic.pdf(x, c, loc, scale)`` is identically
equivalent to ``genhalflogistic.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genhalflogistic
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.773
>>> mean, var, skew, kurt = genhalflogistic.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genhalflogistic.ppf(0.01, c),
...                 genhalflogistic.ppf(0.99, c), 100)
>>> ax.plot(x, genhalflogistic.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='genhalflogistic pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genhalflogistic(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genhalflogistic.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], genhalflogistic.cdf(vals, c))
True

Generate random numbers:

>>> r = genhalflogistic.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

genhyperbolic:
Firma: (*args, **kwds)

Docstring:
A generalized hyperbolic continuous random variable.

As an instance of the `rv_continuous` class, `genhyperbolic` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, p, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, p, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, p, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, p, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, p, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, p, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, p, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, p, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(p, a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(p, a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, a, b, loc=0, scale=1)
    Median of the distribution.
mean(p, a, b, loc=0, scale=1)
    Mean of the distribution.
var(p, a, b, loc=0, scale=1)
    Variance of the distribution.
std(p, a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, p, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
t, norminvgauss, geninvgauss, laplace, cauchy

Notes
-----
The probability density function for `genhyperbolic` is:

.. math::

    f(x, p, a, b) =
        \frac{(a^2 - b^2)^{p/2}}
        {\sqrt{2\pi}a^{p-1/2}
        K_p\Big(\sqrt{a^2 - b^2}\Big)}
        e^{bx} \times \frac{K_{p - 1/2}
        (a \sqrt{1 + x^2})}
        {(\sqrt{1 + x^2})^{1/2 - p}}

for :math:`x, p \in ( - \infty; \infty)`,
:math:`|b| < a` if :math:`p \ge 0`,
:math:`|b| \le a` if :math:`p < 0`.
:math:`K_{p}(.)` denotes the modified Bessel function of the second
kind and order :math:`p` (`scipy.special.kv`)

`genhyperbolic` takes ``p`` as a tail parameter,
``a`` as a shape parameter,
``b`` as a skewness parameter.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genhyperbolic.pdf(x, p, a, b, loc, scale)`` is identically
equivalent to ``genhyperbolic.pdf(y, p, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The original parameterization of the Generalized Hyperbolic Distribution
is found in [1]_ as follows

.. math::

    f(x, \lambda, \alpha, \beta, \delta, \mu) =
       \frac{(\gamma/\delta)^\lambda}{\sqrt{2\pi}K_\lambda(\delta \gamma)}
       e^{\beta (x - \mu)} \times \frac{K_{\lambda - 1/2}
       (\alpha \sqrt{\delta^2 + (x - \mu)^2})}
       {(\sqrt{\delta^2 + (x - \mu)^2} / \alpha)^{1/2 - \lambda}}

for :math:`x \in ( - \infty; \infty)`,
:math:`\gamma := \sqrt{\alpha^2 - \beta^2}`,
:math:`\lambda, \mu \in ( - \infty; \infty)`,
:math:`\delta \ge 0, |\beta| < \alpha` if :math:`\lambda \ge 0`,
:math:`\delta > 0, |\beta| \le \alpha` if :math:`\lambda < 0`.

The location-scale-based parameterization implemented in
SciPy is based on [2]_, where :math:`a = \alpha\delta`,
:math:`b = \beta\delta`, :math:`p = \lambda`,
:math:`scale=\delta` and :math:`loc=\mu`

Moments are implemented based on [3]_ and [4]_.

For the distributions that are a special case such as Student's t,
it is not recommended to rely on the implementation of genhyperbolic.
To avoid potential numerical problems and for performance reasons,
the methods of the specific distributions should be used.

References
----------
.. [1] O. Barndorff-Nielsen, "Hyperbolic Distributions and Distributions
   on Hyperbolae", Scandinavian Journal of Statistics, Vol. 5(3),
   pp. 151-157, 1978. https://www.jstor.org/stable/4615705

.. [2] Eberlein E., Prause K. (2002) The Generalized Hyperbolic Model:
    Financial Derivatives and Risk Measures. In: Geman H., Madan D.,
    Pliska S.R., Vorst T. (eds) Mathematical Finance - Bachelier
    Congress 2000. Springer Finance. Springer, Berlin, Heidelberg.
    :doi:`10.1007/978-3-662-12429-1_12`

.. [3] Scott, David J, Würtz, Diethelm, Dong, Christine and Tran,
   Thanh Tam, (2009), Moments of the generalized hyperbolic
   distribution, MPRA Paper, University Library of Munich, Germany,
   https://EconPapers.repec.org/RePEc:pra:mprapa:19081.

.. [4] E. Eberlein and E. A. von Hammerstein. Generalized hyperbolic
   and inverse Gaussian distributions: Limiting cases and approximation
   of processes. FDM Preprint 80, April 2003. University of Freiburg.
   https://freidok.uni-freiburg.de/fedora/objects/freidok:7974/datastreams/FILE1/content

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genhyperbolic
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p, a, b = 0.5, 1.5, -0.5
>>> mean, var, skew, kurt = genhyperbolic.stats(p, a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genhyperbolic.ppf(0.01, p, a, b),
...                 genhyperbolic.ppf(0.99, p, a, b), 100)
>>> ax.plot(x, genhyperbolic.pdf(x, p, a, b),
...        'r-', lw=5, alpha=0.6, label='genhyperbolic pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genhyperbolic(p, a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genhyperbolic.ppf([0.001, 0.5, 0.999], p, a, b)
>>> np.allclose([0.001, 0.5, 0.999], genhyperbolic.cdf(vals, p, a, b))
True

Generate random numbers:

>>> r = genhyperbolic.rvs(p, a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

geninvgauss:
Firma: (*args, **kwds)

Docstring:
A Generalized Inverse Gaussian continuous random variable.

As an instance of the `rv_continuous` class, `geninvgauss` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, p, b, loc=0, scale=1)
    Probability density function.
logpdf(x, p, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, p, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, p, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, p, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, p, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, p, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, p, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(p, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(p, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, b, loc=0, scale=1)
    Median of the distribution.
mean(p, b, loc=0, scale=1)
    Mean of the distribution.
var(p, b, loc=0, scale=1)
    Variance of the distribution.
std(p, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, p, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `geninvgauss` is:

.. math::

    f(x, p, b) = x^{p-1} \exp(-b (x + 1/x) / 2) / (2 K_p(b))

where ``x > 0``, `p` is a real number and ``b > 0``\([1]_).
:math:`K_p` is the modified Bessel function of second kind of order `p`
(`scipy.special.kv`).

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``geninvgauss.pdf(x, p, b, loc, scale)`` is identically
equivalent to ``geninvgauss.pdf(y, p, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The inverse Gaussian distribution `stats.invgauss(mu)` is a special case of
`geninvgauss` with ``p = -1/2``, ``b = 1 / mu`` and ``scale = mu``.

Generating random variates is challenging for this distribution. The
implementation is based on [2]_.

References
----------
.. [1] O. Barndorff-Nielsen, P. Blaesild, C. Halgreen, "First hitting time
   models for the generalized inverse gaussian distribution",
   Stochastic Processes and their Applications 7, pp. 49--54, 1978.

.. [2] W. Hoermann and J. Leydold, "Generating generalized inverse Gaussian
   random variates", Statistics and Computing, 24(4), p. 547--557, 2014.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import geninvgauss
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p, b = 2.3, 1.5
>>> mean, var, skew, kurt = geninvgauss.stats(p, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(geninvgauss.ppf(0.01, p, b),
...                 geninvgauss.ppf(0.99, p, b), 100)
>>> ax.plot(x, geninvgauss.pdf(x, p, b),
...        'r-', lw=5, alpha=0.6, label='geninvgauss pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = geninvgauss(p, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = geninvgauss.ppf([0.001, 0.5, 0.999], p, b)
>>> np.allclose([0.001, 0.5, 0.999], geninvgauss.cdf(vals, p, b))
True

Generate random numbers:

>>> r = geninvgauss.rvs(p, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

genlogistic:
Firma: (*args, **kwds)

Docstring:
A generalized logistic continuous random variable.

As an instance of the `rv_continuous` class, `genlogistic` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `genlogistic` is:

.. math::

    f(x, c) = c \frac{\exp(-x)}
                     {(1 + \exp(-x))^{c+1}}

for real :math:`x` and :math:`c > 0`. In literature, different
generalizations of the logistic distribution can be found. This is the type 1
generalized logistic distribution according to [1]_. It is also referred to
as the skew-logistic distribution [2]_.

`genlogistic` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genlogistic.pdf(x, c, loc, scale)`` is identically
equivalent to ``genlogistic.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Johnson et al. "Continuous Univariate Distributions", Volume 2,
       Wiley. 1995.
.. [2] "Generalized Logistic Distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Generalized_logistic_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genlogistic
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.412
>>> mean, var, skew, kurt = genlogistic.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genlogistic.ppf(0.01, c),
...                 genlogistic.ppf(0.99, c), 100)
>>> ax.plot(x, genlogistic.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='genlogistic pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genlogistic(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genlogistic.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], genlogistic.cdf(vals, c))
True

Generate random numbers:

>>> r = genlogistic.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gennorm:
Firma: (*args, **kwds)

Docstring:
A generalized normal continuous random variable.

As an instance of the `rv_continuous` class, `gennorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(beta, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, beta, loc=0, scale=1)
    Probability density function.
logpdf(x, beta, loc=0, scale=1)
    Log of the probability density function.
cdf(x, beta, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, beta, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, beta, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, beta, loc=0, scale=1)
    Log of the survival function.
ppf(q, beta, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, beta, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, beta, loc=0, scale=1)
    Non-central moment of the specified order.
stats(beta, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(beta, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(beta,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(beta, loc=0, scale=1)
    Median of the distribution.
mean(beta, loc=0, scale=1)
    Mean of the distribution.
var(beta, loc=0, scale=1)
    Variance of the distribution.
std(beta, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, beta, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
laplace : Laplace distribution
norm : normal distribution

Notes
-----
The probability density function for `gennorm` is [1]_:

.. math::

    f(x, \beta) = \frac{\beta}{2 \Gamma(1/\beta)} \exp(-|x|^\beta),

where :math:`x` is a real number, :math:`\beta > 0` and
:math:`\Gamma` is the gamma function (`scipy.special.gamma`).

`gennorm` takes ``beta`` as a shape parameter for :math:`\beta`.
For :math:`\beta = 1`, it is identical to a Laplace distribution.
For :math:`\beta = 2`, it is identical to a normal distribution
(with ``scale=1/sqrt(2)``).

References
----------

.. [1] "Generalized normal distribution, Version 1",
       https://en.wikipedia.org/wiki/Generalized_normal_distribution#Version_1

.. [2] Nardon, Martina, and Paolo Pianca. "Simulation techniques for
       generalized Gaussian densities." Journal of Statistical
       Computation and Simulation 79.11 (2009): 1317-1329

.. [3] Wicklin, Rick. "Simulate data from a generalized Gaussian
       distribution" in The DO Loop blog, September 21, 2016,
       https://blogs.sas.com/content/iml/2016/09/21/simulate-generalized-gaussian-sas.html

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gennorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> beta = 1.3
>>> mean, var, skew, kurt = gennorm.stats(beta, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gennorm.ppf(0.01, beta),
...                 gennorm.ppf(0.99, beta), 100)
>>> ax.plot(x, gennorm.pdf(x, beta),
...        'r-', lw=5, alpha=0.6, label='gennorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gennorm(beta)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gennorm.ppf([0.001, 0.5, 0.999], beta)
>>> np.allclose([0.001, 0.5, 0.999], gennorm.cdf(vals, beta))
True

Generate random numbers:

>>> r = gennorm.rvs(beta, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

genpareto:
Firma: (*args, **kwds)

Docstring:
A generalized Pareto continuous random variable.

As an instance of the `rv_continuous` class, `genpareto` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `genpareto` is:

.. math::

    f(x, c) = (1 + c x)^{-1 - 1/c}

defined for :math:`x \ge 0` if :math:`c \ge 0`, and for
:math:`0 \le x \le -1/c` if :math:`c < 0`.

`genpareto` takes ``c`` as a shape parameter for :math:`c`.

For :math:`c=0`, `genpareto` reduces to the exponential
distribution, `expon`:

.. math::

    f(x, 0) = \exp(-x)

For :math:`c=-1`, `genpareto` is uniform on ``[0, 1]``:

.. math::

    f(x, -1) = 1

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``genpareto.pdf(x, c, loc, scale)`` is identically
equivalent to ``genpareto.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import genpareto
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.1
>>> mean, var, skew, kurt = genpareto.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(genpareto.ppf(0.01, c),
...                 genpareto.ppf(0.99, c), 100)
>>> ax.plot(x, genpareto.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='genpareto pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = genpareto(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = genpareto.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], genpareto.cdf(vals, c))
True

Generate random numbers:

>>> r = genpareto.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

geom:
Firma: (*args, **kwds)

Docstring:
A geometric discrete random variable.

As an instance of the `rv_discrete` class, `geom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, p, loc=0)
    Probability mass function.
logpmf(k, p, loc=0)
    Log of the probability mass function.
cdf(k, p, loc=0)
    Cumulative distribution function.
logcdf(k, p, loc=0)
    Log of the cumulative distribution function.
sf(k, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, p, loc=0)
    Log of the survival function.
ppf(q, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(p,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, loc=0)
    Median of the distribution.
mean(p, loc=0)
    Mean of the distribution.
var(p, loc=0)
    Variance of the distribution.
std(p, loc=0)
    Standard deviation of the distribution.
interval(confidence, p, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `geom` is:

.. math::

    f(k) = (1-p)^{k-1} p

for :math:`k \ge 1`, :math:`0 < p \leq 1`

`geom` takes :math:`p` as shape parameter,
where :math:`p` is the probability of a single success
and :math:`1-p` is the probability of a single failure.

Note that when drawing random samples, the probability of observations that exceed
``np.iinfo(np.int64).max`` increases rapidly as $p$ decreases below $10^{-17}$. For
$p < 10^{-20}$, almost all observations would exceed the maximum ``int64``; however,
the output dtype is always ``int64``, so these values are clipped to the maximum.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``geom.pmf(k, p, loc)`` is identically
equivalent to ``geom.pmf(k - loc, p)``.

See Also
--------
planck

Examples
--------
>>> import numpy as np
>>> from scipy.stats import geom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p = 0.5
>>> mean, var, skew, kurt = geom.stats(p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(geom.ppf(0.01, p),
...               geom.ppf(0.99, p))
>>> ax.plot(x, geom.pmf(x, p), 'bo', ms=8, label='geom pmf')
>>> ax.vlines(x, 0, geom.pmf(x, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = geom(p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = geom.cdf(x, p)
>>> np.allclose(x, geom.ppf(prob, p))
True

Generate random numbers:

>>> r = geom.rvs(p, size=1000)
================================================================================

gibrat:
Firma: (*args, **kwds)

Docstring:
A Gibrat continuous random variable.

As an instance of the `rv_continuous` class, `gibrat` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `gibrat` is:

.. math::

    f(x) = \frac{1}{x \sqrt{2\pi}} \exp(-\frac{1}{2} (\log(x))^2)

for :math:`x >= 0`.

`gibrat` is a special case of `lognorm` with ``s=1``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gibrat.pdf(x, loc, scale)`` is identically
equivalent to ``gibrat.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gibrat
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = gibrat.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gibrat.ppf(0.01),
...                 gibrat.ppf(0.99), 100)
>>> ax.plot(x, gibrat.pdf(x),
...        'r-', lw=5, alpha=0.6, label='gibrat pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gibrat()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gibrat.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], gibrat.cdf(vals))
True

Generate random numbers:

>>> r = gibrat.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gmean:
Firma: (a, axis=0, dtype=None, weights=None, *, nan_policy='propagate', keepdims=False)

Docstring:
Compute the weighted geometric mean along the specified axis.

The weighted geometric mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

    \exp \left( \frac{ \sum_{i=1}^n w_i \ln a_i }{ \sum_{i=1}^n w_i }
               \right) \, ,

and, with equal weights, it gives:

.. math::

    \sqrt[n]{ \prod_{i=1}^n a_i } \, .

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
dtype : dtype, optional
    Type to which the input arrays are cast before the calculation is
    performed.
weights : array_like, optional
    The `weights` array must be broadcastable to the same shape as `a`.
    Default is None, which gives each value a weight of 1.0.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
gmean : ndarray
    See `dtype` parameter above.

See Also
--------

:func:`numpy.mean`
    Arithmetic average
:func:`numpy.average`
    Weighted average
:func:`hmean`
    Harmonic mean


Notes
-----
The sample geometric mean is the exponential of the mean of the natural
logarithms of the observations.
Negative observations will produce NaNs in the output because the *natural*
logarithm (as opposed to the *complex* logarithm) is defined only for
non-negative reals.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] "Weighted Geometric Mean", *Wikipedia*,
       https://en.wikipedia.org/wiki/Weighted_geometric_mean.
.. [2] Grossman, J., Grossman, M., Katz, R., "Averages: A New Approach",
       Archimedes Foundation, 1983

Examples
--------
>>> from scipy.stats import gmean
>>> gmean([1, 4])
2.0
>>> gmean([1, 2, 3, 4, 5, 6, 7])
3.3800151591412964
>>> gmean([1, 4, 7], weights=[3, 1, 3])
2.80668351922014
================================================================================

gompertz:
Firma: (*args, **kwds)

Docstring:
A Gompertz (or truncated Gumbel) continuous random variable.

As an instance of the `rv_continuous` class, `gompertz` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `gompertz` is:

.. math::

    f(x, c) = c \exp(x) \exp(-c (e^x-1))

for :math:`x \ge 0`, :math:`c > 0`.

`gompertz` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gompertz.pdf(x, c, loc, scale)`` is identically
equivalent to ``gompertz.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gompertz
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.947
>>> mean, var, skew, kurt = gompertz.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gompertz.ppf(0.01, c),
...                 gompertz.ppf(0.99, c), 100)
>>> ax.plot(x, gompertz.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='gompertz pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gompertz(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gompertz.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], gompertz.cdf(vals, c))
True

Generate random numbers:

>>> r = gompertz.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

goodness_of_fit:
Firma: (dist, data, *, known_params=None, fit_params=None, guessed_params=None, statistic='ad', n_mc_samples=9999, rng=None)

Docstring:
Perform a goodness of fit test comparing data to a distribution family.

Given a distribution family and data, perform a test of the null hypothesis
that the data were drawn from a distribution in that family. Any known
parameters of the distribution may be specified. Remaining parameters of
the distribution will be fit to the data, and the p-value of the test
is computed accordingly. Several statistics for comparing the distribution
to data are available.

Parameters
----------
dist : `scipy.stats.rv_continuous`
    The object representing the distribution family under the null
    hypothesis.
data : 1D array_like
    Finite, uncensored data to be tested.
known_params : dict, optional
    A dictionary containing name-value pairs of known distribution
    parameters. Monte Carlo samples are randomly drawn from the
    null-hypothesized distribution with these values of the parameters.
    Before the statistic is evaluated for the observed `data` and each
    Monte Carlo sample, only remaining unknown parameters of the
    null-hypothesized distribution family are fit to the samples; the
    known parameters are held fixed. If all parameters of the distribution
    family are known, then the step of fitting the distribution family to
    each sample is omitted.
fit_params : dict, optional
    A dictionary containing name-value pairs of distribution parameters
    that have already been fit to the data, e.g. using `scipy.stats.fit`
    or the ``fit`` method of `dist`. Monte Carlo samples are drawn from the
    null-hypothesized distribution with these specified values of the
    parameter. However, these and all other unknown parameters of the
    null-hypothesized distribution family are always fit to the sample,
    whether that is the observed `data` or a Monte Carlo sample, before
    the statistic is evaluated.
guessed_params : dict, optional
    A dictionary containing name-value pairs of distribution parameters
    which have been guessed. These parameters are always considered as
    free parameters and are fit both to the provided `data` as well as
    to the Monte Carlo samples drawn from the null-hypothesized
    distribution. The purpose of these `guessed_params` is to be used as
    initial values for the numerical fitting procedure.
statistic : {"ad", "ks", "cvm", "filliben"} or callable, optional
    The statistic used to compare data to a distribution after fitting
    unknown parameters of the distribution family to the data. The
    Anderson-Darling ("ad") [1]_, Kolmogorov-Smirnov ("ks") [1]_,
    Cramer-von Mises ("cvm") [1]_, and Filliben ("filliben") [7]_
    statistics are available.  Alternatively, a callable with signature
    ``(dist, data, axis)`` may be supplied to compute the statistic. Here
    ``dist`` is a frozen distribution object (potentially with array
    parameters), ``data`` is an array of Monte Carlo samples (of
    compatible shape), and ``axis`` is the axis of ``data`` along which
    the statistic must be computed.
n_mc_samples : int, default: 9999
    The number of Monte Carlo samples drawn from the null hypothesized
    distribution to form the null distribution of the statistic. The
    sample size of each is the same as the given `data`.
rng : {None, int, `numpy.random.Generator`}, optional
    If `rng` is passed by keyword, types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.
    If `rng` is already a ``Generator`` instance, then the provided instance is
    used. Specify `rng` for repeatable function behavior.

    If this argument is passed by position or `random_state` is passed by keyword,
    legacy behavior for the argument `random_state` applies:

    - If `random_state` is None (or `numpy.random`), the `numpy.random.RandomState`
      singleton is used.
    - If `random_state` is an int, a new ``RandomState`` instance is used,
      seeded with `random_state`.
    - If `random_state` is already a ``Generator`` or ``RandomState`` instance then
      that instance is used.

    .. versionchanged:: 1.15.0
        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this keyword was changed from `random_state` to `rng`.
        For an interim period, both keywords will continue to work, although only one
        may be specified at a time. After the interim period, function calls using the
        `random_state` keyword will emit warnings. The behavior of both `random_state` and
        `rng` are outlined above, but only the `rng` keyword should be used in new code.
        

Returns
-------
res : GoodnessOfFitResult
    An object with the following attributes.
    
    fit_result : `~scipy.stats._result_classes.FitResult`
        An object representing the fit of the provided `dist` to `data`.
        This  object includes the values of distribution family parameters
        that fully define the null-hypothesized distribution, that is,
        the distribution from which Monte Carlo samples are drawn.
    statistic : float
        The value of the statistic comparing provided `data` to the
        null-hypothesized distribution.
    pvalue : float
        The proportion of elements in the null distribution with
        statistic values at least as extreme as the statistic value of the
        provided `data`.
    null_distribution : ndarray
        The value of the statistic for each Monte Carlo sample
        drawn from the null-hypothesized distribution.

Notes
-----
This is a generalized Monte Carlo goodness-of-fit procedure, special cases
of which correspond with various Anderson-Darling tests, Lilliefors' test,
etc. The test is described in [2]_, [3]_, and [4]_ as a parametric
bootstrap test. This is a Monte Carlo test in which parameters that
specify the distribution from which samples are drawn have been estimated
from the data. We describe the test using "Monte Carlo" rather than
"parametric bootstrap" throughout to avoid confusion with the more familiar
nonparametric bootstrap, and describe how the test is performed below.

*Traditional goodness of fit tests*

Traditionally, critical values corresponding with a fixed set of
significance levels are pre-calculated using Monte Carlo methods. Users
perform the test by calculating the value of the test statistic only for
their observed `data` and comparing this value to tabulated critical
values. This practice is not very flexible, as tables are not available for
all distributions and combinations of known and unknown parameter values.
Also, results can be inaccurate when critical values are interpolated from
limited tabulated data to correspond with the user's sample size and
fitted parameter values. To overcome these shortcomings, this function
allows the user to perform the Monte Carlo trials adapted to their
particular data.

*Algorithmic overview*

In brief, this routine executes the following steps:

  1. Fit unknown parameters to the given `data`, thereby forming the
     "null-hypothesized" distribution, and compute the statistic of
     this pair of data and distribution.
  2. Draw random samples from this null-hypothesized distribution.
  3. Fit the unknown parameters to each random sample.
  4. Calculate the statistic between each sample and the distribution that
     has been fit to the sample.
  5. Compare the value of the statistic corresponding with `data` from (1)
     against the values of the statistic corresponding with the random
     samples from (4). The p-value is the proportion of samples with a
     statistic value greater than or equal to the statistic of the observed
     data.

In more detail, the steps are as follows.

First, any unknown parameters of the distribution family specified by
`dist` are fit to the provided `data` using maximum likelihood estimation.
(One exception is the normal distribution with unknown location and scale:
we use the bias-corrected standard deviation ``np.std(data, ddof=1)`` for
the scale as recommended in [1]_.)
These values of the parameters specify a particular member of the
distribution family referred to as the "null-hypothesized distribution",
that is, the distribution from which the data were sampled under the null
hypothesis. The `statistic`, which compares data to a distribution, is
computed between `data` and the null-hypothesized distribution.

Next, many (specifically `n_mc_samples`) new samples, each containing the
same number of observations as `data`, are drawn from the
null-hypothesized distribution. All unknown parameters of the distribution
family `dist` are fit to *each resample*, and the `statistic` is computed
between each sample and its corresponding fitted distribution. These
values of the statistic form the Monte Carlo null distribution (not to be
confused with the "null-hypothesized distribution" above).

The p-value of the test is the proportion of statistic values in the Monte
Carlo null distribution that are at least as extreme as the statistic value
of the provided `data`. More precisely, the p-value is given by

.. math::

    p = \frac{b + 1}
             {m + 1}

where :math:`b` is the number of statistic values in the Monte Carlo null
distribution that are greater than or equal to the statistic value
calculated for `data`, and :math:`m` is the number of elements in the
Monte Carlo null distribution (`n_mc_samples`). The addition of :math:`1`
to the numerator and denominator can be thought of as including the
value of the statistic corresponding with `data` in the null distribution,
but a more formal explanation is given in [5]_.

*Limitations*

The test can be very slow for some distribution families because unknown
parameters of the distribution family must be fit to each of the Monte
Carlo samples, and for most distributions in SciPy, distribution fitting
performed via numerical optimization.

*Anti-Pattern*

For this reason, it may be tempting
to treat parameters of the distribution pre-fit to `data` (by the user)
as though they were `known_params`, as specification of all parameters of
the distribution precludes the need to fit the distribution to each Monte
Carlo sample. (This is essentially how the original Kilmogorov-Smirnov
test is performed.) Although such a test can provide evidence against the
null hypothesis, the test is conservative in the sense that small p-values
will tend to (greatly) *overestimate* the probability of making a type I
error (that is, rejecting the null hypothesis although it is true), and the
power of the test is low (that is, it is less likely to reject the null
hypothesis even when the null hypothesis is false).
This is because the Monte Carlo samples are less likely to agree with the
null-hypothesized distribution as well as `data`. This tends to increase
the values of the statistic recorded in the null distribution, so that a
larger number of them exceed the value of statistic for `data`, thereby
inflating the p-value.

References
----------
.. [1] M. A. Stephens (1974). "EDF Statistics for Goodness of Fit and
       Some Comparisons." Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [2] W. Stute, W. G. Manteiga, and M. P. Quindimil (1993).
       "Bootstrap based goodness-of-fit-tests." Metrika 40.1: 243-256.
.. [3] C. Genest, & B Rémillard. (2008). "Validity of the parametric
       bootstrap for goodness-of-fit testing in semiparametric models."
       Annales de l'IHP Probabilités et statistiques. Vol. 44. No. 6.
.. [4] I. Kojadinovic and J. Yan (2012). "Goodness-of-fit testing based on
       a weighted bootstrap: A fast large-sample alternative to the
       parametric bootstrap." Canadian Journal of Statistics 40.3: 480-500.
.. [5] B. Phipson and G. K. Smyth (2010). "Permutation P-values Should
       Never Be Zero: Calculating Exact P-values When Permutations Are
       Randomly Drawn." Statistical Applications in Genetics and Molecular
       Biology 9.1.
.. [6] H. W. Lilliefors (1967). "On the Kolmogorov-Smirnov test for
       normality with mean and variance unknown." Journal of the American
       statistical Association 62.318: 399-402.
.. [7] Filliben, James J. "The probability plot correlation coefficient
       test for normality." Technometrics 17.1 (1975): 111-117.

Examples
--------
A well-known test of the null hypothesis that data were drawn from a
given distribution is the Kolmogorov-Smirnov (KS) test, available in SciPy
as `scipy.stats.ks_1samp`. Suppose we wish to test whether the following
data:

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = stats.uniform.rvs(size=75, random_state=rng)

were sampled from a normal distribution. To perform a KS test, the
empirical distribution function of the observed data will be compared
against the (theoretical) cumulative distribution function of a normal
distribution. Of course, to do this, the normal distribution under the null
hypothesis must be fully specified. This is commonly done by first fitting
the ``loc`` and ``scale`` parameters of the distribution to the observed
data, then performing the test.

>>> loc, scale = np.mean(x), np.std(x, ddof=1)
>>> cdf = stats.norm(loc, scale).cdf
>>> stats.ks_1samp(x, cdf)
KstestResult(statistic=0.1119257570456813,
             pvalue=0.2827756409939257,
             statistic_location=0.7751845155861765,
             statistic_sign=-1)

An advantage of the KS-test is that the p-value - the probability of
obtaining a value of the test statistic under the null hypothesis as
extreme as the value obtained from the observed data - can be calculated
exactly and efficiently. `goodness_of_fit` can only approximate these
results.

>>> known_params = {'loc': loc, 'scale': scale}
>>> res = stats.goodness_of_fit(stats.norm, x, known_params=known_params,
...                             statistic='ks', rng=rng)
>>> res.statistic, res.pvalue
(0.1119257570456813, 0.2788)

The statistic matches exactly, but the p-value is estimated by forming
a "Monte Carlo null distribution", that is, by explicitly drawing random
samples from `scipy.stats.norm` with the provided parameters and
calculating the stastic for each. The fraction of these statistic values
at least as extreme as ``res.statistic`` approximates the exact p-value
calculated by `scipy.stats.ks_1samp`.

However, in many cases, we would prefer to test only that the data were
sampled from one of *any* member of the normal distribution family, not
specifically from the normal distribution with the location and scale
fitted to the observed sample. In this case, Lilliefors [6]_ argued that
the KS test is far too conservative (that is, the p-value overstates
the actual probability of rejecting a true null hypothesis) and thus lacks
power - the ability to reject the null hypothesis when the null hypothesis
is actually false.
Indeed, our p-value above is approximately 0.28, which is far too large
to reject the null hypothesis at any common significance level.

Consider why this might be. Note that in the KS test above, the statistic
always compares data against the CDF of a normal distribution fitted to the
*observed data*. This tends to reduce the value of the statistic for the
observed data, but it is "unfair" when computing the statistic for other
samples, such as those we randomly draw to form the Monte Carlo null
distribution. It is easy to correct for this: whenever we compute the KS
statistic of a sample, we use the CDF of a normal distribution fitted
to *that sample*. The null distribution in this case has not been
calculated exactly and is tyically approximated using Monte Carlo methods
as described above. This is where `goodness_of_fit` excels.

>>> res = stats.goodness_of_fit(stats.norm, x, statistic='ks',
...                             rng=rng)
>>> res.statistic, res.pvalue
(0.1119257570456813, 0.0196)

Indeed, this p-value is much smaller, and small enough to (correctly)
reject the null hypothesis at common significance levels, including 5% and
2.5%.

However, the KS statistic is not very sensitive to all deviations from
normality. The original advantage of the KS statistic was the ability
to compute the null distribution theoretically, but a more sensitive
statistic - resulting in a higher test power - can be used now that we can
approximate the null distribution
computationally. The Anderson-Darling statistic [1]_ tends to be more
sensitive, and critical values of the this statistic have been tabulated
for various significance levels and sample sizes using Monte Carlo methods.

>>> res = stats.anderson(x, 'norm')
>>> print(res.statistic)
1.2139573337497467
>>> print(res.critical_values)
[0.549 0.625 0.75  0.875 1.041]
>>> print(res.significance_level)
[15.  10.   5.   2.5  1. ]

Here, the observed value of the statistic exceeds the critical value
corresponding with a 1% significance level. This tells us that the p-value
of the observed data is less than 1%, but what is it? We could interpolate
from these (already-interpolated) values, but `goodness_of_fit` can
estimate it directly.

>>> res = stats.goodness_of_fit(stats.norm, x, statistic='ad',
...                             rng=rng)
>>> res.statistic, res.pvalue
(1.2139573337497467, 0.0034)

A further advantage is that use of `goodness_of_fit` is not limited to
a particular set of distributions or conditions on which parameters
are known versus which must be estimated from data. Instead,
`goodness_of_fit` can estimate p-values relatively quickly for any
distribution with a sufficiently fast and reliable ``fit`` method. For
instance, here we perform a goodness of fit test using the Cramer-von Mises
statistic against the Rayleigh distribution with known location and unknown
scale.

>>> rng = np.random.default_rng()
>>> x = stats.chi(df=2.2, loc=0, scale=2).rvs(size=1000, random_state=rng)
>>> res = stats.goodness_of_fit(stats.rayleigh, x, statistic='cvm',
...                             known_params={'loc': 0}, rng=rng)

This executes fairly quickly, but to check the reliability of the ``fit``
method, we should inspect the fit result.

>>> res.fit_result  # location is as specified, and scale is reasonable
  params: FitParams(loc=0.0, scale=2.1026719844231243)
 success: True
 message: 'The fit was performed successfully.'
>>> import matplotlib.pyplot as plt  # matplotlib must be installed to plot
>>> res.fit_result.plot()
>>> plt.show()

If the distribution is not fit to the observed data as well as possible,
the test may not control the type I error rate, that is, the chance of
rejecting the null hypothesis even when it is true.

We should also look for extreme outliers in the null distribution that
may be caused by unreliable fitting. These do not necessarily invalidate
the result, but they tend to reduce the test's power.

>>> _, ax = plt.subplots()
>>> ax.hist(np.log10(res.null_distribution))
>>> ax.set_xlabel("log10 of CVM statistic under the null hypothesis")
>>> ax.set_ylabel("Frequency")
>>> ax.set_title("Histogram of the Monte Carlo null distribution")
>>> plt.show()

This plot seems reassuring.

If ``fit`` method is working reliably, and if the distribution of the test
statistic is not particularly sensitive to the values of the fitted
parameters, then the p-value provided by `goodness_of_fit` is expected to
be a good approximation.

>>> res.statistic, res.pvalue
(0.2231991510248692, 0.0525)
================================================================================

gstd:
Firma: (a, axis=0, ddof=1)

Docstring:
Calculate the geometric standard deviation of an array.

The geometric standard deviation describes the spread of a set of numbers
where the geometric mean is preferred. It is a multiplicative factor, and
so a dimensionless quantity.

It is defined as the exponential of the standard deviation of the
natural logarithms of the observations.

Parameters
----------
a : array_like
    An array containing finite, strictly positive, real numbers.

    .. deprecated:: 1.14.0
        Support for masked array input was deprecated in
        SciPy 1.14.0 and will be removed in version 1.16.0.

axis : int, tuple or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degree of freedom correction in the calculation of the
    geometric standard deviation. Default is 1.

Returns
-------
gstd : ndarray or float
    An array of the geometric standard deviation. If `axis` is None or `a`
    is a 1d array a float is returned.

See Also
--------
gmean : Geometric mean
numpy.std : Standard deviation
gzscore : Geometric standard score

Notes
-----
Mathematically, the sample geometric standard deviation :math:`s_G` can be
defined in terms of the natural logarithms of the observations
:math:`y_i = \log(x_i)`:

.. math::

    s_G = \exp(s), \quad s = \sqrt{\frac{1}{n - d} \sum_{i=1}^n (y_i - \bar y)^2}

where :math:`n` is the number of observations, :math:`d` is the adjustment `ddof`
to the degrees of freedom, and :math:`\bar y` denotes the mean of the natural
logarithms of the observations. Note that the default ``ddof=1`` is different from
the default value used by similar functions, such as `numpy.std` and `numpy.var`.

When an observation is infinite, the geometric standard deviation is
NaN (undefined). Non-positive observations will also produce NaNs in the
output because the *natural* logarithm (as opposed to the *complex*
logarithm) is defined and finite only for positive reals.
The geometric standard deviation is sometimes confused with the exponential
of the standard deviation, ``exp(std(a))``. Instead, the geometric standard
deviation is ``exp(std(log(a)))``.

References
----------
.. [1] "Geometric standard deviation", *Wikipedia*,
       https://en.wikipedia.org/wiki/Geometric_standard_deviation.
.. [2] Kirkwood, T. B., "Geometric means and measures of dispersion",
       Biometrics, vol. 35, pp. 908-909, 1979

Examples
--------
Find the geometric standard deviation of a log-normally distributed sample.
Note that the standard deviation of the distribution is one; on a
log scale this evaluates to approximately ``exp(1)``.

>>> import numpy as np
>>> from scipy.stats import gstd
>>> rng = np.random.default_rng()
>>> sample = rng.lognormal(mean=0, sigma=1, size=1000)
>>> gstd(sample)
2.810010162475324

Compute the geometric standard deviation of a multidimensional array and
of a given axis.

>>> a = np.arange(1, 25).reshape(2, 3, 4)
>>> gstd(a, axis=None)
2.2944076136018947
>>> gstd(a, axis=2)
array([[1.82424757, 1.22436866, 1.13183117],
       [1.09348306, 1.07244798, 1.05914985]])
>>> gstd(a, axis=(1,2))
array([2.12939215, 1.22120169])
================================================================================

gumbel_l:
Firma: (*args, **kwds)

Docstring:
A left-skewed Gumbel continuous random variable.

As an instance of the `rv_continuous` class, `gumbel_l` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gumbel_r, gompertz, genextreme

Notes
-----
The probability density function for `gumbel_l` is:

.. math::

    f(x) = \exp(x - e^x)

for real :math:`x`.

The Gumbel distribution is sometimes referred to as a type I Fisher-Tippett
distribution.  It is also related to the extreme value distribution,
log-Weibull and Gompertz distributions.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gumbel_l.pdf(x, loc, scale)`` is identically
equivalent to ``gumbel_l.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gumbel_l
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = gumbel_l.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gumbel_l.ppf(0.01),
...                 gumbel_l.ppf(0.99), 100)
>>> ax.plot(x, gumbel_l.pdf(x),
...        'r-', lw=5, alpha=0.6, label='gumbel_l pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gumbel_l()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gumbel_l.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], gumbel_l.cdf(vals))
True

Generate random numbers:

>>> r = gumbel_l.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gumbel_r:
Firma: (*args, **kwds)

Docstring:
A right-skewed Gumbel continuous random variable.

As an instance of the `rv_continuous` class, `gumbel_r` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gumbel_l, gompertz, genextreme

Notes
-----
The probability density function for `gumbel_r` is:

.. math::

    f(x) = \exp(-(x + e^{-x}))

for real :math:`x`.

The Gumbel distribution is sometimes referred to as a type I Fisher-Tippett
distribution.  It is also related to the extreme value distribution,
log-Weibull and Gompertz distributions.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``gumbel_r.pdf(x, loc, scale)`` is identically
equivalent to ``gumbel_r.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import gumbel_r
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = gumbel_r.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(gumbel_r.ppf(0.01),
...                 gumbel_r.ppf(0.99), 100)
>>> ax.plot(x, gumbel_r.pdf(x),
...        'r-', lw=5, alpha=0.6, label='gumbel_r pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = gumbel_r()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = gumbel_r.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], gumbel_r.cdf(vals))
True

Generate random numbers:

>>> r = gumbel_r.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

gzscore:
Firma: (a, *, axis=0, ddof=0, nan_policy='propagate')

Docstring:
Compute the geometric standard score.

Compute the geometric z score of each strictly positive value in the
sample, relative to the geometric mean and standard deviation.
Mathematically the geometric z score can be evaluated as::

    gzscore = log(a/gmu) / log(gsigma)

where ``gmu`` (resp. ``gsigma``) is the geometric mean (resp. standard
deviation).

Parameters
----------
a : array_like
    Sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.  Note that when the value is 'omit',
    nans in the input also propagate to the output, but they do not affect
    the geometric z scores computed for the non-nan values.

Returns
-------
gzscore : array_like
    The geometric z scores, standardized by geometric mean and geometric
    standard deviation of input array `a`.

See Also
--------
gmean : Geometric mean
gstd : Geometric standard deviation
zscore : Standard score

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses ``asanyarray`` instead of
``asarray`` for parameters).

.. versionadded:: 1.8

References
----------
.. [1] "Geometric standard score", *Wikipedia*,
       https://en.wikipedia.org/wiki/Geometric_standard_deviation#Geometric_standard_score.

Examples
--------
Draw samples from a log-normal distribution:

>>> import numpy as np
>>> from scipy.stats import zscore, gzscore
>>> import matplotlib.pyplot as plt

>>> rng = np.random.default_rng()
>>> mu, sigma = 3., 1.  # mean and standard deviation
>>> x = rng.lognormal(mu, sigma, size=500)

Display the histogram of the samples:

>>> fig, ax = plt.subplots()
>>> ax.hist(x, 50)
>>> plt.show()

Display the histogram of the samples standardized by the classical zscore.
Distribution is rescaled but its shape is unchanged.

>>> fig, ax = plt.subplots()
>>> ax.hist(zscore(x), 50)
>>> plt.show()

Demonstrate that the distribution of geometric zscores is rescaled and
quasinormal:

>>> fig, ax = plt.subplots()
>>> ax.hist(gzscore(x), 50)
>>> plt.show()
================================================================================

halfcauchy:
Firma: (*args, **kwds)

Docstring:
A Half-Cauchy continuous random variable.

As an instance of the `rv_continuous` class, `halfcauchy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `halfcauchy` is:

.. math::

    f(x) = \frac{2}{\pi (1 + x^2)}

for :math:`x \ge 0`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``halfcauchy.pdf(x, loc, scale)`` is identically
equivalent to ``halfcauchy.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import halfcauchy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = halfcauchy.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(halfcauchy.ppf(0.01),
...                 halfcauchy.ppf(0.99), 100)
>>> ax.plot(x, halfcauchy.pdf(x),
...        'r-', lw=5, alpha=0.6, label='halfcauchy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = halfcauchy()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = halfcauchy.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], halfcauchy.cdf(vals))
True

Generate random numbers:

>>> r = halfcauchy.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

halfgennorm:
Firma: (*args, **kwds)

Docstring:
The upper half of a generalized normal continuous random variable.

As an instance of the `rv_continuous` class, `halfgennorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(beta, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, beta, loc=0, scale=1)
    Probability density function.
logpdf(x, beta, loc=0, scale=1)
    Log of the probability density function.
cdf(x, beta, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, beta, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, beta, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, beta, loc=0, scale=1)
    Log of the survival function.
ppf(q, beta, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, beta, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, beta, loc=0, scale=1)
    Non-central moment of the specified order.
stats(beta, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(beta, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(beta,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(beta, loc=0, scale=1)
    Median of the distribution.
mean(beta, loc=0, scale=1)
    Mean of the distribution.
var(beta, loc=0, scale=1)
    Variance of the distribution.
std(beta, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, beta, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
gennorm : generalized normal distribution
expon : exponential distribution
halfnorm : half normal distribution

Notes
-----
The probability density function for `halfgennorm` is:

.. math::

    f(x, \beta) = \frac{\beta}{\Gamma(1/\beta)} \exp(-|x|^\beta)

for :math:`x, \beta > 0`. :math:`\Gamma` is the gamma function
(`scipy.special.gamma`).

`halfgennorm` takes ``beta`` as a shape parameter for :math:`\beta`.
For :math:`\beta = 1`, it is identical to an exponential distribution.
For :math:`\beta = 2`, it is identical to a half normal distribution
(with ``scale=1/sqrt(2)``).

References
----------

.. [1] "Generalized normal distribution, Version 1",
       https://en.wikipedia.org/wiki/Generalized_normal_distribution#Version_1

Examples
--------
>>> import numpy as np
>>> from scipy.stats import halfgennorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> beta = 0.675
>>> mean, var, skew, kurt = halfgennorm.stats(beta, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(halfgennorm.ppf(0.01, beta),
...                 halfgennorm.ppf(0.99, beta), 100)
>>> ax.plot(x, halfgennorm.pdf(x, beta),
...        'r-', lw=5, alpha=0.6, label='halfgennorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = halfgennorm(beta)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = halfgennorm.ppf([0.001, 0.5, 0.999], beta)
>>> np.allclose([0.001, 0.5, 0.999], halfgennorm.cdf(vals, beta))
True

Generate random numbers:

>>> r = halfgennorm.rvs(beta, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

halflogistic:
Firma: (*args, **kwds)

Docstring:
A half-logistic continuous random variable.

As an instance of the `rv_continuous` class, `halflogistic` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `halflogistic` is:

.. math::

    f(x) = \frac{ 2 e^{-x} }{ (1+e^{-x})^2 }
         = \frac{1}{2} \text{sech}(x/2)^2

for :math:`x \ge 0`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``halflogistic.pdf(x, loc, scale)`` is identically
equivalent to ``halflogistic.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Asgharzadeh et al (2011). "Comparisons of Methods of Estimation for the
       Half-Logistic Distribution". Selcuk J. Appl. Math. 93-108.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import halflogistic
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = halflogistic.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(halflogistic.ppf(0.01),
...                 halflogistic.ppf(0.99), 100)
>>> ax.plot(x, halflogistic.pdf(x),
...        'r-', lw=5, alpha=0.6, label='halflogistic pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = halflogistic()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = halflogistic.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], halflogistic.cdf(vals))
True

Generate random numbers:

>>> r = halflogistic.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

halfnorm:
Firma: (*args, **kwds)

Docstring:
A half-normal continuous random variable.

As an instance of the `rv_continuous` class, `halfnorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `halfnorm` is:

.. math::

    f(x) = \sqrt{2/\pi} \exp(-x^2 / 2)

for :math:`x >= 0`.

`halfnorm` is a special case of `chi` with ``df=1``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``halfnorm.pdf(x, loc, scale)`` is identically
equivalent to ``halfnorm.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import halfnorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = halfnorm.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(halfnorm.ppf(0.01),
...                 halfnorm.ppf(0.99), 100)
>>> ax.plot(x, halfnorm.pdf(x),
...        'r-', lw=5, alpha=0.6, label='halfnorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = halfnorm()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = halfnorm.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], halfnorm.cdf(vals))
True

Generate random numbers:

>>> r = halfnorm.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

hmean:
Firma: (a, axis=0, dtype=None, *, weights=None, nan_policy='propagate', keepdims=False)

Docstring:
Calculate the weighted harmonic mean along the specified axis.

The weighted harmonic mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

    \frac{ \sum_{i=1}^n w_i }{ \sum_{i=1}^n \frac{w_i}{a_i} } \, ,

and, with equal weights, it gives:

.. math::

    \frac{ n }{ \sum_{i=1}^n \frac{1}{a_i} } \, .

Parameters
----------
a : array_like
    Input array, masked array or object that can be converted to an array.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If `dtype` is not specified, it defaults to the
    dtype of `a`, unless `a` has an integer `dtype` with a precision less
    than that of the default platform integer. In that case, the default
    platform integer is used.
weights : array_like, optional
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given `axis`) or of the same shape as `a`.
    Default is None, which gives each value a weight of 1.0.
    
    .. versionadded:: 1.9
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
hmean : ndarray
    See `dtype` parameter above.

See Also
--------

:func:`numpy.mean`
    Arithmetic average
:func:`numpy.average`
    Weighted average
:func:`gmean`
    Geometric mean


Notes
-----
The sample harmonic mean is the reciprocal of the mean of the reciprocals
of the observations.

The harmonic mean is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

The harmonic mean is only defined if all observations are non-negative;
otherwise, the result is NaN.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] "Weighted Harmonic Mean", *Wikipedia*,
       https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean
.. [2] Ferger, F., "The nature and use of the harmonic mean", Journal of
       the American Statistical Association, vol. 26, pp. 36-40, 1931

Examples
--------
>>> from scipy.stats import hmean
>>> hmean([1, 4])
1.6000000000000001
>>> hmean([1, 2, 3, 4, 5, 6, 7])
2.6997245179063363
>>> hmean([1, 4, 7], weights=[3, 1, 3])
1.9029126213592233
================================================================================

hypergeom:
Firma: (*args, **kwds)

Docstring:
A hypergeometric discrete random variable.

The hypergeometric distribution models drawing objects from a bin.
`M` is the total number of objects, `n` is total number of Type I objects.
The random variate represents the number of Type I objects in `N` drawn
without replacement from the total population.

As an instance of the `rv_discrete` class, `hypergeom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(M, n, N, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, M, n, N, loc=0)
    Probability mass function.
logpmf(k, M, n, N, loc=0)
    Log of the probability mass function.
cdf(k, M, n, N, loc=0)
    Cumulative distribution function.
logcdf(k, M, n, N, loc=0)
    Log of the cumulative distribution function.
sf(k, M, n, N, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, M, n, N, loc=0)
    Log of the survival function.
ppf(q, M, n, N, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, M, n, N, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(M, n, N, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(M, n, N, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(M, n, N), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(M, n, N, loc=0)
    Median of the distribution.
mean(M, n, N, loc=0)
    Mean of the distribution.
var(M, n, N, loc=0)
    Variance of the distribution.
std(M, n, N, loc=0)
    Standard deviation of the distribution.
interval(confidence, M, n, N, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The symbols used to denote the shape parameters (`M`, `n`, and `N`) are not
universally accepted.  See the Examples for a clarification of the
definitions used here.

The probability mass function is defined as,

.. math:: p(k, M, n, N) = \frac{\binom{n}{k} \binom{M - n}{N - k}}
                               {\binom{M}{N}}

for :math:`k \in [\max(0, N - M + n), \min(n, N)]`, where the binomial
coefficients are defined as,

.. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pmf``, ``cdf``, ``sf`` and ``stats`` methods. [1]_

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``hypergeom.pmf(k, M, n, N, loc)`` is identically
equivalent to ``hypergeom.pmf(k - loc, M, n, N)``.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import hypergeom
>>> import matplotlib.pyplot as plt

Suppose we have a collection of 20 animals, of which 7 are dogs.  Then if
we want to know the probability of finding a given number of dogs if we
choose at random 12 of the 20 animals, we can initialize a frozen
distribution and plot the probability mass function:

>>> [M, n, N] = [20, 7, 12]
>>> rv = hypergeom(M, n, N)
>>> x = np.arange(0, n+1)
>>> pmf_dogs = rv.pmf(x)

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(x, pmf_dogs, 'bo')
>>> ax.vlines(x, 0, pmf_dogs, lw=2)
>>> ax.set_xlabel('# of dogs in our group of chosen animals')
>>> ax.set_ylabel('hypergeom PMF')
>>> plt.show()

Instead of using a frozen distribution we can also use `hypergeom`
methods directly.  To for example obtain the cumulative distribution
function, use:

>>> prb = hypergeom.cdf(x, M, n, N)

And to generate random numbers:

>>> R = hypergeom.rvs(M, n, N, size=10)

See Also
--------
nhypergeom, binom, nbinom
================================================================================

hypsecant:
Firma: (*args, **kwds)

Docstring:
A hyperbolic secant continuous random variable.

As an instance of the `rv_continuous` class, `hypsecant` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `hypsecant` is:

.. math::

    f(x) = \frac{1}{\pi} \text{sech}(x)

for a real number :math:`x`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``hypsecant.pdf(x, loc, scale)`` is identically
equivalent to ``hypsecant.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import hypsecant
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = hypsecant.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(hypsecant.ppf(0.01),
...                 hypsecant.ppf(0.99), 100)
>>> ax.plot(x, hypsecant.pdf(x),
...        'r-', lw=5, alpha=0.6, label='hypsecant pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = hypsecant()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = hypsecant.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], hypsecant.cdf(vals))
True

Generate random numbers:

>>> r = hypsecant.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

invgamma:
Firma: (*args, **kwds)

Docstring:
An inverted gamma continuous random variable.

As an instance of the `rv_continuous` class, `invgamma` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `invgamma` is:

.. math::

    f(x, a) = \frac{x^{-a-1}}{\Gamma(a)} \exp(-\frac{1}{x})

for :math:`x >= 0`, :math:`a > 0`. :math:`\Gamma` is the gamma function
(`scipy.special.gamma`).

`invgamma` takes ``a`` as a shape parameter for :math:`a`.

`invgamma` is a special case of `gengamma` with ``c=-1``, and it is a
different parameterization of the scaled inverse chi-squared distribution.
Specifically, if the scaled inverse chi-squared distribution is
parameterized with degrees of freedom :math:`\nu` and scaling parameter
:math:`\tau^2`, then it can be modeled using `invgamma` with
``a=`` :math:`\nu/2` and ``scale=`` :math:`\nu \tau^2/2`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``invgamma.pdf(x, a, loc, scale)`` is identically
equivalent to ``invgamma.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import invgamma
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 4.07
>>> mean, var, skew, kurt = invgamma.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(invgamma.ppf(0.01, a),
...                 invgamma.ppf(0.99, a), 100)
>>> ax.plot(x, invgamma.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='invgamma pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = invgamma(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = invgamma.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], invgamma.cdf(vals, a))
True

Generate random numbers:

>>> r = invgamma.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

invgauss:
Firma: (*args, **kwds)

Docstring:
An inverse Gaussian continuous random variable.

As an instance of the `rv_continuous` class, `invgauss` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(mu, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, mu, loc=0, scale=1)
    Probability density function.
logpdf(x, mu, loc=0, scale=1)
    Log of the probability density function.
cdf(x, mu, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, mu, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, mu, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, mu, loc=0, scale=1)
    Log of the survival function.
ppf(q, mu, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, mu, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, mu, loc=0, scale=1)
    Non-central moment of the specified order.
stats(mu, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(mu, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(mu,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(mu, loc=0, scale=1)
    Median of the distribution.
mean(mu, loc=0, scale=1)
    Mean of the distribution.
var(mu, loc=0, scale=1)
    Variance of the distribution.
std(mu, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, mu, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `invgauss` is:

.. math::

    f(x; \mu) = \frac{1}{\sqrt{2 \pi x^3}}
                \exp\left(-\frac{(x-\mu)^2}{2 \mu^2 x}\right)

for :math:`x \ge 0` and :math:`\mu > 0`.

`invgauss` takes ``mu`` as a shape parameter for :math:`\mu`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``invgauss.pdf(x, mu, loc, scale)`` is identically
equivalent to ``invgauss.pdf(y, mu) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

A common shape-scale parameterization of the inverse Gaussian distribution
has density

.. math::

    f(x; \nu, \lambda) = \sqrt{\frac{\lambda}{2 \pi x^3}}
                \exp\left( -\frac{\lambda(x-\nu)^2}{2 \nu^2 x}\right)

Using ``nu`` for :math:`\nu` and ``lam`` for :math:`\lambda`, this
parameterization is equivalent to the one above with ``mu = nu/lam``,
``loc = 0``, and ``scale = lam``.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``ppf`` and ``isf`` methods. [1]_

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import invgauss
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mu = 0.145
>>> mean, var, skew, kurt = invgauss.stats(mu, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(invgauss.ppf(0.01, mu),
...                 invgauss.ppf(0.99, mu), 100)
>>> ax.plot(x, invgauss.pdf(x, mu),
...        'r-', lw=5, alpha=0.6, label='invgauss pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = invgauss(mu)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = invgauss.ppf([0.001, 0.5, 0.999], mu)
>>> np.allclose([0.001, 0.5, 0.999], invgauss.cdf(vals, mu))
True

Generate random numbers:

>>> r = invgauss.rvs(mu, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

invweibull:
Firma: (*args, **kwds)

Docstring:
An inverted Weibull continuous random variable.

This distribution is also known as the Fréchet distribution or the
type II extreme value distribution.

As an instance of the `rv_continuous` class, `invweibull` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `invweibull` is:

.. math::

    f(x, c) = c x^{-c-1} \exp(-x^{-c})

for :math:`x > 0`, :math:`c > 0`.

`invweibull` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``invweibull.pdf(x, c, loc, scale)`` is identically
equivalent to ``invweibull.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
F.R.S. de Gusmao, E.M.M Ortega and G.M. Cordeiro, "The generalized inverse
Weibull distribution", Stat. Papers, vol. 52, pp. 591-619, 2011.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import invweibull
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 10.6
>>> mean, var, skew, kurt = invweibull.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(invweibull.ppf(0.01, c),
...                 invweibull.ppf(0.99, c), 100)
>>> ax.plot(x, invweibull.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='invweibull pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = invweibull(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = invweibull.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], invweibull.cdf(vals, c))
True

Generate random numbers:

>>> r = invweibull.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

invwishart:
Firma: (df=None, scale=None, seed=None)

Docstring:
An inverse Wishart random variable.

The `df` keyword specifies the degrees of freedom. The `scale` keyword
specifies the scale matrix, which must be symmetric and positive definite.
In this context, the scale matrix is often interpreted in terms of a
multivariate normal covariance matrix.

Methods
-------
pdf(x, df, scale)
    Probability density function.
logpdf(x, df, scale)
    Log of the probability density function.
rvs(df, scale, size=1, random_state=None)
    Draw random samples from an inverse Wishart distribution.
entropy(df, scale)
    Differential entropy of the distribution.

Parameters
----------
df : int
    Degrees of freedom, must be greater than or equal to dimension of the
    scale matrix
scale : array_like
    Symmetric positive definite scale matrix of the distribution
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Raises
------
scipy.linalg.LinAlgError
    If the scale matrix `scale` is not positive definite.

See Also
--------
wishart

Notes
-----


The scale matrix `scale` must be a symmetric positive definite
matrix. Singular matrices, including the symmetric positive semi-definite
case, are not supported. Symmetry is not checked; only the lower triangular
portion is used.

The inverse Wishart distribution is often denoted

.. math::

    W_p^{-1}(\nu, \Psi)

where :math:`\nu` is the degrees of freedom and :math:`\Psi` is the
:math:`p \times p` scale matrix.

The probability density function for `invwishart` has support over positive
definite matrices :math:`S`; if :math:`S \sim W^{-1}_p(\nu, \Sigma)`,
then its PDF is given by:

.. math::

    f(S) = \frac{|\Sigma|^\frac{\nu}{2}}{2^{ \frac{\nu p}{2} }
           |S|^{\frac{\nu + p + 1}{2}} \Gamma_p \left(\frac{\nu}{2} \right)}
           \exp\left( -tr(\Sigma S^{-1}) / 2 \right)

If :math:`S \sim W_p^{-1}(\nu, \Psi)` (inverse Wishart) then
:math:`S^{-1} \sim W_p(\nu, \Psi^{-1})` (Wishart).

If the scale matrix is 1-dimensional and equal to one, then the inverse
Wishart distribution :math:`W_1(\nu, 1)` collapses to the
inverse Gamma distribution with parameters shape = :math:`\frac{\nu}{2}`
and scale = :math:`\frac{1}{2}`.

Instead of inverting a randomly generated Wishart matrix as described in [2],
here the algorithm in [4] is used to directly generate a random inverse-Wishart
matrix without inversion.

.. versionadded:: 0.16.0

References
----------
.. [1] M.L. Eaton, "Multivariate Statistics: A Vector Space Approach",
       Wiley, 1983.
.. [2] M.C. Jones, "Generating Inverse Wishart Matrices", Communications
       in Statistics - Simulation and Computation, vol. 14.2, pp.511-514,
       1985.
.. [3] Gupta, M. and Srivastava, S. "Parametric Bayesian Estimation of
       Differential Entropy and Relative Entropy". Entropy 12, 818 - 843.
       2010.
.. [4] S.D. Axen, "Efficiently generating inverse-Wishart matrices and
       their Cholesky factors", :arXiv:`2310.15884v1`. 2023.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import invwishart, invgamma
>>> x = np.linspace(0.01, 1, 100)
>>> iw = invwishart.pdf(x, df=6, scale=1)
>>> iw[:3]
array([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])
>>> ig = invgamma.pdf(x, 6/2., scale=1./2)
>>> ig[:3]
array([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])
>>> plt.plot(x, iw)
>>> plt.show()

The input quantiles can be any shape of array, as long as the last
axis labels the components.

Alternatively, the object may be called (as a function) to fix the degrees
of freedom and scale parameters, returning a "frozen" inverse Wishart
random variable:

>>> rv = invwishart(df=1, scale=1)
>>> # Frozen object with the same methods but holding the given
>>> # degrees of freedom and scale fixed.
================================================================================

iqr:
Firma: (x, axis=None, rng=(25, 75), scale=1.0, nan_policy='propagate', interpolation='linear', keepdims=False)

Docstring:
Compute the interquartile range of the data along the specified axis.

The interquartile range (IQR) is the difference between the 75th and
25th percentile of the data. It is a measure of the dispersion
similar to standard deviation or variance, but is much more robust
against outliers [2]_.

The ``rng`` parameter allows this function to compute other
percentile ranges than the actual IQR. For example, setting
``rng=(0, 100)`` is equivalent to `numpy.ptp`.

The IQR of an empty array is `np.nan`.

.. versionadded:: 0.18.0

Parameters
----------
x : array_like
    Input array or object that can be converted to an array.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
rng : Two-element sequence containing floats in range of [0,100] optional
    Percentiles over which to compute the range. Each must be
    between 0 and 100, inclusive. The default is the true IQR:
    ``(25, 75)``. The order of the elements is not important.
scale : scalar or str or array_like of reals, optional
    The numerical value of scale will be divided out of the final
    result. The following string value is also recognized:
    
      * 'normal' : Scale by
        :math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`.
    
    The default is 1.0.
    Array-like `scale` of real dtype is also allowed, as long
    as it broadcasts correctly to the output such that
    ``out / scale`` is a valid operation. The output dimensions
    depend on the input array, `x`, the `axis` argument, and the
    `keepdims` flag.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
interpolation : str, optional
    Specifies the interpolation method to use when the percentile
    boundaries lie between two data points ``i`` and ``j``.
    The following options are available (default is 'linear'):
    
      * 'linear': ``i + (j - i)*fraction``, where ``fraction`` is the
        fractional part of the index surrounded by ``i`` and ``j``.
      * 'lower': ``i``.
      * 'higher': ``j``.
      * 'nearest': ``i`` or ``j`` whichever is nearest.
      * 'midpoint': ``(i + j)/2``.
    
    For NumPy >= 1.22.0, the additional options provided by the ``method``
    keyword of `numpy.percentile` are also valid.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
iqr : scalar or ndarray
    If ``axis=None``, a scalar is returned. If the input contains
    integers or floats of smaller precision than ``np.float64``, then the
    output data-type is ``np.float64``. Otherwise, the output data-type is
    the same as that of the input.

See Also
--------

:func:`numpy.std`, :func:`numpy.var`
    ..

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] "Interquartile range" https://en.wikipedia.org/wiki/Interquartile_range
.. [2] "Robust measures of scale" https://en.wikipedia.org/wiki/Robust_measures_of_scale
.. [3] "Quantile" https://en.wikipedia.org/wiki/Quantile

Examples
--------
>>> import numpy as np
>>> from scipy.stats import iqr
>>> x = np.array([[10, 7, 4], [3, 2, 1]])
>>> x
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> iqr(x)
4.0
>>> iqr(x, axis=0)
array([ 3.5,  2.5,  1.5])
>>> iqr(x, axis=1)
array([ 3.,  1.])
>>> iqr(x, axis=1, keepdims=True)
array([[ 3.],
       [ 1.]])
================================================================================

irwinhall:
Firma: (*args, **kwds)

Docstring:
An Irwin-Hall (Uniform Sum) continuous random variable.

An `Irwin-Hall <https://en.wikipedia.org/wiki/Irwin-Hall_distribution/>`_
continuous random variable is the sum of :math:`n` independent
standard uniform random variables [1]_ [2]_.

As an instance of the `rv_continuous` class, `irwinhall` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, n, loc=0, scale=1)
    Probability density function.
logpdf(x, n, loc=0, scale=1)
    Log of the probability density function.
cdf(x, n, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, n, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, n, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, n, loc=0, scale=1)
    Log of the survival function.
ppf(q, n, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, n, loc=0, scale=1)
    Non-central moment of the specified order.
stats(n, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(n,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, loc=0, scale=1)
    Median of the distribution.
mean(n, loc=0, scale=1)
    Mean of the distribution.
var(n, loc=0, scale=1)
    Variance of the distribution.
std(n, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, n, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
Applications include `Rao's Spacing Test
<https://jammalam.faculty.pstat.ucsb.edu/html/favorite/test.htm>`_,
a more powerful alternative to the Rayleigh test
when the data are not unimodal, and radar [3]_.

Conveniently, the pdf and cdf are the :math:`n`-fold convolution of
the ones for the standard uniform distribution, which is also the
definition of the cardinal B-splines of degree :math:`n-1`
having knots evenly spaced from :math:`1` to :math:`n` [4]_ [5]_.

The Bates distribution, which represents the *mean* of statistically
independent, uniformly distributed random variables, is simply the
Irwin-Hall distribution scaled by :math:`1/n`. For example, the frozen
distribution ``bates = irwinhall(10, scale=1/10)`` represents the
distribution of the mean of 10 uniformly distributed random variables.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``irwinhall.pdf(x, n, loc, scale)`` is identically
equivalent to ``irwinhall.pdf(y, n) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] P. Hall, "The distribution of means for samples of size N drawn
        from a population in which the variate takes values between 0 and 1,
        all such values being equally probable",
        Biometrika, Volume 19, Issue 3-4, December 1927, Pages 240-244,
        :doi:`10.1093/biomet/19.3-4.240`.
.. [2] J. O. Irwin, "On the frequency distribution of the means of samples
        from a population having any law of frequency with finite moments,
        with special reference to Pearson's Type II,
        Biometrika, Volume 19, Issue 3-4, December 1927, Pages 225-239,
        :doi:`0.1093/biomet/19.3-4.225`.
.. [3] K. Buchanan, T. Adeyemi, C. Flores-Molina, S. Wheeland and D. Overturf, 
        "Sidelobe behavior and bandwidth characteristics
        of distributed antenna arrays,"
        2018 United States National Committee of
        URSI National Radio Science Meeting (USNC-URSI NRSM),
        Boulder, CO, USA, 2018, pp. 1-2.
        https://www.usnc-ursi-archive.org/nrsm/2018/papers/B15-9.pdf.
.. [4] Amos Ron, "Lecture 1: Cardinal B-splines and convolution operators", p. 1
        https://pages.cs.wisc.edu/~deboor/887/lec1new.pdf.
.. [5] Trefethen, N. (2012, July). B-splines and convolution. Chebfun. 
        Retrieved April 30, 2024, from http://www.chebfun.org/examples/approx/BSplineConv.html.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import irwinhall
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> n = 10
>>> mean, var, skew, kurt = irwinhall.stats(n, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(irwinhall.ppf(0.01, n),
...                 irwinhall.ppf(0.99, n), 100)
>>> ax.plot(x, irwinhall.pdf(x, n),
...        'r-', lw=5, alpha=0.6, label='irwinhall pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = irwinhall(n)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = irwinhall.ppf([0.001, 0.5, 0.999], n)
>>> np.allclose([0.001, 0.5, 0.999], irwinhall.cdf(vals, n))
True

Generate random numbers:

>>> r = irwinhall.rvs(n, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

jarque_bera:
Firma: (x, *, axis=None, nan_policy='propagate', keepdims=False)

Docstring:
Perform the Jarque-Bera goodness of fit test on sample data.

The Jarque-Bera test tests whether the sample data has the skewness and
kurtosis matching a normal distribution.

Note that this test only works for a large enough number of data samples
(>2000) as the test statistic asymptotically has a Chi-squared distribution
with 2 degrees of freedom.

Parameters
----------
x : array_like
    Observations of a random variable.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
result : SignificanceResult
    An object with the following attributes:
    
    statistic : float
        The test statistic.
    pvalue : float
        The p-value for the hypothesis test.

See Also
--------

:ref:`hypothesis_jarque_bera`
    Extended example


Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Jarque, C. and Bera, A. (1980) "Efficient tests for normality,
       homoscedasticity and serial independence of regression residuals",
       6 Econometric Letters 255-259.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = rng.normal(0, 1, 100000)
>>> jarque_bera_test = stats.jarque_bera(x)
>>> jarque_bera_test
Jarque_beraResult(statistic=3.3415184718131554, pvalue=0.18810419594996775)
>>> jarque_bera_test.statistic
3.3415184718131554
>>> jarque_bera_test.pvalue
0.18810419594996775

For a more detailed example, see :ref:`hypothesis_jarque_bera`.
================================================================================

jf_skew_t:
Firma: (*args, **kwds)

Docstring:
Jones and Faddy skew-t distribution.

As an instance of the `rv_continuous` class, `jf_skew_t` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `jf_skew_t` is:

.. math::

    f(x; a, b) = C_{a,b}^{-1}
                \left(1+\frac{x}{\left(a+b+x^2\right)^{1/2}}\right)^{a+1/2}
                \left(1-\frac{x}{\left(a+b+x^2\right)^{1/2}}\right)^{b+1/2}

for real numbers :math:`a>0` and :math:`b>0`, where
:math:`C_{a,b} = 2^{a+b-1}B(a,b)(a+b)^{1/2}`, and :math:`B` denotes the
beta function (`scipy.special.beta`).

When :math:`a<b`, the distribution is negatively skewed, and when
:math:`a>b`, the distribution is positively skewed. If :math:`a=b`, then
we recover the `t` distribution with :math:`2a` degrees of freedom.

`jf_skew_t` takes :math:`a` and :math:`b` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``jf_skew_t.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``jf_skew_t.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] M.C. Jones and M.J. Faddy. "A skew extension of the t distribution,
       with applications" *Journal of the Royal Statistical Society*.
       Series B (Statistical Methodology) 65, no. 1 (2003): 159-174.
       :doi:`10.1111/1467-9868.00378`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import jf_skew_t
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 8, 4
>>> mean, var, skew, kurt = jf_skew_t.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(jf_skew_t.ppf(0.01, a, b),
...                 jf_skew_t.ppf(0.99, a, b), 100)
>>> ax.plot(x, jf_skew_t.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='jf_skew_t pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = jf_skew_t(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = jf_skew_t.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], jf_skew_t.cdf(vals, a, b))
True

Generate random numbers:

>>> r = jf_skew_t.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

johnsonsb:
Firma: (*args, **kwds)

Docstring:
A Johnson SB continuous random variable.

As an instance of the `rv_continuous` class, `johnsonsb` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
johnsonsu

Notes
-----
The probability density function for `johnsonsb` is:

.. math::

    f(x, a, b) = \frac{b}{x(1-x)}  \phi(a + b \log \frac{x}{1-x} )

where :math:`x`, :math:`a`, and :math:`b` are real scalars; :math:`b > 0`
and :math:`x \in [0,1]`.  :math:`\phi` is the pdf of the normal
distribution.

`johnsonsb` takes :math:`a` and :math:`b` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``johnsonsb.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``johnsonsb.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import johnsonsb
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 4.32, 3.18
>>> mean, var, skew, kurt = johnsonsb.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(johnsonsb.ppf(0.01, a, b),
...                 johnsonsb.ppf(0.99, a, b), 100)
>>> ax.plot(x, johnsonsb.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='johnsonsb pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = johnsonsb(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = johnsonsb.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], johnsonsb.cdf(vals, a, b))
True

Generate random numbers:

>>> r = johnsonsb.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

johnsonsu:
Firma: (*args, **kwds)

Docstring:
A Johnson SU continuous random variable.

As an instance of the `rv_continuous` class, `johnsonsu` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
johnsonsb

Notes
-----
The probability density function for `johnsonsu` is:

.. math::

    f(x, a, b) = \frac{b}{\sqrt{x^2 + 1}}
                 \phi(a + b \log(x + \sqrt{x^2 + 1}))

where :math:`x`, :math:`a`, and :math:`b` are real scalars; :math:`b > 0`.
:math:`\phi` is the pdf of the normal distribution.

`johnsonsu` takes :math:`a` and :math:`b` as shape parameters.

The first four central moments are calculated according to the formulas
in [1]_.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``johnsonsu.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``johnsonsu.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Taylor Enterprises. "Johnson Family of Distributions".
   https://variation.com/wp-content/distribution_analyzer_help/hs126.htm

Examples
--------
>>> import numpy as np
>>> from scipy.stats import johnsonsu
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 2.55, 2.25
>>> mean, var, skew, kurt = johnsonsu.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(johnsonsu.ppf(0.01, a, b),
...                 johnsonsu.ppf(0.99, a, b), 100)
>>> ax.plot(x, johnsonsu.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='johnsonsu pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = johnsonsu(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = johnsonsu.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], johnsonsu.cdf(vals, a, b))
True

Generate random numbers:

>>> r = johnsonsu.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

kappa3:
Firma: (*args, **kwds)

Docstring:
Kappa 3 parameter distribution.

As an instance of the `rv_continuous` class, `kappa3` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `kappa3` is:

.. math::

    f(x, a) = a (a + x^a)^{-(a + 1)/a}

for :math:`x > 0` and :math:`a > 0`.

`kappa3` takes ``a`` as a shape parameter for :math:`a`.

References
----------
P.W. Mielke and E.S. Johnson, "Three-Parameter Kappa Distribution Maximum
Likelihood and Likelihood Ratio Tests", Methods in Weather Research,
701-707, (September, 1973),
:doi:`10.1175/1520-0493(1973)101<0701:TKDMLE>2.3.CO;2`

B. Kumphon, "Maximum Entropy and Maximum Likelihood Estimation for the
Three-Parameter Kappa Distribution", Open Journal of Statistics, vol 2,
415-419 (2012), :doi:`10.4236/ojs.2012.24050`

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``kappa3.pdf(x, a, loc, scale)`` is identically
equivalent to ``kappa3.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import kappa3
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 1
>>> mean, var, skew, kurt = kappa3.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(kappa3.ppf(0.01, a),
...                 kappa3.ppf(0.99, a), 100)
>>> ax.plot(x, kappa3.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='kappa3 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = kappa3(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = kappa3.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], kappa3.cdf(vals, a))
True

Generate random numbers:

>>> r = kappa3.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

kappa4:
Firma: (*args, **kwds)

Docstring:
Kappa 4 parameter distribution.

As an instance of the `rv_continuous` class, `kappa4` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(h, k, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, h, k, loc=0, scale=1)
    Probability density function.
logpdf(x, h, k, loc=0, scale=1)
    Log of the probability density function.
cdf(x, h, k, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, h, k, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, h, k, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, h, k, loc=0, scale=1)
    Log of the survival function.
ppf(q, h, k, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, h, k, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, h, k, loc=0, scale=1)
    Non-central moment of the specified order.
stats(h, k, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(h, k, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(h, k), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(h, k, loc=0, scale=1)
    Median of the distribution.
mean(h, k, loc=0, scale=1)
    Mean of the distribution.
var(h, k, loc=0, scale=1)
    Variance of the distribution.
std(h, k, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, h, k, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for kappa4 is:

.. math::

    f(x, h, k) = (1 - k x)^{1/k - 1} (1 - h (1 - k x)^{1/k})^{1/h-1}

if :math:`h` and :math:`k` are not equal to 0.

If :math:`h` or :math:`k` are zero then the pdf can be simplified:

h = 0 and k != 0::

    kappa4.pdf(x, h, k) = (1.0 - k*x)**(1.0/k - 1.0)*
                          exp(-(1.0 - k*x)**(1.0/k))

h != 0 and k = 0::

    kappa4.pdf(x, h, k) = exp(-x)*(1.0 - h*exp(-x))**(1.0/h - 1.0)

h = 0 and k = 0::

    kappa4.pdf(x, h, k) = exp(-x)*exp(-exp(-x))

kappa4 takes :math:`h` and :math:`k` as shape parameters.

The kappa4 distribution returns other distributions when certain
:math:`h` and :math:`k` values are used.

+------+-------------+----------------+------------------+
| h    | k=0.0       | k=1.0          | -inf<=k<=inf     |
+======+=============+================+==================+
| -1.0 | Logistic    |                | Generalized      |
|      |             |                | Logistic(1)      |
|      |             |                |                  |
|      | logistic(x) |                |                  |
+------+-------------+----------------+------------------+
|  0.0 | Gumbel      | Reverse        | Generalized      |
|      |             | Exponential(2) | Extreme Value    |
|      |             |                |                  |
|      | gumbel_r(x) |                | genextreme(x, k) |
+------+-------------+----------------+------------------+
|  1.0 | Exponential | Uniform        | Generalized      |
|      |             |                | Pareto           |
|      |             |                |                  |
|      | expon(x)    | uniform(x)     | genpareto(x, -k) |
+------+-------------+----------------+------------------+

(1) There are at least five generalized logistic distributions.
    Four are described here:
    https://en.wikipedia.org/wiki/Generalized_logistic_distribution
    The "fifth" one is the one kappa4 should match which currently
    isn't implemented in scipy:
    https://en.wikipedia.org/wiki/Talk:Generalized_logistic_distribution
    https://www.mathwave.com/help/easyfit/html/analyses/distributions/gen_logistic.html
(2) This distribution is currently not in scipy.

References
----------
J.C. Finney, "Optimization of a Skewed Logistic Distribution With Respect
to the Kolmogorov-Smirnov Test", A Dissertation Submitted to the Graduate
Faculty of the Louisiana State University and Agricultural and Mechanical
College, (August, 2004),
https://digitalcommons.lsu.edu/gradschool_dissertations/3672

J.R.M. Hosking, "The four-parameter kappa distribution". IBM J. Res.
Develop. 38 (3), 25 1-258 (1994).

B. Kumphon, A. Kaew-Man, P. Seenoi, "A Rainfall Distribution for the Lampao
Site in the Chi River Basin, Thailand", Journal of Water Resource and
Protection, vol. 4, 866-869, (2012).
:doi:`10.4236/jwarp.2012.410101`

C. Winchester, "On Estimation of the Four-Parameter Kappa Distribution", A
Thesis Submitted to Dalhousie University, Halifax, Nova Scotia, (March
2000).
http://www.nlc-bnc.ca/obj/s4/f2/dsk2/ftp01/MQ57336.pdf

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``kappa4.pdf(x, h, k, loc, scale)`` is identically
equivalent to ``kappa4.pdf(y, h, k) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import kappa4
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> h, k = 0.1, 0
>>> mean, var, skew, kurt = kappa4.stats(h, k, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(kappa4.ppf(0.01, h, k),
...                 kappa4.ppf(0.99, h, k), 100)
>>> ax.plot(x, kappa4.pdf(x, h, k),
...        'r-', lw=5, alpha=0.6, label='kappa4 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = kappa4(h, k)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = kappa4.ppf([0.001, 0.5, 0.999], h, k)
>>> np.allclose([0.001, 0.5, 0.999], kappa4.cdf(vals, h, k))
True

Generate random numbers:

>>> r = kappa4.rvs(h, k, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

kendalltau:
Firma: (x, y, *, nan_policy='propagate', method='auto', variant='b', alternative='two-sided')

Docstring:
Calculate Kendall's tau, a correlation measure for ordinal data.

Kendall's tau is a measure of the correspondence between two rankings.
Values close to 1 indicate strong agreement, and values close to -1
indicate strong disagreement. This implements two variants of Kendall's
tau: tau-b (the default) and tau-c (also known as Stuart's tau-c). These
differ only in how they are normalized to lie within the range -1 to 1;
the hypothesis tests (their p-values) are identical. Kendall's original
tau-a is not implemented separately because both tau-b and tau-c reduce
to tau-a in the absence of ties.

Parameters
----------
x, y : array_like
    Arrays of rankings, of the same shape. If arrays are not 1-D, they
    will be flattened to 1-D.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

method : {'auto', 'asymptotic', 'exact'}, optional
    Defines which method is used to calculate the p-value [5]_.
    The following options are available (default is 'auto'):

    * 'auto': selects the appropriate method based on a trade-off
      between speed and accuracy
    * 'asymptotic': uses a normal approximation valid for large samples
    * 'exact': computes the exact p-value, but can only be used if no ties
      are present. As the sample size increases, the 'exact' computation
      time may grow and the result may lose some precision.

variant : {'b', 'c'}, optional
    Defines which variant of Kendall's tau is returned. Default is 'b'.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the rank correlation is nonzero
    * 'less': the rank correlation is negative (less than zero)
    * 'greater': the rank correlation is positive (greater than zero)

Returns
-------
res : SignificanceResult
    An object containing attributes:

    statistic : float
       The tau statistic.
    pvalue : float
       The p-value for a hypothesis test whose null hypothesis is
       an absence of association, tau = 0.

Raises
------
ValueError
    If `nan_policy` is 'omit' and `variant` is not 'b' or
    if `method` is 'exact' and there are ties between `x` and `y`.

See Also
--------
spearmanr : Calculates a Spearman rank-order correlation coefficient.
theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).
weightedtau : Computes a weighted version of Kendall's tau.
:ref:`hypothesis_kendalltau` : Extended example

Notes
-----
The definition of Kendall's tau that is used is [2]_::

  tau_b = (P - Q) / sqrt((P + Q + T) * (P + Q + U))

  tau_c = 2 (P - Q) / (n**2 * (m - 1) / m)

where P is the number of concordant pairs, Q the number of discordant
pairs, T the number of ties only in `x`, and U the number of ties only in
`y`.  If a tie occurs for the same pair in both `x` and `y`, it is not
added to either T or U. n is the total number of samples, and m is the
number of unique values in either `x` or `y`, whichever is smaller.

References
----------
.. [1] Maurice G. Kendall, "A New Measure of Rank Correlation", Biometrika
       Vol. 30, No. 1/2, pp. 81-93, 1938.
.. [2] Maurice G. Kendall, "The treatment of ties in ranking problems",
       Biometrika Vol. 33, No. 3, pp. 239-251. 1945.
.. [3] Gottfried E. Noether, "Elements of Nonparametric Statistics", John
       Wiley & Sons, 1967.
.. [4] Peter M. Fenwick, "A new data structure for cumulative frequency
       tables", Software: Practice and Experience, Vol. 24, No. 3,
       pp. 327-336, 1994.
.. [5] Maurice G. Kendall, "Rank Correlation Methods" (4th Edition),
       Charles Griffin & Co., 1970.

Examples
--------

>>> from scipy import stats
>>> x1 = [12, 2, 1, 12, 2]
>>> x2 = [1, 4, 7, 1, 0]
>>> res = stats.kendalltau(x1, x2)
>>> res.statistic
-0.47140452079103173
>>> res.pvalue
0.2827454599327748

For a more detailed example, see :ref:`hypothesis_kendalltau`.
================================================================================

kruskal:
Firma: (*samples, nan_policy='propagate', axis=0, keepdims=False)

Docstring:
Compute the Kruskal-Wallis H-test for independent samples.

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
    Two or more arrays with the sample measurements can be given as
    arguments. Samples must be one-dimensional.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The Kruskal-Wallis H statistic, corrected for ties.
pvalue : float
    The p-value for the test using the assumption that H has a chi
    square distribution. The p-value returned is the survival function of
    the chi square distribution evaluated at H.

See Also
--------

:func:`f_oneway`
    1-way ANOVA.
:func:`mannwhitneyu`
    Mann-Whitney rank test on two samples.
:func:`friedmanchisquare`
    Friedman test for repeated measurements.


Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] W. H. Kruskal & W. W. Wallis, "Use of Ranks in
   One-Criterion Variance Analysis", Journal of the American Statistical
   Association, Vol. 47, Issue 260, pp. 583-621, 1952.
.. [2] https://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance

Examples
--------
>>> from scipy import stats
>>> x = [1, 3, 5, 7, 9]
>>> y = [2, 4, 6, 8, 10]
>>> stats.kruskal(x, y)
KruskalResult(statistic=0.2727272727272734, pvalue=0.6015081344405895)

>>> x = [1, 1, 1]
>>> y = [2, 2, 2]
>>> z = [2, 2]
>>> stats.kruskal(x, y, z)
KruskalResult(statistic=7.0, pvalue=0.0301973834223185)
================================================================================

ks_1samp:
Firma: (x, cdf, args=(), alternative='two-sided', method='auto', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Performs the one-sample Kolmogorov-Smirnov test for goodness of fit.

This test compares the underlying distribution F(x) of a sample
against a given continuous distribution G(x). See Notes for a description
of the available null and alternative hypotheses.

Parameters
----------
x : array_like
    a 1-D array of observations of iid random variables.
cdf : callable
    callable used to calculate the cdf.
args : tuple, sequence, optional
    Distribution parameters, used with `cdf`.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'approx', 'asymp'}, optional
    Defines the distribution used for calculating the p-value.
    The following options are available (default is 'auto'):
    
      * 'auto' : selects one of the other options.
      * 'exact' : uses the exact distribution of test statistic.
      * 'approx' : approximates the two-sided probability with twice
        the one-sided probability
      * 'asymp': uses asymptotic distribution of test statistic
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res: KstestResult
    An object containing attributes:
    
    statistic : float
        KS test statistic, either D+, D-, or D (the maximum of the two)
    pvalue : float
        One-tailed or two-tailed p-value.
    statistic_location : float
        Value of `x` corresponding with the KS statistic; i.e., the
        distance between the empirical distribution function and the
        hypothesized cumulative distribution function is measured at this
        observation.
    statistic_sign : int
        +1 if the KS statistic is the maximum positive difference between
        the empirical distribution function and the hypothesized cumulative
        distribution function (D+); -1 if the KS statistic is the maximum
        negative difference (D-).

See Also
--------

:func:`ks_2samp`, :func:`kstest`
    ..

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical.

- `less`: The null hypothesis is that F(x) >= G(x) for all x; the
  alternative is that F(x) < G(x) for at least one x.

- `greater`: The null hypothesis is that F(x) <= G(x) for all x; the
  alternative is that F(x) > G(x) for at least one x.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values. For example,
suppose x1 ~ F and x2 ~ G. If F(x) > G(x) for all x, the values in
x1 tend to be less than those in x2.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
Suppose we wish to test the null hypothesis that a sample is distributed
according to the standard normal.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

When testing uniformly distributed data, we would expect the
null hypothesis to be rejected.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> stats.ks_1samp(stats.uniform.rvs(size=100, random_state=rng),
...                stats.norm.cdf)
KstestResult(statistic=0.5001899973268688,
             pvalue=1.1616392184763533e-23,
             statistic_location=0.00047625268963724654,
             statistic_sign=-1)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
are *not* distributed according to the standard normal.

When testing random variates from the standard normal distribution, we
expect the data to be consistent with the null hypothesis most of the time.

>>> x = stats.norm.rvs(size=100, random_state=rng)
>>> stats.ks_1samp(x, stats.norm.cdf)
KstestResult(statistic=0.05345882212970396,
             pvalue=0.9227159037744717,
             statistic_location=-1.2451343873745018,
             statistic_sign=1)

As expected, the p-value of 0.92 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the random variates are distributed according to
a normal distribution that is shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF of the standard normal. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

>>> x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)
>>> stats.ks_1samp(x, stats.norm.cdf, alternative='less')
KstestResult(statistic=0.17482387821055168,
             pvalue=0.001913921057766743,
             statistic_location=0.3713830565352756,
             statistic_sign=-1)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.
================================================================================

ks_2samp:
Firma: (data1, data2, alternative='two-sided', method='auto', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.

This test compares the underlying continuous distributions F(x) and G(x)
of two independent samples.  See Notes for a description of the available
null and alternative hypotheses.

Parameters
----------
data1, data2 : array_like, 1-Dimensional
    Two arrays of sample observations assumed to be drawn from a continuous
    distribution, sample sizes can be different.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'asymp'}, optional
    Defines the method used for calculating the p-value.
    The following options are available (default is 'auto'):
    
      * 'auto' : use 'exact' for small size arrays, 'asymp' for large
      * 'exact' : use exact distribution of test statistic
      * 'asymp' : use asymptotic distribution of test statistic
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res: KstestResult
    An object containing attributes:
    
    statistic : float
        KS test statistic.
    pvalue : float
        One-tailed or two-tailed p-value.
    statistic_location : float
        Value from `data1` or `data2` corresponding with the KS statistic;
        i.e., the distance between the empirical distribution functions is
        measured at this observation.
    statistic_sign : int
        +1 if the empirical distribution function of `data1` exceeds
        the empirical distribution function of `data2` at
        `statistic_location`, otherwise -1.

See Also
--------

:func:`kstest`, :func:`ks_1samp`, :func:`epps_singleton_2samp`, :func:`anderson_ksamp`
    ..

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `less`: The null hypothesis is that F(x) >= G(x) for all x; the
  alternative is that F(x) < G(x) for at least one x. The statistic
  is the magnitude of the minimum (most negative) difference between the
  empirical distribution functions of the samples.

- `greater`: The null hypothesis is that F(x) <= G(x) for all x; the
  alternative is that F(x) > G(x) for at least one x. The statistic
  is the maximum (most positive) difference between the empirical
  distribution functions of the samples.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical. The statistic is the maximum absolute difference between the
  empirical distribution functions of the samples.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values of the data. For example,
suppose x1 ~ F and x2 ~ G. If F(x) > G(x) for all x, the values in
x1 tend to be less than those in x2.

If the KS statistic is large, then the p-value will be small, and this may
be taken as evidence against the null hypothesis in favor of the
alternative.

If ``method='exact'``, `ks_2samp` attempts to compute an exact p-value,
that is, the probability under the null hypothesis of obtaining a test
statistic value as extreme as the value computed from the data.
If ``method='asymp'``, the asymptotic Kolmogorov-Smirnov distribution is
used to compute an approximate p-value.
If ``method='auto'``, an exact p-value computation is attempted if both
sample sizes are less than 10000; otherwise, the asymptotic method is used.
In any case, if an exact p-value calculation is attempted and fails, a
warning will be emitted, and the asymptotic p-value will be returned.

The 'two-sided' 'exact' computation computes the complementary probability
and then subtracts from 1.  As such, the minimum probability it can return
is about 1e-16.  While the algorithm itself is exact, numerical
errors may accumulate for large sample sizes.   It is most suited to
situations in which one of the sample sizes is only a few thousand.

We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk [1]_.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Hodges, J.L. Jr.,  "The Significance Probability of the Smirnov
       Two-Sample Test," Arkiv fiur Matematik, 3, No. 43 (1958), 469-486.

Examples
--------
Suppose we wish to test the null hypothesis that two samples were drawn
from the same distribution.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

If the first sample were drawn from a uniform distribution and the second
were drawn from the standard normal, we would expect the null hypothesis
to be rejected.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> sample1 = stats.uniform.rvs(size=100, random_state=rng)
>>> sample2 = stats.norm.rvs(size=110, random_state=rng)
>>> stats.ks_2samp(sample1, sample2)
KstestResult(statistic=0.5454545454545454,
             pvalue=7.37417839555191e-15,
             statistic_location=-0.014071496412861274,
             statistic_sign=-1)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
were *not* drawn from the same distribution.

When both samples are drawn from the same distribution, we expect the data
to be consistent with the null hypothesis most of the time.

>>> sample1 = stats.norm.rvs(size=105, random_state=rng)
>>> sample2 = stats.norm.rvs(size=95, random_state=rng)
>>> stats.ks_2samp(sample1, sample2)
KstestResult(statistic=0.10927318295739348,
             pvalue=0.5438289009927495,
             statistic_location=-0.1670157701848795,
             statistic_sign=-1)

As expected, the p-value of 0.54 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the first sample were drawn from
a normal distribution shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF underlying the second sample. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

>>> sample1 = stats.norm.rvs(size=105, loc=0.5, random_state=rng)
>>> stats.ks_2samp(sample1, sample2, alternative='less')
KstestResult(statistic=0.4055137844611529,
             pvalue=3.5474563068855554e-08,
             statistic_location=-0.13249370614972575,
             statistic_sign=-1)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.
================================================================================

ksone:
Firma: (*args, **kwds)

Docstring:
Kolmogorov-Smirnov one-sided test statistic distribution.

This is the distribution of the one-sided Kolmogorov-Smirnov (KS)
statistics :math:`D_n^+` and :math:`D_n^-`
for a finite sample size ``n >= 1`` (the shape parameter).

As an instance of the `rv_continuous` class, `ksone` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, n, loc=0, scale=1)
    Probability density function.
logpdf(x, n, loc=0, scale=1)
    Log of the probability density function.
cdf(x, n, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, n, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, n, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, n, loc=0, scale=1)
    Log of the survival function.
ppf(q, n, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, n, loc=0, scale=1)
    Non-central moment of the specified order.
stats(n, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(n,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, loc=0, scale=1)
    Median of the distribution.
mean(n, loc=0, scale=1)
    Mean of the distribution.
var(n, loc=0, scale=1)
    Variance of the distribution.
std(n, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, n, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
kstwobign, kstwo, kstest

Notes
-----
:math:`D_n^+` and :math:`D_n^-` are given by

.. math::

    D_n^+ &= \text{sup}_x (F_n(x) - F(x)),\\
    D_n^- &= \text{sup}_x (F(x) - F_n(x)),\\

where :math:`F` is a continuous CDF and :math:`F_n` is an empirical CDF.
`ksone` describes the distribution under the null hypothesis of the KS test
that the empirical CDF corresponds to :math:`n` i.i.d. random variates
with CDF :math:`F`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``ksone.pdf(x, n, loc, scale)`` is identically
equivalent to ``ksone.pdf(y, n) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Birnbaum, Z. W. and Tingey, F.H. "One-sided confidence contours
   for probability distribution functions", The Annals of Mathematical
   Statistics, 22(4), pp 592-596 (1951).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import ksone
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Display the probability density function (``pdf``):

>>> n = 1e+03
>>> x = np.linspace(ksone.ppf(0.01, n),
...                 ksone.ppf(0.99, n), 100)
>>> ax.plot(x, ksone.pdf(x, n),
...         'r-', lw=5, alpha=0.6, label='ksone pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = ksone(n)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = ksone.ppf([0.001, 0.5, 0.999], n)
>>> np.allclose([0.001, 0.5, 0.999], ksone.cdf(vals, n))
True
================================================================================

kstat:
Firma: (data, n=2, *, axis=None, nan_policy='propagate', keepdims=False)

Docstring:
Return the `n` th k-statistic ( ``1<=n<=4`` so far).

The `n` th k-statistic ``k_n`` is the unique symmetric unbiased estimator of the
`n` th cumulant :math:`\kappa_n` [1]_ [2]_.

Parameters
----------
data : array_like
    Input array.
n : int, {1, 2, 3, 4}, optional
    Default is equal to 2.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
kstat : float
    The `n` th k-statistic.

See Also
--------

:func:`kstatvar`
    Returns an unbiased estimator of the variance of the k-statistic
:func:`moment`
    Returns the n-th central moment about the mean for a sample.


Notes
-----
For a sample size :math:`n`, the first few k-statistics are given by

.. math::

    k_1 &= \frac{S_1}{n}, \\
    k_2 &= \frac{nS_2 - S_1^2}{n(n-1)}, \\
    k_3 &= \frac{2S_1^3 - 3nS_1S_2 + n^2S_3}{n(n-1)(n-2)}, \\
    k_4 &= \frac{-6S_1^4 + 12nS_1^2S_2 - 3n(n-1)S_2^2 - 4n(n+1)S_1S_3
    + n^2(n+1)S_4}{n (n-1)(n-2)(n-3)},

where

.. math::

    S_r \equiv \sum_{i=1}^n X_i^r,

and :math:`X_i` is the :math:`i` th data point.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] http://mathworld.wolfram.com/k-Statistic.html

.. [2] http://mathworld.wolfram.com/Cumulant.html

Examples
--------
>>> from scipy import stats
>>> from numpy.random import default_rng
>>> rng = default_rng()

As sample size increases, `n`-th moment and `n`-th k-statistic converge to the
same number (although they aren't identical). In the case of the normal
distribution, they converge to zero.

>>> for i in range(2,8):
...     x = rng.normal(size=10**i)
...     m, k = stats.moment(x, 3), stats.kstat(x, 3)
...     print(f"{i=}: {m=:.3g}, {k=:.3g}, {(m-k)=:.3g}")
i=2: m=-0.631, k=-0.651, (m-k)=0.0194  # random
i=3: m=0.0282, k=0.0283, (m-k)=-8.49e-05
i=4: m=-0.0454, k=-0.0454, (m-k)=1.36e-05
i=6: m=7.53e-05, k=7.53e-05, (m-k)=-2.26e-09
i=7: m=0.00166, k=0.00166, (m-k)=-4.99e-09
i=8: m=-2.88e-06 k=-2.88e-06, (m-k)=8.63e-13
================================================================================

kstatvar:
Firma: (data, n=2, *, axis=None, nan_policy='propagate', keepdims=False)

Docstring:
Return an unbiased estimator of the variance of the k-statistic.

See `kstat` and [1]_ for more details about the k-statistic.

Parameters
----------
data : array_like
    Input array.
n : int, {1, 2}, optional
    Default is equal to 2.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
kstatvar : float
    The `n` th k-statistic variance.

See Also
--------

:func:`kstat`
    Returns the n-th k-statistic.
:func:`moment`
    Returns the n-th central moment about the mean for a sample.


Notes
-----
Unbiased estimators of the variances of the first two k-statistics are given by

.. math::

    \mathrm{var}(k_1) &= \frac{k_2}{n}, \\
    \mathrm{var}(k_2) &= \frac{2k_2^2n + (n-1)k_4}{n(n - 1)}.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] http://mathworld.wolfram.com/k-Statistic.html
================================================================================

kstest:
Firma: (rvs, cdf, args=(), N=20, alternative='two-sided', method='auto', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for
goodness of fit.

The one-sample test compares the underlying distribution F(x) of a sample
against a given distribution G(x). The two-sample test compares the
underlying distributions of two independent samples. Both tests are valid
only for continuous distributions.

Parameters
----------
rvs : str, array_like, or callable
    If an array, it should be a 1-D array of observations of random
    variables.
    If a callable, it should be a function to generate random variables;
    it is required to have a keyword argument `size`.
    If a string, it should be the name of a distribution in `scipy.stats`,
    which will be used to generate random variables.
cdf : str, array_like or callable
    If array_like, it should be a 1-D array of observations of random
    variables, and the two-sample test is performed
    (and rvs must be array_like).
    If a callable, that callable is used to calculate the cdf.
    If a string, it should be the name of a distribution in `scipy.stats`,
    which will be used as the cdf function.
args : tuple, sequence, optional
    Distribution parameters, used if `rvs` or `cdf` are strings or
    callables.
N : int, optional
    Sample size if `rvs` is string or callable.  Default is 20.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'approx', 'asymp'}, optional
    Defines the distribution used for calculating the p-value.
    The following options are available (default is 'auto'):
    
      * 'auto' : selects one of the other options.
      * 'exact' : uses the exact distribution of test statistic.
      * 'approx' : approximates the two-sided probability with twice the
        one-sided probability
      * 'asymp': uses asymptotic distribution of test statistic
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res: KstestResult
    An object containing attributes:
    
    statistic : float
        KS test statistic, either D+, D-, or D (the maximum of the two)
    pvalue : float
        One-tailed or two-tailed p-value.
    statistic_location : float
        In a one-sample test, this is the value of `rvs`
        corresponding with the KS statistic; i.e., the distance between
        the empirical distribution function and the hypothesized cumulative
        distribution function is measured at this observation.
    
        In a two-sample test, this is the value from `rvs` or `cdf`
        corresponding with the KS statistic; i.e., the distance between
        the empirical distribution functions is measured at this
        observation.
    statistic_sign : int
        In a one-sample test, this is +1 if the KS statistic is the
        maximum positive difference between the empirical distribution
        function and the hypothesized cumulative distribution function
        (D+); it is -1 if the KS statistic is the maximum negative
        difference (D-).
    
        In a two-sample test, this is +1 if the empirical distribution
        function of `rvs` exceeds the empirical distribution
        function of `cdf` at `statistic_location`, otherwise -1.

See Also
--------

:func:`ks_1samp`, :func:`ks_2samp`
    ..

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical.

- `less`: The null hypothesis is that F(x) >= G(x) for all x; the
  alternative is that F(x) < G(x) for at least one x.

- `greater`: The null hypothesis is that F(x) <= G(x) for all x; the
  alternative is that F(x) > G(x) for at least one x.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values. For example,
suppose x1 ~ F and x2 ~ G. If F(x) > G(x) for all x, the values in
x1 tend to be less than those in x2.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
Suppose we wish to test the null hypothesis that a sample is distributed
according to the standard normal.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

When testing uniformly distributed data, we would expect the
null hypothesis to be rejected.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> stats.kstest(stats.uniform.rvs(size=100, random_state=rng),
...              stats.norm.cdf)
KstestResult(statistic=0.5001899973268688,
             pvalue=1.1616392184763533e-23,
             statistic_location=0.00047625268963724654,
             statistic_sign=-1)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
are *not* distributed according to the standard normal.

When testing random variates from the standard normal distribution, we
expect the data to be consistent with the null hypothesis most of the time.

>>> x = stats.norm.rvs(size=100, random_state=rng)
>>> stats.kstest(x, stats.norm.cdf)
KstestResult(statistic=0.05345882212970396,
             pvalue=0.9227159037744717,
             statistic_location=-1.2451343873745018,
             statistic_sign=1)

As expected, the p-value of 0.92 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the random variates are distributed according to
a normal distribution that is shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF of the standard normal. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

>>> x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)
>>> stats.kstest(x, stats.norm.cdf, alternative='less')
KstestResult(statistic=0.17482387821055168,
             pvalue=0.001913921057766743,
             statistic_location=0.3713830565352756,
             statistic_sign=-1)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.

For convenience, the previous test can be performed using the name of the
distribution as the second argument.

>>> stats.kstest(x, "norm", alternative='less')
KstestResult(statistic=0.17482387821055168,
             pvalue=0.001913921057766743,
             statistic_location=0.3713830565352756,
             statistic_sign=-1)

The examples above have all been one-sample tests identical to those
performed by `ks_1samp`. Note that `kstest` can also perform two-sample
tests identical to those performed by `ks_2samp`. For example, when two
samples are drawn from the same distribution, we expect the data to be
consistent with the null hypothesis most of the time.

>>> sample1 = stats.laplace.rvs(size=105, random_state=rng)
>>> sample2 = stats.laplace.rvs(size=95, random_state=rng)
>>> stats.kstest(sample1, sample2)
KstestResult(statistic=0.11779448621553884,
             pvalue=0.4494256912629795,
             statistic_location=0.6138814275424155,
             statistic_sign=1)

As expected, the p-value of 0.45 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.
================================================================================

kstwo:
Firma: (*args, **kwds)

Docstring:
Kolmogorov-Smirnov two-sided test statistic distribution.

This is the distribution of the two-sided Kolmogorov-Smirnov (KS)
statistic :math:`D_n` for a finite sample size ``n >= 1``
(the shape parameter).

As an instance of the `rv_continuous` class, `kstwo` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, n, loc=0, scale=1)
    Probability density function.
logpdf(x, n, loc=0, scale=1)
    Log of the probability density function.
cdf(x, n, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, n, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, n, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, n, loc=0, scale=1)
    Log of the survival function.
ppf(q, n, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, n, loc=0, scale=1)
    Non-central moment of the specified order.
stats(n, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(n,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, loc=0, scale=1)
    Median of the distribution.
mean(n, loc=0, scale=1)
    Mean of the distribution.
var(n, loc=0, scale=1)
    Variance of the distribution.
std(n, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, n, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
kstwobign, ksone, kstest

Notes
-----
:math:`D_n` is given by

.. math::

    D_n = \text{sup}_x |F_n(x) - F(x)|

where :math:`F` is a (continuous) CDF and :math:`F_n` is an empirical CDF.
`kstwo` describes the distribution under the null hypothesis of the KS test
that the empirical CDF corresponds to :math:`n` i.i.d. random variates
with CDF :math:`F`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``kstwo.pdf(x, n, loc, scale)`` is identically
equivalent to ``kstwo.pdf(y, n) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Simard, R., L'Ecuyer, P. "Computing the Two-Sided
   Kolmogorov-Smirnov Distribution",  Journal of Statistical Software,
   Vol 39, 11, 1-18 (2011).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import kstwo
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Display the probability density function (``pdf``):

>>> n = 10
>>> x = np.linspace(kstwo.ppf(0.01, n),
...                 kstwo.ppf(0.99, n), 100)
>>> ax.plot(x, kstwo.pdf(x, n),
...         'r-', lw=5, alpha=0.6, label='kstwo pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = kstwo(n)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = kstwo.ppf([0.001, 0.5, 0.999], n)
>>> np.allclose([0.001, 0.5, 0.999], kstwo.cdf(vals, n))
True
================================================================================

kstwobign:
Firma: (*args, **kwds)

Docstring:
Limiting distribution of scaled Kolmogorov-Smirnov two-sided test statistic.

This is the asymptotic distribution of the two-sided Kolmogorov-Smirnov
statistic :math:`\sqrt{n} D_n` that measures the maximum absolute
distance of the theoretical (continuous) CDF from the empirical CDF.
(see `kstest`).

As an instance of the `rv_continuous` class, `kstwobign` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
ksone, kstwo, kstest

Notes
-----
:math:`\sqrt{n} D_n` is given by

.. math::

    D_n = \text{sup}_x |F_n(x) - F(x)|

where :math:`F` is a continuous CDF and :math:`F_n` is an empirical CDF.
`kstwobign`  describes the asymptotic distribution (i.e. the limit of
:math:`\sqrt{n} D_n`) under the null hypothesis of the KS test that the
empirical CDF corresponds to i.i.d. random variates with CDF :math:`F`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``kstwobign.pdf(x, loc, scale)`` is identically
equivalent to ``kstwobign.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Feller, W. "On the Kolmogorov-Smirnov Limit Theorems for Empirical
   Distributions",  Ann. Math. Statist. Vol 19, 177-189 (1948).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import kstwobign
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = kstwobign.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(kstwobign.ppf(0.01),
...                 kstwobign.ppf(0.99), 100)
>>> ax.plot(x, kstwobign.pdf(x),
...        'r-', lw=5, alpha=0.6, label='kstwobign pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = kstwobign()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = kstwobign.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], kstwobign.cdf(vals))
True

Generate random numbers:

>>> r = kstwobign.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

kurtosis:
Firma: (a, axis=0, fisher=True, bias=True, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the kurtosis (Fisher or Pearson) of a dataset.

Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.

If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators

Use `kurtosistest` to see if result is close enough to normal.

Parameters
----------
a : array
    Data for which the kurtosis is calculated.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
fisher : bool, optional
    If True, Fisher's definition is used (normal ==> 0.0). If False,
    Pearson's definition is used (normal ==> 3.0).
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
kurtosis : array
    The kurtosis of values along an axis, returning NaN where all values
    are equal.

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.

Examples
--------
In Fisher's definition, the kurtosis of the normal distribution is zero.
In the following example, the kurtosis is close to zero, because it was
calculated from the dataset, not from the continuous distribution.

>>> import numpy as np
>>> from scipy.stats import norm, kurtosis
>>> data = norm.rvs(size=1000, random_state=3)
>>> kurtosis(data)
-0.06928694200380558

The distribution with a higher kurtosis has a heavier tail.
The zero valued kurtosis of the normal distribution in Fisher's definition
can serve as a reference point.

>>> import matplotlib.pyplot as plt
>>> import scipy.stats as stats
>>> from scipy.stats import kurtosis

>>> x = np.linspace(-5, 5, 100)
>>> ax = plt.subplot()
>>> distnames = ['laplace', 'norm', 'uniform']

>>> for distname in distnames:
...     if distname == 'uniform':
...         dist = getattr(stats, distname)(loc=-2, scale=4)
...     else:
...         dist = getattr(stats, distname)
...     data = dist.rvs(size=1000)
...     kur = kurtosis(data, fisher=True)
...     y = dist.pdf(x)
...     ax.plot(x, y, label="{}, {}".format(distname, round(kur, 3)))
...     ax.legend()

The Laplace distribution has a heavier tail than the normal distribution.
The uniform distribution (which has negative kurtosis) has the thinnest
tail.
================================================================================

kurtosistest:
Firma: (a, axis=0, nan_policy='propagate', alternative='two-sided', *, keepdims=False)

Docstring:
Test whether a dataset has normal kurtosis.

This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution.

Parameters
----------
a : array
    Array of the sample data. Must contain at least five observations.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):
    
    * 'two-sided': the kurtosis of the distribution underlying the sample
      is different from that of the normal distribution
    * 'less': the kurtosis of the distribution underlying the sample
      is less than that of the normal distribution
    * 'greater': the kurtosis of the distribution underlying the sample
      is greater than that of the normal distribution
    
    .. versionadded:: 1.7.0
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The p-value for the hypothesis test.

See Also
--------

:ref:`hypothesis_kurtosistest`
    Extended example


Notes
-----
Valid only for n>20. This function uses the method described in [1]_.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] F. J. Anscombe, W. J. Glynn, "Distribution of the kurtosis
   statistic b2 for normal samples", Biometrika, vol. 70, pp. 227-234, 1983.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import kurtosistest
>>> kurtosistest(list(range(20)))
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.08804338332528348)
>>> kurtosistest(list(range(20)), alternative='less')
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.04402169166264174)
>>> kurtosistest(list(range(20)), alternative='greater')
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.9559783083373583)
>>> rng = np.random.default_rng()
>>> s = rng.normal(0, 1, 1000)
>>> kurtosistest(s)
KurtosistestResult(statistic=-1.475047944490622, pvalue=0.14019965402996987)

For a more detailed example, see :ref:`hypothesis_kurtosistest`.
================================================================================

landau:
Firma: (*args, **kwds)

Docstring:
A Landau continuous random variable.

As an instance of the `rv_continuous` class, `landau` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `landau` ([1]_, [2]_) is:

.. math::

    f(x) = \frac{1}{\pi}\int_0^\infty \exp(-t \log t - xt)\sin(\pi t) dt

for a real number :math:`x`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``landau.pdf(x, loc, scale)`` is identically
equivalent to ``landau.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Often (e.g. [2]_), the Landau distribution is parameterized in terms of a
location parameter :math:`\mu` and scale parameter :math:`c`, the latter of
which *also* introduces a location shift. If ``mu`` and ``c`` are used to
represent these parameters, this corresponds with SciPy's parameterization
with ``loc = mu + 2*c / np.pi * np.log(c)`` and ``scale = c``.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pdf``, ``cdf``, ``ppf``, ``sf`` and ``isf``
methods. [1]_

References
----------
.. [1] Landau, L. (1944). "On the energy loss of fast particles by
       ionization". J. Phys. (USSR). 8: 201.
.. [2] "Landau Distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Landau_distribution
.. [3] Chambers, J. M., Mallows, C. L., & Stuck, B. (1976).
       "A method for simulating stable random variables."
       Journal of the American Statistical Association, 71(354), 340-344.
.. [4] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.
.. [5] Yoshimura, T. "Numerical Evaluation and High Precision Approximation
       Formula for Landau Distribution".
       :doi:`10.36227/techrxiv.171822215.53612870/v2`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import landau
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = landau.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(landau.ppf(0.01),
...                 landau.ppf(0.99), 100)
>>> ax.plot(x, landau.pdf(x),
...        'r-', lw=5, alpha=0.6, label='landau pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = landau()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = landau.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], landau.cdf(vals))
True

Generate random numbers:

>>> r = landau.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

laplace:
Firma: (*args, **kwds)

Docstring:
A Laplace continuous random variable.

As an instance of the `rv_continuous` class, `laplace` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `laplace` is

.. math::

    f(x) = \frac{1}{2} \exp(-|x|)

for a real number :math:`x`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``laplace.pdf(x, loc, scale)`` is identically
equivalent to ``laplace.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import laplace
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = laplace.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(laplace.ppf(0.01),
...                 laplace.ppf(0.99), 100)
>>> ax.plot(x, laplace.pdf(x),
...        'r-', lw=5, alpha=0.6, label='laplace pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = laplace()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = laplace.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], laplace.cdf(vals))
True

Generate random numbers:

>>> r = laplace.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

laplace_asymmetric:
Firma: (*args, **kwds)

Docstring:
An asymmetric Laplace continuous random variable.

As an instance of the `rv_continuous` class, `laplace_asymmetric` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(kappa, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, kappa, loc=0, scale=1)
    Probability density function.
logpdf(x, kappa, loc=0, scale=1)
    Log of the probability density function.
cdf(x, kappa, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, kappa, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, kappa, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, kappa, loc=0, scale=1)
    Log of the survival function.
ppf(q, kappa, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, kappa, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, kappa, loc=0, scale=1)
    Non-central moment of the specified order.
stats(kappa, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(kappa, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(kappa,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(kappa, loc=0, scale=1)
    Median of the distribution.
mean(kappa, loc=0, scale=1)
    Mean of the distribution.
var(kappa, loc=0, scale=1)
    Variance of the distribution.
std(kappa, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, kappa, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
laplace : Laplace distribution

Notes
-----
The probability density function for `laplace_asymmetric` is

.. math::

   f(x, \kappa) &= \frac{1}{\kappa+\kappa^{-1}}\exp(-x\kappa),\quad x\ge0\\
                &= \frac{1}{\kappa+\kappa^{-1}}\exp(x/\kappa),\quad x<0\\

for :math:`-\infty < x < \infty`, :math:`\kappa > 0`.

`laplace_asymmetric` takes ``kappa`` as a shape parameter for
:math:`\kappa`. For :math:`\kappa = 1`, it is identical to a
Laplace distribution.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``laplace_asymmetric.pdf(x, kappa, loc, scale)`` is identically
equivalent to ``laplace_asymmetric.pdf(y, kappa) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Note that the scale parameter of some references is the reciprocal of
SciPy's ``scale``. For example, :math:`\lambda = 1/2` in the
parameterization of [1]_ is equivalent to ``scale = 2`` with
`laplace_asymmetric`.

References
----------
.. [1] "Asymmetric Laplace distribution", Wikipedia
        https://en.wikipedia.org/wiki/Asymmetric_Laplace_distribution

.. [2] Kozubowski TJ and Podgórski K. A Multivariate and
       Asymmetric Generalization of Laplace Distribution,
       Computational Statistics 15, 531--540 (2000).
       :doi:`10.1007/PL00022717`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import laplace_asymmetric
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> kappa = 2
>>> mean, var, skew, kurt = laplace_asymmetric.stats(kappa, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(laplace_asymmetric.ppf(0.01, kappa),
...                 laplace_asymmetric.ppf(0.99, kappa), 100)
>>> ax.plot(x, laplace_asymmetric.pdf(x, kappa),
...        'r-', lw=5, alpha=0.6, label='laplace_asymmetric pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = laplace_asymmetric(kappa)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = laplace_asymmetric.ppf([0.001, 0.5, 0.999], kappa)
>>> np.allclose([0.001, 0.5, 0.999], laplace_asymmetric.cdf(vals, kappa))
True

Generate random numbers:

>>> r = laplace_asymmetric.rvs(kappa, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

levene:
Firma: (*samples, center='median', proportiontocut=0.05, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Perform Levene test for equal variances.

The Levene test tests the null hypothesis that all input samples
are from populations with equal variances.  Levene's test is an
alternative to Bartlett's test `bartlett` in the case where
there are significant deviations from normality.

Parameters
----------
sample1, sample2, ... : array_like
    The sample data, possibly with different lengths. Only one-dimensional
    samples are accepted.
center : {'mean', 'median', 'trimmed'}, optional
    Which function of the data to use in the test.  The default
    is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the test.

See Also
--------

:func:`fligner`
    A non-parametric test for the equality of k variances
:func:`bartlett`
    A parametric test for equality of k variances in normal samples
:ref:`hypothesis_levene`
    Extended example


Notes
-----
Three variations of Levene's test are possible.  The possibilities
and their recommended usages are:

* 'median' : Recommended for skewed (non-normal) distributions>
* 'mean' : Recommended for symmetric, moderate-tailed distributions.
* 'trimmed' : Recommended for heavy-tailed distributions.

The test version using the mean was proposed in the original article
of Levene ([2]_) while the median and trimmed mean have been studied by
Brown and Forsythe ([3]_), sometimes also referred to as Brown-Forsythe
test.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm
.. [2] Levene, H. (1960). In Contributions to Probability and Statistics:
       Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,
       Stanford University Press, pp. 278-292.
.. [3] Brown, M. B. and Forsythe, A. B. (1974), Journal of the American
       Statistical Association, 69, 364-367

Examples
--------
Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

>>> import numpy as np
>>> from scipy import stats
>>> a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
>>> b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
>>> c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
>>> stat, p = stats.levene(a, b, c)
>>> p
0.002431505967249681

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

>>> [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]

For a more detailed example, see :ref:`hypothesis_levene`.
================================================================================

levy:
Firma: (*args, **kwds)

Docstring:
A Levy continuous random variable.

As an instance of the `rv_continuous` class, `levy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
levy_stable, levy_l

Notes
-----
The probability density function for `levy` is:

.. math::

    f(x) = \frac{1}{\sqrt{2\pi x^3}} \exp\left(-\frac{1}{2x}\right)

for :math:`x > 0`.

This is the same as the Levy-stable distribution with :math:`a=1/2` and
:math:`b=1`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``levy.pdf(x, loc, scale)`` is identically
equivalent to ``levy.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import levy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mean, var, skew, kurt = levy.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> # `levy` is very heavy-tailed.
>>> # To show a nice plot, let's cut off the upper 40 percent.
>>> a, b = levy.ppf(0), levy.ppf(0.6)
>>> x = np.linspace(a, b, 100)
>>> ax.plot(x, levy.pdf(x),
...        'r-', lw=5, alpha=0.6, label='levy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = levy()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = levy.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], levy.cdf(vals))
True

Generate random numbers:

>>> r = levy.rvs(size=1000)

And compare the histogram:

>>> # manual binning to ignore the tail
>>> bins = np.concatenate((np.linspace(a, b, 20), [np.max(r)]))
>>> ax.hist(r, bins=bins, density=True, histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

levy_l:
Firma: (*args, **kwds)

Docstring:
A left-skewed Levy continuous random variable.

As an instance of the `rv_continuous` class, `levy_l` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
levy, levy_stable

Notes
-----
The probability density function for `levy_l` is:

.. math::
    f(x) = \frac{1}{|x| \sqrt{2\pi |x|}} \exp{ \left(-\frac{1}{2|x|} \right)}

for :math:`x < 0`.

This is the same as the Levy-stable distribution with :math:`a=1/2` and
:math:`b=-1`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``levy_l.pdf(x, loc, scale)`` is identically
equivalent to ``levy_l.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import levy_l
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mean, var, skew, kurt = levy_l.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> # `levy_l` is very heavy-tailed.
>>> # To show a nice plot, let's cut off the lower 40 percent.
>>> a, b = levy_l.ppf(0.4), levy_l.ppf(1)
>>> x = np.linspace(a, b, 100)
>>> ax.plot(x, levy_l.pdf(x),
...        'r-', lw=5, alpha=0.6, label='levy_l pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = levy_l()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = levy_l.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], levy_l.cdf(vals))
True

Generate random numbers:

>>> r = levy_l.rvs(size=1000)

And compare the histogram:

>>> # manual binning to ignore the tail
>>> bins = np.concatenate(([np.min(r)], np.linspace(a, b, 20)))
>>> ax.hist(r, bins=bins, density=True, histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

levy_stable:
Firma: (*args, **params)

Docstring:
A Levy-stable continuous random variable.

As an instance of the `rv_continuous` class, `levy_stable` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(alpha, beta, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, alpha, beta, loc=0, scale=1)
    Probability density function.
logpdf(x, alpha, beta, loc=0, scale=1)
    Log of the probability density function.
cdf(x, alpha, beta, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, alpha, beta, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, alpha, beta, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, alpha, beta, loc=0, scale=1)
    Log of the survival function.
ppf(q, alpha, beta, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, alpha, beta, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, alpha, beta, loc=0, scale=1)
    Non-central moment of the specified order.
stats(alpha, beta, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(alpha, beta, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(alpha, beta), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(alpha, beta, loc=0, scale=1)
    Median of the distribution.
mean(alpha, beta, loc=0, scale=1)
    Mean of the distribution.
var(alpha, beta, loc=0, scale=1)
    Variance of the distribution.
std(alpha, beta, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, alpha, beta, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
levy, levy_l, cauchy, norm

Notes
-----
The distribution for `levy_stable` has characteristic function:

.. math::

    \varphi(t, \alpha, \beta, c, \mu) =
    e^{it\mu -|ct|^{\alpha}(1-i\beta\operatorname{sign}(t)\Phi(\alpha, t))}

where two different parameterizations are supported. The first :math:`S_1`:

.. math::

    \Phi = \begin{cases}
            \tan \left({\frac {\pi \alpha }{2}}\right)&\alpha \neq 1\\
            -{\frac {2}{\pi }}\log |t|&\alpha =1
            \end{cases}

The second :math:`S_0`:

.. math::

    \Phi = \begin{cases}
            -\tan \left({\frac {\pi \alpha }{2}}\right)(|ct|^{1-\alpha}-1)
            &\alpha \neq 1\\
            -{\frac {2}{\pi }}\log |ct|&\alpha =1
            \end{cases}


The probability density function for `levy_stable` is:

.. math::

    f(x) = \frac{1}{2\pi}\int_{-\infty}^\infty \varphi(t)e^{-ixt}\,dt

where :math:`-\infty < t < \infty`. This integral does not have a known
closed form.

`levy_stable` generalizes several distributions.  Where possible, they
should be used instead.  Specifically, when the shape parameters
assume the values in the table below, the corresponding equivalent
distribution should be used.

=========  ========  ===========
``alpha``  ``beta``   Equivalent
=========  ========  ===========
 1/2       -1        `levy_l`
 1/2       1         `levy`
 1         0         `cauchy`
 2         any       `norm` (with ``scale=sqrt(2)``)
=========  ========  ===========

Evaluation of the pdf uses Nolan's piecewise integration approach with the
Zolotarev :math:`M` parameterization by default. There is also the option
to use direct numerical integration of the standard parameterization of the
characteristic function or to evaluate by taking the FFT of the
characteristic function.

The default method can changed by setting the class variable
``levy_stable.pdf_default_method`` to one of 'piecewise' for Nolan's
approach, 'dni' for direct numerical integration, or 'fft-simpson' for the
FFT based approach. For the sake of backwards compatibility, the methods
'best' and 'zolotarev' are equivalent to 'piecewise' and the method
'quadrature' is equivalent to 'dni'.

The parameterization can be changed  by setting the class variable
``levy_stable.parameterization`` to either 'S0' or 'S1'.
The default is 'S1'.

To improve performance of piecewise and direct numerical integration one
can specify ``levy_stable.quad_eps`` (defaults to 1.2e-14). This is used
as both the absolute and relative quadrature tolerance for direct numerical
integration and as the relative quadrature tolerance for the piecewise
method. One can also specify ``levy_stable.piecewise_x_tol_near_zeta``
(defaults to 0.005) for how close x is to zeta before it is considered the
same as x [NO]. The exact check is
``abs(x0 - zeta) < piecewise_x_tol_near_zeta*alpha**(1/alpha)``. One can
also specify ``levy_stable.piecewise_alpha_tol_near_one`` (defaults to
0.005) for how close alpha is to 1 before being considered equal to 1.

To increase accuracy of FFT calculation one can specify
``levy_stable.pdf_fft_grid_spacing`` (defaults to 0.001) and
``pdf_fft_n_points_two_power`` (defaults to None which means a value is
calculated that sufficiently covers the input range).

Further control over FFT calculation is available by setting
``pdf_fft_interpolation_degree`` (defaults to 3) for spline order and
``pdf_fft_interpolation_level`` for determining the number of points to use
in the Newton-Cotes formula when approximating the characteristic function
(considered experimental).

Evaluation of the cdf uses Nolan's piecewise integration approach with the
Zolatarev :math:`S_0` parameterization by default. There is also the option
to evaluate through integration of an interpolated spline of the pdf
calculated by means of the FFT method. The settings affecting FFT
calculation are the same as for pdf calculation. The default cdf method can
be changed by setting ``levy_stable.cdf_default_method`` to either
'piecewise' or 'fft-simpson'.  For cdf calculations the Zolatarev method is
superior in accuracy, so FFT is disabled by default.

Fitting estimate uses quantile estimation method in [MC]. MLE estimation of
parameters in fit method uses this quantile estimate initially. Note that
MLE doesn't always converge if using FFT for pdf calculations; this will be
the case if alpha <= 1 where the FFT approach doesn't give good
approximations.

Any non-missing value for the attribute
``levy_stable.pdf_fft_min_points_threshold`` will set
``levy_stable.pdf_default_method`` to 'fft-simpson' if a valid
default method is not otherwise set.



.. warning::

    For pdf calculations FFT calculation is considered experimental.

    For cdf calculations FFT calculation is considered experimental. Use
    Zolatarev's method instead (default).

The probability density above is defined in the "standardized" form. To
shift and/or scale the distribution use the ``loc`` and ``scale``
parameters.
Generally ``levy_stable.pdf(x, alpha, beta, loc, scale)`` is identically
equivalent to ``levy_stable.pdf(y, alpha, beta) / scale`` with
``y = (x - loc) / scale``, except in the ``S1`` parameterization if
``alpha == 1``.  In that case ``levy_stable.pdf(x, alpha, beta, loc, scale)``
is identically equivalent to ``levy_stable.pdf(y, alpha, beta) / scale`` with
``y = (x - loc - 2 * beta * scale * np.log(scale) / np.pi) / scale``.
See [NO2]_ Definition 1.8 for more information.
Note that shifting the location of a distribution
does not make it a "noncentral" distribution.

References
----------
.. [MC] McCulloch, J., 1986. Simple consistent estimators of stable
    distribution parameters. Communications in Statistics - Simulation and
    Computation 15, 11091136.
.. [WZ] Wang, Li and Zhang, Ji-Hong, 2008. Simpson's rule based FFT method
    to compute densities of stable distribution.
.. [NO] Nolan, J., 1997. Numerical Calculation of Stable Densities and
    distributions Functions.
.. [NO2] Nolan, J., 2018. Stable Distributions: Models for Heavy Tailed
    Data.
.. [HO] Hopcraft, K. I., Jakeman, E., Tanner, R. M. J., 1999. Lévy random
    walks with fluctuating step number and multiscale behavior.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import levy_stable
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> alpha, beta = 1.8, -0.5
>>> mean, var, skew, kurt = levy_stable.stats(alpha, beta, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(levy_stable.ppf(0.01, alpha, beta),
...                 levy_stable.ppf(0.99, alpha, beta), 100)
>>> ax.plot(x, levy_stable.pdf(x, alpha, beta),
...        'r-', lw=5, alpha=0.6, label='levy_stable pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = levy_stable(alpha, beta)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = levy_stable.ppf([0.001, 0.5, 0.999], alpha, beta)
>>> np.allclose([0.001, 0.5, 0.999], levy_stable.cdf(vals, alpha, beta))
True

Generate random numbers:

>>> r = levy_stable.rvs(alpha, beta, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

linregress:
Firma: (x, y=None, alternative='two-sided')

Docstring:
Calculate a linear least-squares regression for two sets of measurements.

Parameters
----------
x, y : array_like
    Two sets of measurements.  Both arrays should have the same length N.  If
    only `x` is given (and ``y=None``), then it must be a two-dimensional
    array where one dimension has length 2.  The two sets of measurements
    are then found by splitting the array along the length-2 dimension. In
    the case where ``y=None`` and `x` is a 2xN array, ``linregress(x)`` is
    equivalent to ``linregress(x[0], x[1])``.

    .. deprecated:: 1.14.0
        Inference of the two sets of measurements from a single argument `x`
        is deprecated will result in an error in SciPy 1.16.0; the sets
        must be specified separately as `x` and `y`.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the slope of the regression line is nonzero
    * 'less': the slope of the regression line is less than zero
    * 'greater':  the slope of the regression line is greater than zero

    .. versionadded:: 1.7.0

Returns
-------
result : ``LinregressResult`` instance
    The return value is an object with the following attributes:

    slope : float
        Slope of the regression line.
    intercept : float
        Intercept of the regression line.
    rvalue : float
        The Pearson correlation coefficient. The square of ``rvalue``
        is equal to the coefficient of determination.
    pvalue : float
        The p-value for a hypothesis test whose null hypothesis is
        that the slope is zero, using Wald Test with t-distribution of
        the test statistic. See `alternative` above for alternative
        hypotheses.
    stderr : float
        Standard error of the estimated slope (gradient), under the
        assumption of residual normality.
    intercept_stderr : float
        Standard error of the estimated intercept, under the assumption
        of residual normality.

See Also
--------
scipy.optimize.curve_fit :
    Use non-linear least squares to fit a function to data.
scipy.optimize.leastsq :
    Minimize the sum of squares of a set of equations.

Notes
-----
For compatibility with older versions of SciPy, the return value acts
like a ``namedtuple`` of length 5, with fields ``slope``, ``intercept``,
``rvalue``, ``pvalue`` and ``stderr``, so one can continue to write::

    slope, intercept, r, p, se = linregress(x, y)

With that style, however, the standard error of the intercept is not
available.  To have access to all the computed values, including the
standard error of the intercept, use the return value as an object
with attributes, e.g.::

    result = linregress(x, y)
    print(result.intercept, result.intercept_stderr)

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> rng = np.random.default_rng()

Generate some data:

>>> x = rng.random(10)
>>> y = 1.6*x + rng.random(10)

Perform the linear regression:

>>> res = stats.linregress(x, y)

Coefficient of determination (R-squared):

>>> print(f"R-squared: {res.rvalue**2:.6f}")
R-squared: 0.717533

Plot the data along with the fitted line:

>>> plt.plot(x, y, 'o', label='original data')
>>> plt.plot(x, res.intercept + res.slope*x, 'r', label='fitted line')
>>> plt.legend()
>>> plt.show()

Calculate 95% confidence interval on slope and intercept:

>>> # Two-sided inverse Students t-distribution
>>> # p - probability, df - degrees of freedom
>>> from scipy.stats import t
>>> tinv = lambda p, df: abs(t.ppf(p/2, df))

>>> ts = tinv(0.05, len(x)-2)
>>> print(f"slope (95%): {res.slope:.6f} +/- {ts*res.stderr:.6f}")
slope (95%): 1.453392 +/- 0.743465
>>> print(f"intercept (95%): {res.intercept:.6f}"
...       f" +/- {ts*res.intercept_stderr:.6f}")
intercept (95%): 0.616950 +/- 0.544475
================================================================================

lmoment:
Firma: (sample, order=None, *, axis=0, sorted=False, standardize=True, nan_policy='propagate', keepdims=False)

Docstring:
Compute L-moments of a sample from a continuous distribution

The L-moments of a probability distribution are summary statistics with
uses similar to those of conventional moments, but they are defined in
terms of the expected values of order statistics.
Sample L-moments are defined analogously to population L-moments, and
they can serve as estimators of population L-moments. They tend to be less
sensitive to extreme observations than conventional moments.

Parameters
----------
sample : array_like
    The real-valued sample whose L-moments are desired.
order : array_like, optional
    The (positive integer) orders of the desired L-moments.
    Must be a scalar or non-empty 1D array. Default is [1, 2, 3, 4].
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
sorted : bool, default=False
    Whether `sample` is already sorted in increasing order along `axis`.
    If False (default), `sample` will be sorted.
standardize : bool, default=True
    Whether to return L-moment ratios for orders 3 and higher.
    L-moment ratios are analogous to standardized conventional
    moments: they are the non-standardized L-moments divided
    by the L-moment of order 2.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
lmoments : ndarray
    The sample L-moments of order `order`.

See Also
--------

:func:`moment`
    ..

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] D. Bilkova. "L-Moments and TL-Moments as an Alternative Tool of
       Statistical Data Analysis". Journal of Applied Mathematics and
       Physics. 2014. :doi:`10.4236/jamp.2014.210104`
.. [2] J. R. M. Hosking. "L-Moments: Analysis and Estimation of Distributions
       Using Linear Combinations of Order Statistics". Journal of the Royal
       Statistical Society. 1990. :doi:`10.1111/j.2517-6161.1990.tb01775.x`
.. [3] "L-moment". *Wikipedia*. https://en.wikipedia.org/wiki/L-moment.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng(328458568356392)
>>> sample = rng.exponential(size=100000)
>>> stats.lmoment(sample)
array([1.00124272, 0.50111437, 0.3340092 , 0.16755338])

Note that the first four standardized population L-moments of the standard
exponential distribution are 1, 1/2, 1/3, and 1/6; the sample L-moments
provide reasonable estimates.
================================================================================

log:
Firma: (X, /)

Docstring:
Natural logarithm of a non-negative random variable

Parameters
----------
X : `ContinuousDistribution`
    The random variable :math:`X` with positive support.

Returns
-------
Y : `ContinuousDistribution`
    A random variable :math:`Y = \exp(X)`.

Examples
--------
Suppose we have a gamma distributed random variable :math:`X`:

>>> import numpy as np
>>> from scipy import stats
>>> Gamma = stats.make_distribution(stats.gamma)
>>> X = Gamma(a=1.0)

We wish to have a exp-gamma distributed random variable :math:`Y`,
a random variable whose natural exponential is :math:`X`.
If :math:`X` is to be the natural exponential of :math:`Y`, then we
must take :math:`Y` to be the natural logarithm of :math:`X`.

>>> Y = stats.log(X)

To demonstrate that ``X`` represents the exponential of ``Y``,
we plot a normalized histogram of the exponential of observations of
``Y`` against the PDF underlying ``X``.

>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng(435383595582522)
>>> y = Y.sample(shape=10000, rng=rng)
>>> ax = plt.gca()
>>> ax.hist(np.exp(y), bins=50, density=True)
>>> X.plot(ax=ax)
>>> plt.legend(('PDF of `X`', 'histogram of `exp(y)`'))
>>> plt.show()
================================================================================

loggamma:
Firma: (*args, **kwds)

Docstring:
A log gamma continuous random variable.

As an instance of the `rv_continuous` class, `loggamma` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `loggamma` is:

.. math::

    f(x, c) = \frac{\exp(c x - \exp(x))}
                   {\Gamma(c)}

for all :math:`x, c > 0`. Here, :math:`\Gamma` is the
gamma function (`scipy.special.gamma`).

`loggamma` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``loggamma.pdf(x, c, loc, scale)`` is identically
equivalent to ``loggamma.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import loggamma
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.414
>>> mean, var, skew, kurt = loggamma.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(loggamma.ppf(0.01, c),
...                 loggamma.ppf(0.99, c), 100)
>>> ax.plot(x, loggamma.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='loggamma pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = loggamma(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = loggamma.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], loggamma.cdf(vals, c))
True

Generate random numbers:

>>> r = loggamma.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

logistic:
Firma: (*args, **kwds)

Docstring:
A logistic (or Sech-squared) continuous random variable.

As an instance of the `rv_continuous` class, `logistic` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `logistic` is:

.. math::

    f(x) = \frac{\exp(-x)}
                {(1+\exp(-x))^2}

`logistic` is a special case of `genlogistic` with ``c=1``.

Remark that the survival function (``logistic.sf``) is equal to the
Fermi-Dirac distribution describing fermionic statistics.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``logistic.pdf(x, loc, scale)`` is identically
equivalent to ``logistic.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import logistic
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = logistic.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(logistic.ppf(0.01),
...                 logistic.ppf(0.99), 100)
>>> ax.plot(x, logistic.pdf(x),
...        'r-', lw=5, alpha=0.6, label='logistic pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = logistic()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = logistic.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], logistic.cdf(vals))
True

Generate random numbers:

>>> r = logistic.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

loglaplace:
Firma: (*args, **kwds)

Docstring:
A log-Laplace continuous random variable.

As an instance of the `rv_continuous` class, `loglaplace` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `loglaplace` is:

.. math::

    f(x, c) = \begin{cases}\frac{c}{2} x^{ c-1}  &\text{for } 0 < x < 1\\
                           \frac{c}{2} x^{-c-1}  &\text{for } x \ge 1
              \end{cases}

for :math:`c > 0`.

`loglaplace` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``loglaplace.pdf(x, c, loc, scale)`` is identically
equivalent to ``loglaplace.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Suppose a random variable ``X`` follows the Laplace distribution with
location ``a`` and scale ``b``.  Then ``Y = exp(X)`` follows the
log-Laplace distribution with ``c = 1 / b`` and ``scale = exp(a)``.

References
----------
T.J. Kozubowski and K. Podgorski, "A log-Laplace growth rate model",
The Mathematical Scientist, vol. 28, pp. 49-60, 2003.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import loglaplace
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 3.25
>>> mean, var, skew, kurt = loglaplace.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(loglaplace.ppf(0.01, c),
...                 loglaplace.ppf(0.99, c), 100)
>>> ax.plot(x, loglaplace.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='loglaplace pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = loglaplace(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = loglaplace.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], loglaplace.cdf(vals, c))
True

Generate random numbers:

>>> r = loglaplace.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

lognorm:
Firma: (*args, **kwds)

Docstring:
A lognormal continuous random variable.

As an instance of the `rv_continuous` class, `lognorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(s, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, s, loc=0, scale=1)
    Probability density function.
logpdf(x, s, loc=0, scale=1)
    Log of the probability density function.
cdf(x, s, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, s, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, s, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, s, loc=0, scale=1)
    Log of the survival function.
ppf(q, s, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, s, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, s, loc=0, scale=1)
    Non-central moment of the specified order.
stats(s, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(s, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(s,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(s, loc=0, scale=1)
    Median of the distribution.
mean(s, loc=0, scale=1)
    Mean of the distribution.
var(s, loc=0, scale=1)
    Variance of the distribution.
std(s, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, s, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `lognorm` is:

.. math::

    f(x, s) = \frac{1}{s x \sqrt{2\pi}}
              \exp\left(-\frac{\log^2(x)}{2s^2}\right)

for :math:`x > 0`, :math:`s > 0`.

`lognorm` takes ``s`` as a shape parameter for :math:`s`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``lognorm.pdf(x, s, loc, scale)`` is identically
equivalent to ``lognorm.pdf(y, s) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Suppose a normally distributed random variable ``X`` has  mean ``mu`` and
standard deviation ``sigma``. Then ``Y = exp(X)`` is lognormally
distributed with ``s = sigma`` and ``scale = exp(mu)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import lognorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> s = 0.954
>>> mean, var, skew, kurt = lognorm.stats(s, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(lognorm.ppf(0.01, s),
...                 lognorm.ppf(0.99, s), 100)
>>> ax.plot(x, lognorm.pdf(x, s),
...        'r-', lw=5, alpha=0.6, label='lognorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = lognorm(s)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = lognorm.ppf([0.001, 0.5, 0.999], s)
>>> np.allclose([0.001, 0.5, 0.999], lognorm.cdf(vals, s))
True

Generate random numbers:

>>> r = lognorm.rvs(s, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


The logarithm of a log-normally distributed random variable is
normally distributed:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> fig, ax = plt.subplots(1, 1)
>>> mu, sigma = 2, 0.5
>>> X = stats.norm(loc=mu, scale=sigma)
>>> Y = stats.lognorm(s=sigma, scale=np.exp(mu))
>>> x = np.linspace(*X.interval(0.999))
>>> y = Y.rvs(size=10000)
>>> ax.plot(x, X.pdf(x), label='X (pdf)')
>>> ax.hist(np.log(y), density=True, bins=x, label='log(Y) (histogram)')
>>> ax.legend()
>>> plt.show()
================================================================================

logrank:
Firma: (x: 'npt.ArrayLike | CensoredData', y: 'npt.ArrayLike | CensoredData', alternative: Literal['two-sided', 'less', 'greater'] = 'two-sided') -> scipy.stats._survival.LogRankResult

Docstring:
Compare the survival distributions of two samples via the logrank test.

Parameters
----------
x, y : array_like or CensoredData
    Samples to compare based on their empirical survival functions.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.

    The null hypothesis is that the survival distributions of the two
    groups, say *X* and *Y*, are identical.

    The following alternative hypotheses [4]_ are available (default is
    'two-sided'):

    * 'two-sided': the survival distributions of the two groups are not
      identical.
    * 'less': survival of group *X* is favored: the group *X* failure rate
      function is less than the group *Y* failure rate function at some
      times.
    * 'greater': survival of group *Y* is favored: the group *X* failure
      rate function is greater than the group *Y* failure rate function at
      some times.

Returns
-------
res : `~scipy.stats._result_classes.LogRankResult`
    An object containing attributes:

    statistic : float ndarray
        The computed statistic (defined below). Its magnitude is the
        square root of the magnitude returned by most other logrank test
        implementations.
    pvalue : float ndarray
        The computed p-value of the test.

See Also
--------
scipy.stats.ecdf

Notes
-----
The logrank test [1]_ compares the observed number of events to
the expected number of events under the null hypothesis that the two
samples were drawn from the same distribution. The statistic is

.. math::

    Z_i = \frac{\sum_{j=1}^J(O_{i,j}-E_{i,j})}{\sqrt{\sum_{j=1}^J V_{i,j}}}
    \rightarrow \mathcal{N}(0,1)

where

.. math::

    E_{i,j} = O_j \frac{N_{i,j}}{N_j},
    \qquad
    V_{i,j} = E_{i,j} \left(\frac{N_j-O_j}{N_j}\right)
    \left(\frac{N_j-N_{i,j}}{N_j-1}\right),

:math:`i` denotes the group (i.e. it may assume values :math:`x` or
:math:`y`, or it may be omitted to refer to the combined sample)
:math:`j` denotes the time (at which an event occurred),
:math:`N` is the number of subjects at risk just before an event occurred,
and :math:`O` is the observed number of events at that time.

The ``statistic`` :math:`Z_x` returned by `logrank` is the (signed) square
root of the statistic returned by many other implementations. Under the
null hypothesis, :math:`Z_x**2` is asymptotically distributed according to
the chi-squared distribution with one degree of freedom. Consequently,
:math:`Z_x` is asymptotically distributed according to the standard normal
distribution. The advantage of using :math:`Z_x` is that the sign
information (i.e. whether the observed number of events tends to be less
than or greater than the number expected under the null hypothesis) is
preserved, allowing `scipy.stats.logrank` to offer one-sided alternative
hypotheses.

References
----------
.. [1] Mantel N. "Evaluation of survival data and two new rank order
       statistics arising in its consideration."
       Cancer Chemotherapy Reports, 50(3):163-170, PMID: 5910392, 1966
.. [2] Bland, Altman, "The logrank test", BMJ, 328:1073,
       :doi:`10.1136/bmj.328.7447.1073`, 2004
.. [3] "Logrank test", Wikipedia,
       https://en.wikipedia.org/wiki/Logrank_test
.. [4] Brown, Mark. "On the choice of variance for the log rank test."
       Biometrika 71.1 (1984): 65-74.
.. [5] Klein, John P., and Melvin L. Moeschberger. Survival analysis:
       techniques for censored and truncated data. Vol. 1230. New York:
       Springer, 2003.

Examples
--------
Reference [2]_ compared the survival times of patients with two different
types of recurrent malignant gliomas. The samples below record the time
(number of weeks) for which each patient participated in the study. The
`scipy.stats.CensoredData` class is used because the data is
right-censored: the uncensored observations correspond with observed deaths
whereas the censored observations correspond with the patient leaving the
study for another reason.

>>> from scipy import stats
>>> x = stats.CensoredData(
...     uncensored=[6, 13, 21, 30, 37, 38, 49, 50,
...                 63, 79, 86, 98, 202, 219],
...     right=[31, 47, 80, 82, 82, 149]
... )
>>> y = stats.CensoredData(
...     uncensored=[10, 10, 12, 13, 14, 15, 16, 17, 18, 20, 24, 24,
...                 25, 28,30, 33, 35, 37, 40, 40, 46, 48, 76, 81,
...                 82, 91, 112, 181],
...     right=[34, 40, 70]
... )

We can calculate and visualize the empirical survival functions
of both groups as follows.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> ax = plt.subplot()
>>> ecdf_x = stats.ecdf(x)
>>> ecdf_x.sf.plot(ax, label='Astrocytoma')
>>> ecdf_y = stats.ecdf(y)
>>> ecdf_y.sf.plot(ax, label='Glioblastoma')
>>> ax.set_xlabel('Time to death (weeks)')
>>> ax.set_ylabel('Empirical SF')
>>> plt.legend()
>>> plt.show()

Visual inspection of the empirical survival functions suggests that the
survival times tend to be different between the two groups. To formally
assess whether the difference is significant at the 1% level, we use the
logrank test.

>>> res = stats.logrank(x=x, y=y)
>>> res.statistic
-2.73799
>>> res.pvalue
0.00618

The p-value is less than 1%, so we can consider the data to be evidence
against the null hypothesis in favor of the alternative that there is a
difference between the two survival functions.
================================================================================

logser:
Firma: (*args, **kwds)

Docstring:
A Logarithmic (Log-Series, Series) discrete random variable.

As an instance of the `rv_discrete` class, `logser` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, p, loc=0)
    Probability mass function.
logpmf(k, p, loc=0)
    Log of the probability mass function.
cdf(k, p, loc=0)
    Cumulative distribution function.
logcdf(k, p, loc=0)
    Log of the cumulative distribution function.
sf(k, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, p, loc=0)
    Log of the survival function.
ppf(q, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(p,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, loc=0)
    Median of the distribution.
mean(p, loc=0)
    Mean of the distribution.
var(p, loc=0)
    Variance of the distribution.
std(p, loc=0)
    Standard deviation of the distribution.
interval(confidence, p, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `logser` is:

.. math::

    f(k) = - \frac{p^k}{k \log(1-p)}

for :math:`k \ge 1`, :math:`0 < p < 1`

`logser` takes :math:`p` as shape parameter,
where :math:`p` is the probability of a single success
and :math:`1-p` is the probability of a single failure.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``logser.pmf(k, p, loc)`` is identically
equivalent to ``logser.pmf(k - loc, p)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import logser
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p = 0.6
>>> mean, var, skew, kurt = logser.stats(p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(logser.ppf(0.01, p),
...               logser.ppf(0.99, p))
>>> ax.plot(x, logser.pmf(x, p), 'bo', ms=8, label='logser pmf')
>>> ax.vlines(x, 0, logser.pmf(x, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = logser(p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = logser.cdf(x, p)
>>> np.allclose(x, logser.ppf(prob, p))
True

Generate random numbers:

>>> r = logser.rvs(p, size=1000)
================================================================================

loguniform:
Firma: (*args, **kwds)

Docstring:
A loguniform or reciprocal continuous random variable.

As an instance of the `rv_continuous` class, `loguniform` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for this class is:

.. math::

    f(x, a, b) = \frac{1}{x \log(b/a)}

for :math:`a \le x \le b`, :math:`b > a > 0`. This class takes
:math:`a` and :math:`b` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``loguniform.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``loguniform.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import loguniform
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 0.01, 1.25
>>> mean, var, skew, kurt = loguniform.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(loguniform.ppf(0.01, a, b),
...                 loguniform.ppf(0.99, a, b), 100)
>>> ax.plot(x, loguniform.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='loguniform pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = loguniform(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = loguniform.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], loguniform.cdf(vals, a, b))
True

Generate random numbers:

>>> r = loguniform.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


This doesn't show the equal probability of ``0.01``, ``0.1`` and
``1``. This is best when the x-axis is log-scaled:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)
>>> ax.hist(np.log10(r))
>>> ax.set_ylabel("Frequency")
>>> ax.set_xlabel("Value of random variable")
>>> ax.xaxis.set_major_locator(plt.FixedLocator([-2, -1, 0]))
>>> ticks = ["$10^{{ {} }}$".format(i) for i in [-2, -1, 0]]
>>> ax.set_xticklabels(ticks)  # doctest: +SKIP
>>> plt.show()

This random variable will be log-uniform regardless of the base chosen for
``a`` and ``b``. Let's specify with base ``2`` instead:

>>> rvs = loguniform(2**-2, 2**0).rvs(size=1000)

Values of ``1/4``, ``1/2`` and ``1`` are equally likely with this random
variable.  Here's the histogram:

>>> fig, ax = plt.subplots(1, 1)
>>> ax.hist(np.log2(rvs))
>>> ax.set_ylabel("Frequency")
>>> ax.set_xlabel("Value of random variable")
>>> ax.xaxis.set_major_locator(plt.FixedLocator([-2, -1, 0]))
>>> ticks = ["$2^{{ {} }}$".format(i) for i in [-2, -1, 0]]
>>> ax.set_xticklabels(ticks)  # doctest: +SKIP
>>> plt.show()
================================================================================

lomax:
Firma: (*args, **kwds)

Docstring:
A Lomax (Pareto of the second kind) continuous random variable.

As an instance of the `rv_continuous` class, `lomax` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `lomax` is:

.. math::

    f(x, c) = \frac{c}{(1+x)^{c+1}}

for :math:`x \ge 0`, :math:`c > 0`.

`lomax` takes ``c`` as a shape parameter for :math:`c`.

`lomax` is a special case of `pareto` with ``loc=-1.0``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``lomax.pdf(x, c, loc, scale)`` is identically
equivalent to ``lomax.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import lomax
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 1.88
>>> mean, var, skew, kurt = lomax.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(lomax.ppf(0.01, c),
...                 lomax.ppf(0.99, c), 100)
>>> ax.plot(x, lomax.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='lomax pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = lomax(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = lomax.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], lomax.cdf(vals, c))
True

Generate random numbers:

>>> r = lomax.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

make_distribution:
Firma: (dist)

Docstring:
Generate a `ContinuousDistribution` from an instance of `rv_continuous`

The returned value is a `ContinuousDistribution` subclass. Like any subclass
of `ContinuousDistribution`, it must be instantiated (i.e. by passing all shape
parameters as keyword arguments) before use. Once instantiated, the resulting
object will have the same interface as any other instance of
`ContinuousDistribution`; e.g., `scipy.stats.Normal`.

.. note::

    `make_distribution` does not work perfectly with all instances of
    `rv_continuous`. Known failures include `levy_stable` and `vonmises`,
    and some methods of some distributions will not support array shape
    parameters.

Parameters
----------
dist : `rv_continuous`
    Instance of `rv_continuous`.

Returns
-------
CustomDistribution : `ContinuousDistribution`
    A subclass of `ContinuousDistribution` corresponding with `dist`. The
    initializer requires all shape parameters to be passed as keyword arguments
    (using the same names as the instance of `rv_continuous`).

Notes
-----
The documentation of `ContinuousDistribution` is not rendered. See below for
an example of how to instantiate the class (i.e. pass all shape parameters of
`dist` to the initializer as keyword arguments). Documentation of all methods
is identical to that of `scipy.stats.Normal`. Use ``help`` on the returned
class or its methods for more information.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> LogU = stats.make_distribution(stats.loguniform)
>>> X = LogU(a=1.0, b=3.0)
>>> np.isclose((X + 0.25).median(), stats.loguniform.ppf(0.5, 1, 3, loc=0.25))
np.True_
>>> X.plot()
>>> sample = X.sample(10000, rng=np.random.default_rng())
>>> plt.hist(sample, density=True, bins=30)
>>> plt.legend(('pdf', 'histogram'))
>>> plt.show()
================================================================================

mannwhitneyu:
Firma: (x, y, use_continuity=True, alternative='two-sided', axis=0, method='auto', *, nan_policy='propagate', keepdims=False)

Docstring:
Perform the Mann-Whitney U rank test on two independent samples.

The Mann-Whitney U test is a nonparametric test of the null hypothesis
that the distribution underlying sample `x` is the same as the
distribution underlying sample `y`. It is often used as a test of
difference in location between distributions.

Parameters
----------
x, y : array-like
    N-d arrays of samples. The arrays must be broadcastable except along
    the dimension given by `axis`.
use_continuity : bool, optional
    Whether a continuity correction (1/2) should be applied.
    Default is True when `method` is ``'asymptotic'``; has no effect
    otherwise.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    Let *SX(u)* and *SY(u)* be the survival functions of the
    distributions underlying `x` and `y`, respectively. Then the following
    alternative hypotheses are available:
    
    * 'two-sided': the distributions are not equal, i.e. *SX(u) ≠ SY(u)* for
      at least one *u*.
    * 'less': the distribution underlying `x` is stochastically less
      than the distribution underlying `y`, i.e. *SX(u) < SY(u)* for all *u*.
    * 'greater': the distribution underlying `x` is stochastically greater
      than the distribution underlying `y`, i.e. *SX(u) > SY(u)* for all *u*.
    
    Under a more restrictive set of assumptions, the alternative hypotheses
    can be expressed in terms of the locations of the distributions;
    see [5]_ section 5.1.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
method : {'auto', 'asymptotic', 'exact'} or `PermutationMethod` instance, optional
    Selects the method used to calculate the *p*-value.
    Default is 'auto'. The following options are available.
    
    * ``'asymptotic'``: compares the standardized test statistic
      against the normal distribution, correcting for ties.
    * ``'exact'``: computes the exact *p*-value by comparing the observed
      :math:`U` statistic against the exact distribution of the :math:`U`
      statistic under the null hypothesis. No correction is made for ties.
    * ``'auto'``: chooses ``'exact'`` when the size of one of the samples
      is less than or equal to 8 and there are no ties;
      chooses ``'asymptotic'`` otherwise.
    * `PermutationMethod` instance. In this case, the p-value
      is computed using `permutation_test` with the provided
      configuration options and other appropriate settings.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : MannwhitneyuResult
    An object containing attributes:
    
    statistic : float
        The Mann-Whitney U statistic corresponding with sample `x`. See
        Notes for the test statistic corresponding with sample `y`.
    pvalue : float
        The associated *p*-value for the chosen `alternative`.

See Also
--------

:func:`scipy.stats.wilcoxon`, :func:`scipy.stats.ranksums`, :func:`scipy.stats.ttest_ind`
    ..

Notes
-----
If ``U1`` is the statistic corresponding with sample `x`, then the
statistic corresponding with sample `y` is
``U2 = x.shape[axis] * y.shape[axis] - U1``.

`mannwhitneyu` is for independent samples. For related / paired samples,
consider `scipy.stats.wilcoxon`.

`method` ``'exact'`` is recommended when there are no ties and when either
sample size is less than 8 [1]_. The implementation follows the algorithm
reported in [3]_.
Note that the exact method is *not* corrected for ties, but
`mannwhitneyu` will not raise errors or warnings if there are ties in the
data. If there are ties and either samples is small (fewer than ~10
observations), consider passing an instance of `PermutationMethod`
as the `method` to perform a permutation test.

The Mann-Whitney U test is a non-parametric version of the t-test for
independent samples. When the means of samples from the populations
are normally distributed, consider `scipy.stats.ttest_ind`.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] H.B. Mann and D.R. Whitney, "On a test of whether one of two random
       variables is stochastically larger than the other", The Annals of
       Mathematical Statistics, Vol. 18, pp. 50-60, 1947.
.. [2] Mann-Whitney U Test, Wikipedia,
       http://en.wikipedia.org/wiki/Mann-Whitney_U_test
.. [3] Andreas Löffler,
       "Über eine Partition der nat. Zahlen und ihr Anwendung beim U-Test",
       Wiss. Z. Univ. Halle, XXXII'83 pp. 87-89.
.. [4] Rosie Shier, "Statistics: 2.3 The Mann-Whitney U Test", Mathematics
       Learning Support Centre, 2004.
.. [5] Michael P. Fay and Michael A. Proschan. "Wilcoxon-Mann-Whitney
       or t-test? On assumptions for hypothesis tests and multiple \
       interpretations of decision rules." Statistics surveys, Vol. 4, pp.
       1-39, 2010. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2857732/

Examples
--------
We follow the example from [4]_: nine randomly sampled young adults were
diagnosed with type II diabetes at the ages below.

>>> males = [19, 22, 16, 29, 24]
>>> females = [20, 11, 17, 12]

We use the Mann-Whitney U test to assess whether there is a statistically
significant difference in the diagnosis age of males and females.
The null hypothesis is that the distribution of male diagnosis ages is
the same as the distribution of female diagnosis ages. We decide
that a confidence level of 95% is required to reject the null hypothesis
in favor of the alternative that the distributions are different.
Since the number of samples is very small and there are no ties in the
data, we can compare the observed test statistic against the *exact*
distribution of the test statistic under the null hypothesis.

>>> from scipy.stats import mannwhitneyu
>>> U1, p = mannwhitneyu(males, females, method="exact")
>>> print(U1)
17.0

`mannwhitneyu` always reports the statistic associated with the first
sample, which, in this case, is males. This agrees with :math:`U_M = 17`
reported in [4]_. The statistic associated with the second statistic
can be calculated:

>>> nx, ny = len(males), len(females)
>>> U2 = nx*ny - U1
>>> print(U2)
3.0

This agrees with :math:`U_F = 3` reported in [4]_. The two-sided
*p*-value can be calculated from either statistic, and the value produced
by `mannwhitneyu` agrees with :math:`p = 0.11` reported in [4]_.

>>> print(p)
0.1111111111111111

The exact distribution of the test statistic is asymptotically normal, so
the example continues by comparing the exact *p*-value against the
*p*-value produced using the normal approximation.

>>> _, pnorm = mannwhitneyu(males, females, method="asymptotic")
>>> print(pnorm)
0.11134688653314041

Here `mannwhitneyu`'s reported *p*-value appears to conflict with the
value :math:`p = 0.09` given in [4]_. The reason is that [4]_
does not apply the continuity correction performed by `mannwhitneyu`;
`mannwhitneyu` reduces the distance between the test statistic and the
mean :math:`\mu = n_x n_y / 2` by 0.5 to correct for the fact that the
discrete statistic is being compared against a continuous distribution.
Here, the :math:`U` statistic used is less than the mean, so we reduce
the distance by adding 0.5 in the numerator.

>>> import numpy as np
>>> from scipy.stats import norm
>>> U = min(U1, U2)
>>> N = nx + ny
>>> z = (U - nx*ny/2 + 0.5) / np.sqrt(nx*ny * (N + 1)/ 12)
>>> p = 2 * norm.cdf(z)  # use CDF to get p-value from smaller statistic
>>> print(p)
0.11134688653314041

If desired, we can disable the continuity correction to get a result
that agrees with that reported in [4]_.

>>> _, pnorm = mannwhitneyu(males, females, use_continuity=False,
...                         method="asymptotic")
>>> print(pnorm)
0.0864107329737

Regardless of whether we perform an exact or asymptotic test, the
probability of the test statistic being as extreme or more extreme by
chance exceeds 5%, so we do not consider the results statistically
significant.

Suppose that, before seeing the data, we had hypothesized that females
would tend to be diagnosed at a younger age than males.
In that case, it would be natural to provide the female ages as the
first input, and we would have performed a one-sided test using
``alternative = 'less'``: females are diagnosed at an age that is
stochastically less than that of males.

>>> res = mannwhitneyu(females, males, alternative="less", method="exact")
>>> print(res)
MannwhitneyuResult(statistic=3.0, pvalue=0.05555555555555555)

Again, the probability of getting a sufficiently low value of the
test statistic by chance under the null hypothesis is greater than 5%,
so we do not reject the null hypothesis in favor of our alternative.

If it is reasonable to assume that the means of samples from the
populations are normally distributed, we could have used a t-test to
perform the analysis.

>>> from scipy.stats import ttest_ind
>>> res = ttest_ind(females, males, alternative="less")
>>> print(res)
TtestResult(statistic=-2.239334696520584,
            pvalue=0.030068441095757924,
            df=7.0)

Under this assumption, the *p*-value would be low enough to reject the
null hypothesis in favor of the alternative.
================================================================================

matrix_normal:
Firma: (mean=None, rowcov=1, colcov=1, seed=None)

Docstring:
A matrix normal random variable.

The `mean` keyword specifies the mean. The `rowcov` keyword specifies the
among-row covariance matrix. The 'colcov' keyword specifies the
among-column covariance matrix.

Methods
-------
pdf(X, mean=None, rowcov=1, colcov=1)
    Probability density function.
logpdf(X, mean=None, rowcov=1, colcov=1)
    Log of the probability density function.
rvs(mean=None, rowcov=1, colcov=1, size=1, random_state=None)
    Draw random samples.
entropy(rowcol=1, colcov=1)
    Differential entropy.

Parameters
----------
mean : array_like, optional
    Mean of the distribution (default: `None`)
rowcov : array_like, optional
    Among-row covariance matrix of the distribution (default: ``1``)
colcov : array_like, optional
    Among-column covariance matrix of the distribution (default: ``1``)
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
If `mean` is set to `None` then a matrix of zeros is used for the mean.
The dimensions of this matrix are inferred from the shape of `rowcov` and
`colcov`, if these are provided, or set to ``1`` if ambiguous.

`rowcov` and `colcov` can be two-dimensional array_likes specifying the
covariance matrices directly. Alternatively, a one-dimensional array will
be be interpreted as the entries of a diagonal matrix, and a scalar or
zero-dimensional array will be interpreted as this value times the
identity matrix.

The covariance matrices specified by `rowcov` and `colcov` must be
(symmetric) positive definite. If the samples in `X` are
:math:`m \times n`, then `rowcov` must be :math:`m \times m` and
`colcov` must be :math:`n \times n`. `mean` must be the same shape as `X`.

The probability density function for `matrix_normal` is

.. math::

    f(X) = (2 \pi)^{-\frac{mn}{2}}|U|^{-\frac{n}{2}} |V|^{-\frac{m}{2}}
           \exp\left( -\frac{1}{2} \mathrm{Tr}\left[ U^{-1} (X-M) V^{-1}
           (X-M)^T \right] \right),

where :math:`M` is the mean, :math:`U` the among-row covariance matrix,
:math:`V` the among-column covariance matrix.

The `allow_singular` behaviour of the `multivariate_normal`
distribution is not currently supported. Covariance matrices must be
full rank.

The `matrix_normal` distribution is closely related to the
`multivariate_normal` distribution. Specifically, :math:`\mathrm{Vec}(X)`
(the vector formed by concatenating the columns  of :math:`X`) has a
multivariate normal distribution with mean :math:`\mathrm{Vec}(M)`
and covariance :math:`V \otimes U` (where :math:`\otimes` is the Kronecker
product). Sampling and pdf evaluation are
:math:`\mathcal{O}(m^3 + n^3 + m^2 n + m n^2)` for the matrix normal, but
:math:`\mathcal{O}(m^3 n^3)` for the equivalent multivariate normal,
making this equivalent form algorithmically inefficient.

.. versionadded:: 0.17.0

Examples
--------

>>> import numpy as np
>>> from scipy.stats import matrix_normal

>>> M = np.arange(6).reshape(3,2); M
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> U = np.diag([1,2,3]); U
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
>>> V = 0.3*np.identity(2); V
array([[ 0.3,  0. ],
       [ 0. ,  0.3]])
>>> X = M + 0.1; X
array([[ 0.1,  1.1],
       [ 2.1,  3.1],
       [ 4.1,  5.1]])
>>> matrix_normal.pdf(X, mean=M, rowcov=U, colcov=V)
0.023410202050005054

>>> # Equivalent multivariate normal
>>> from scipy.stats import multivariate_normal
>>> vectorised_X = X.T.flatten()
>>> equiv_mean = M.T.flatten()
>>> equiv_cov = np.kron(V,U)
>>> multivariate_normal.pdf(vectorised_X, mean=equiv_mean, cov=equiv_cov)
0.023410202050005054

Alternatively, the object may be called (as a function) to fix the mean
and covariance parameters, returning a "frozen" matrix normal
random variable:

>>> rv = matrix_normal(mean=None, rowcov=1, colcov=1)
>>> # Frozen object with the same methods but holding the given
>>> # mean and covariance fixed.
================================================================================

maxwell:
Firma: (*args, **kwds)

Docstring:
A Maxwell continuous random variable.

As an instance of the `rv_continuous` class, `maxwell` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
A special case of a `chi` distribution,  with ``df=3``, ``loc=0.0``,
and given ``scale = a``, where ``a`` is the parameter used in the
Mathworld description [1]_.

The probability density function for `maxwell` is:

.. math::

    f(x) = \sqrt{2/\pi}x^2 \exp(-x^2/2)

for :math:`x >= 0`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``maxwell.pdf(x, loc, scale)`` is identically
equivalent to ``maxwell.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] http://mathworld.wolfram.com/MaxwellDistribution.html

Examples
--------
>>> import numpy as np
>>> from scipy.stats import maxwell
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = maxwell.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(maxwell.ppf(0.01),
...                 maxwell.ppf(0.99), 100)
>>> ax.plot(x, maxwell.pdf(x),
...        'r-', lw=5, alpha=0.6, label='maxwell pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = maxwell()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = maxwell.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], maxwell.cdf(vals))
True

Generate random numbers:

>>> r = maxwell.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

median_abs_deviation:
Firma: (x, axis=0, center=<function median at 0x00000255BB97C930>, scale=1.0, nan_policy='propagate')

Docstring:
Compute the median absolute deviation of the data along the given axis.

The median absolute deviation (MAD, [1]_) computes the median over the
absolute deviations from the median. It is a measure of dispersion
similar to the standard deviation but more robust to outliers [2]_.

The MAD of an empty array is ``np.nan``.

.. versionadded:: 1.5.0

Parameters
----------
x : array_like
    Input array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the range is computed. Default is 0. If None, compute
    the MAD over the entire array.
center : callable, optional
    A function that will return the central value. The default is to use
    np.median. Any user defined function used will need to have the
    function signature ``func(arr, axis)``.
scale : scalar or str, optional
    The numerical value of scale will be divided out of the final
    result. The default is 1.0. The string "normal" is also accepted,
    and results in `scale` being the inverse of the standard normal
    quantile function at 0.75, which is approximately 0.67449.
    Array-like scale is also allowed, as long as it broadcasts correctly
    to the output such that ``out / scale`` is a valid operation. The
    output dimensions depend on the input array, `x`, and the `axis`
    argument.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

Returns
-------
mad : scalar or ndarray
    If ``axis=None``, a scalar is returned. If the input contains
    integers or floats of smaller precision than ``np.float64``, then the
    output data-type is ``np.float64``. Otherwise, the output data-type is
    the same as that of the input.

See Also
--------
numpy.std, numpy.var, numpy.median, scipy.stats.iqr, scipy.stats.tmean,
scipy.stats.tstd, scipy.stats.tvar

Notes
-----
The `center` argument only affects the calculation of the central value
around which the MAD is calculated. That is, passing in ``center=np.mean``
will calculate the MAD around the mean - it will not calculate the *mean*
absolute deviation.

The input array may contain `inf`, but if `center` returns `inf`, the
corresponding MAD for that data will be `nan`.

References
----------
.. [1] "Median absolute deviation",
       https://en.wikipedia.org/wiki/Median_absolute_deviation
.. [2] "Robust measures of scale",
       https://en.wikipedia.org/wiki/Robust_measures_of_scale

Examples
--------
When comparing the behavior of `median_abs_deviation` with ``np.std``,
the latter is affected when we change a single value of an array to have an
outlier value while the MAD hardly changes:

>>> import numpy as np
>>> from scipy import stats
>>> x = stats.norm.rvs(size=100, scale=1, random_state=123456)
>>> x.std()
0.9973906394005013
>>> stats.median_abs_deviation(x)
0.82832610097857
>>> x[0] = 345.6
>>> x.std()
34.42304872314415
>>> stats.median_abs_deviation(x)
0.8323442311590675

Axis handling example:

>>> x = np.array([[10, 7, 4], [3, 2, 1]])
>>> x
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> stats.median_abs_deviation(x)
array([3.5, 2.5, 1.5])
>>> stats.median_abs_deviation(x, axis=None)
2.0

Scale normal example:

>>> x = stats.norm.rvs(size=1000000, scale=2, random_state=123456)
>>> stats.median_abs_deviation(x)
1.3487398527041636
>>> stats.median_abs_deviation(x, scale='normal')
1.9996446978061115
================================================================================

median_test:
Firma: (*samples, ties='below', correction=True, lambda_=1, nan_policy='propagate')

Docstring:
Perform a Mood's median test.

Test that two or more samples come from populations with the same median.

Let ``n = len(samples)`` be the number of samples.  The "grand median" of
all the data is computed, and a contingency table is formed by
classifying the values in each sample as being above or below the grand
median.  The contingency table, along with `correction` and `lambda_`,
are passed to `scipy.stats.chi2_contingency` to compute the test statistic
and p-value.

Parameters
----------
sample1, sample2, ... : array_like
    The set of samples.  There must be at least two samples.
    Each sample must be a one-dimensional sequence containing at least
    one value.  The samples are not required to have the same length.
ties : str, optional
    Determines how values equal to the grand median are classified in
    the contingency table.  The string must be one of::

        "below":
            Values equal to the grand median are counted as "below".
        "above":
            Values equal to the grand median are counted as "above".
        "ignore":
            Values equal to the grand median are not counted.

    The default is "below".
correction : bool, optional
    If True, *and* there are just two samples, apply Yates' correction
    for continuity when computing the test statistic associated with
    the contingency table.  Default is True.
lambda_ : float or str, optional
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family to be used instead.  See
    `power_divergence` for details.
    Default is 1 (Pearson's chi-squared statistic).
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
res : MedianTestResult
    An object containing attributes:

    statistic : float
        The test statistic.  The statistic that is returned is determined
        by `lambda_`.  The default is Pearson's chi-squared statistic.
    pvalue : float
        The p-value of the test.
    median : float
        The grand median.
    table : ndarray
        The contingency table.  The shape of the table is (2, n), where
        n is the number of samples.  The first row holds the counts of the
        values above the grand median, and the second row holds the counts
        of the values below the grand median.  The table allows further
        analysis with, for example, `scipy.stats.chi2_contingency`, or with
        `scipy.stats.fisher_exact` if there are two samples, without having
        to recompute the table.  If ``nan_policy`` is "propagate" and there
        are nans in the input, the return value for ``table`` is ``None``.

See Also
--------
kruskal : Compute the Kruskal-Wallis H-test for independent samples.
mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.

Notes
-----
.. versionadded:: 0.15.0

References
----------
.. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill
    (1950), pp. 394-399.
.. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).
    See Sections 8.12 and 10.15.

Examples
--------
A biologist runs an experiment in which there are three groups of plants.
Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.
Each plant produces a number of seeds.  The seed counts for each group
are::

    Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49
    Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99
    Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84

The following code applies Mood's median test to these samples.

>>> g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]
>>> g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]
>>> g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]
>>> from scipy.stats import median_test
>>> res = median_test(g1, g2, g3)

The median is

>>> res.median
34.0

and the contingency table is

>>> res.table
array([[ 5, 10,  7],
       [11,  5, 10]])

`p` is too large to conclude that the medians are not the same:

>>> res.pvalue
0.12609082774093244

The "G-test" can be performed by passing ``lambda_="log-likelihood"`` to
`median_test`.

>>> res = median_test(g1, g2, g3, lambda_="log-likelihood")
>>> res.pvalue
0.12224779737117837

The median occurs several times in the data, so we'll get a different
result if, for example, ``ties="above"`` is used:

>>> res = median_test(g1, g2, g3, ties="above")
>>> res.pvalue
0.063873276069553273

>>> res.table
array([[ 5, 11,  9],
       [11,  4,  8]])

This example demonstrates that if the data set is not large and there
are values equal to the median, the p-value can be sensitive to the
choice of `ties`.
================================================================================

mielke:
Firma: (*args, **kwds)

Docstring:
A Mielke Beta-Kappa / Dagum continuous random variable.

As an instance of the `rv_continuous` class, `mielke` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(k, s, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, k, s, loc=0, scale=1)
    Probability density function.
logpdf(x, k, s, loc=0, scale=1)
    Log of the probability density function.
cdf(x, k, s, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, k, s, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, k, s, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, k, s, loc=0, scale=1)
    Log of the survival function.
ppf(q, k, s, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, k, s, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, k, s, loc=0, scale=1)
    Non-central moment of the specified order.
stats(k, s, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(k, s, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(k, s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(k, s, loc=0, scale=1)
    Median of the distribution.
mean(k, s, loc=0, scale=1)
    Mean of the distribution.
var(k, s, loc=0, scale=1)
    Variance of the distribution.
std(k, s, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, k, s, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `mielke` is:

.. math::

    f(x, k, s) = \frac{k x^{k-1}}{(1+x^s)^{1+k/s}}

for :math:`x > 0` and :math:`k, s > 0`. The distribution is sometimes
called Dagum distribution ([2]_). It was already defined in [3]_, called
a Burr Type III distribution (`burr` with parameters ``c=s`` and
``d=k/s``).

`mielke` takes ``k`` and ``s`` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``mielke.pdf(x, k, s, loc, scale)`` is identically
equivalent to ``mielke.pdf(y, k, s) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Mielke, P.W., 1973 "Another Family of Distributions for Describing
       and Analyzing Precipitation Data." J. Appl. Meteor., 12, 275-280
.. [2] Dagum, C., 1977 "A new model for personal income distribution."
       Economie Appliquee, 33, 327-367.
.. [3] Burr, I. W. "Cumulative frequency functions", Annals of
       Mathematical Statistics, 13(2), pp 215-232 (1942).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import mielke
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> k, s = 10.4, 4.6
>>> mean, var, skew, kurt = mielke.stats(k, s, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(mielke.ppf(0.01, k, s),
...                 mielke.ppf(0.99, k, s), 100)
>>> ax.plot(x, mielke.pdf(x, k, s),
...        'r-', lw=5, alpha=0.6, label='mielke pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = mielke(k, s)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = mielke.ppf([0.001, 0.5, 0.999], k, s)
>>> np.allclose([0.001, 0.5, 0.999], mielke.cdf(vals, k, s))
True

Generate random numbers:

>>> r = mielke.rvs(k, s, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

mode:
Firma: (a, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Return an array of the modal (most common) value in the passed array.

If there is more than one such value, only one is returned.
The bin-count for the modal bins is also returned.

Parameters
----------
a : array_like
    Numeric, n-dimensional array of which to find mode(s).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
mode : ndarray
    Array of modal values.
count : ndarray
    Array of counts for each mode.

Notes
-----
The mode  is calculated using `numpy.unique`.
In NumPy versions 1.21 and after, all NaNs - even those with different
binary representations - are treated as equivalent and counted as separate
instances of the same value.

By convention, the mode of an empty array is NaN, and the associated count
is zero.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> a = np.array([[3, 0, 3, 7],
...               [3, 2, 6, 2],
...               [1, 7, 2, 8],
...               [3, 0, 6, 1],
...               [3, 2, 5, 5]])
>>> from scipy import stats
>>> stats.mode(a, keepdims=True)
ModeResult(mode=array([[3, 0, 6, 1]]), count=array([[4, 2, 2, 1]]))

To get mode of whole array, specify ``axis=None``:

>>> stats.mode(a, axis=None, keepdims=True)
ModeResult(mode=[[3]], count=[[5]])
>>> stats.mode(a, axis=None, keepdims=False)
ModeResult(mode=3, count=5)
================================================================================

moment:
Firma: (a, order=1, axis=0, nan_policy='propagate', *, center=None, keepdims=False)

Docstring:
Calculate the nth moment about the mean for a sample.

A moment is a specific quantitative measure of the shape of a set of
points. It is often used to calculate coefficients of skewness and kurtosis
due to its close relationship with them.

Parameters
----------
a : array_like
    Input array.
order : int or 1-D array_like of ints, optional
    Order of central moment that is returned. Default is 1.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
center : float or None, optional
    The point about which moments are taken. This can be the sample mean,
    the origin, or any other be point. If `None` (default) compute the
    center as the sample mean.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
n-th moment about the `center` : ndarray or float
    The appropriate moment along the given axis or over all values if axis
    is None. The denominator for the moment calculation is the number of
    observations, no degrees of freedom correction is done.

See Also
--------

:func:`kurtosis`, :func:`skew`, :func:`describe`
    ..

Notes
-----
The k-th moment of a data sample is:

.. math::

    m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - c)^k

Where `n` is the number of samples, and `c` is the center around which the
moment is calculated. This function uses exponentiation by squares [1]_ for
efficiency.

Note that, if `a` is an empty array (``a.size == 0``), array `moment` with
one element (`moment.size == 1`) is treated the same as scalar `moment`
(``np.isscalar(moment)``). This might produce arrays of unexpected shape.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms

Examples
--------
>>> from scipy.stats import moment
>>> moment([1, 2, 3, 4, 5], order=1)
0.0
>>> moment([1, 2, 3, 4, 5], order=2)
2.0
================================================================================

monte_carlo_test:
Firma: (data, rvs, statistic, *, vectorized=None, n_resamples=9999, batch=None, alternative='two-sided', axis=0)

Docstring:
Perform a Monte Carlo hypothesis test.

`data` contains a sample or a sequence of one or more samples. `rvs`
specifies the distribution(s) of the sample(s) in `data` under the null
hypothesis. The value of `statistic` for the given `data` is compared
against a Monte Carlo null distribution: the value of the statistic for
each of `n_resamples` sets of samples generated using `rvs`. This gives
the p-value, the probability of observing such an extreme value of the
test statistic under the null hypothesis.

Parameters
----------
data : array-like or sequence of array-like
    An array or sequence of arrays of observations.
rvs : callable or tuple of callables
    A callable or sequence of callables that generates random variates
    under the null hypothesis. Each element of `rvs` must be a callable
    that accepts keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and
    returns an N-d array sample of that shape. If `rvs` is a sequence, the
    number of callables in `rvs` must match the number of samples in
    `data`, i.e. ``len(rvs) == len(data)``. If `rvs` is a single callable,
    `data` is treated as a single sample.
statistic : callable
    Statistic for which the p-value of the hypothesis test is to be
    calculated. `statistic` must be a callable that accepts a sample
    (e.g. ``statistic(sample)``) or ``len(rvs)`` separate samples (e.g.
    ``statistic(samples1, sample2)`` if `rvs` contains two callables and
    `data` contains two samples) and returns the resulting statistic.
    If `vectorized` is set ``True``, `statistic` must also accept a keyword
    argument `axis` and be vectorized to compute the statistic along the
    provided `axis` of the samples in `data`.
vectorized : bool, optional
    If `vectorized` is set ``False``, `statistic` will not be passed
    keyword argument `axis` and is expected to calculate the statistic
    only for 1D samples. If ``True``, `statistic` will be passed keyword
    argument `axis` and is expected to calculate the statistic along `axis`
    when passed ND sample arrays. If ``None`` (default), `vectorized`
    will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of
    a vectorized statistic typically reduces computation time.
n_resamples : int, default: 9999
    Number of samples drawn from each of the callables of `rvs`.
    Equivalently, the number statistic values under the null hypothesis
    used as the Monte Carlo null distribution.
batch : int, optional
    The number of Monte Carlo samples to process in each call to
    `statistic`. Memory usage is O( `batch` * ``sample.size[axis]`` ). Default
    is ``None``, in which case `batch` equals `n_resamples`.
alternative : {'two-sided', 'less', 'greater'}
    The alternative hypothesis for which the p-value is calculated.
    For each alternative, the p-value is defined as follows.

    - ``'greater'`` : the percentage of the null distribution that is
      greater than or equal to the observed value of the test statistic.
    - ``'less'`` : the percentage of the null distribution that is
      less than or equal to the observed value of the test statistic.
    - ``'two-sided'`` : twice the smaller of the p-values above.

axis : int, default: 0
    The axis of `data` (or each sample within `data`) over which to
    calculate the statistic.

Returns
-------
res : MonteCarloTestResult
    An object with attributes:

    statistic : float or ndarray
        The test statistic of the observed `data`.
    pvalue : float or ndarray
        The p-value for the given alternative.
    null_distribution : ndarray
        The values of the test statistic generated under the null
        hypothesis.

.. warning::
    The p-value is calculated by counting the elements of the null
    distribution that are as extreme or more extreme than the observed
    value of the statistic. Due to the use of finite precision arithmetic,
    some statistic functions return numerically distinct values when the
    theoretical values would be exactly equal. In some cases, this could
    lead to a large error in the calculated p-value. `monte_carlo_test`
    guards against this by considering elements in the null distribution
    that are "close" (within a relative tolerance of 100 times the
    floating point epsilon of inexact dtypes) to the observed
    value of the test statistic as equal to the observed value of the
    test statistic. However, the user is advised to inspect the null
    distribution to assess whether this method of comparison is
    appropriate, and if not, calculate the p-value manually.

References
----------

.. [1] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
   Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
   Statistical Applications in Genetics and Molecular Biology 9.1 (2010).

Examples
--------

Suppose we wish to test whether a small sample has been drawn from a normal
distribution. We decide that we will use the skew of the sample as a
test statistic, and we will consider a p-value of 0.05 to be statistically
significant.

>>> import numpy as np
>>> from scipy import stats
>>> def statistic(x, axis):
...     return stats.skew(x, axis)

After collecting our data, we calculate the observed value of the test
statistic.

>>> rng = np.random.default_rng()
>>> x = stats.skewnorm.rvs(a=1, size=50, random_state=rng)
>>> statistic(x, axis=0)
0.12457412450240658

To determine the probability of observing such an extreme value of the
skewness by chance if the sample were drawn from the normal distribution,
we can perform a Monte Carlo hypothesis test. The test will draw many
samples at random from their normal distribution, calculate the skewness
of each sample, and compare our original skewness against this
distribution to determine an approximate p-value.

>>> from scipy.stats import monte_carlo_test
>>> # because our statistic is vectorized, we pass `vectorized=True`
>>> rvs = lambda size: stats.norm.rvs(size=size, random_state=rng)
>>> res = monte_carlo_test(x, rvs, statistic, vectorized=True)
>>> print(res.statistic)
0.12457412450240658
>>> print(res.pvalue)
0.7012

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is ~70%. This is greater than
our chosen threshold of 5%, so we cannot consider this to be significant
evidence against the null hypothesis.

Note that this p-value essentially matches that of
`scipy.stats.skewtest`, which relies on an asymptotic distribution of a
test statistic based on the sample skewness.

>>> stats.skewtest(x).pvalue
0.6892046027110614

This asymptotic approximation is not valid for small sample sizes, but
`monte_carlo_test` can be used with samples of any size.

>>> x = stats.skewnorm.rvs(a=1, size=7, random_state=rng)
>>> # stats.skewtest(x) would produce an error due to small sample
>>> res = monte_carlo_test(x, rvs, statistic, vectorized=True)

The Monte Carlo distribution of the test statistic is provided for
further investigation.

>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots()
>>> ax.hist(res.null_distribution, bins=50)
>>> ax.set_title("Monte Carlo distribution of test statistic")
>>> ax.set_xlabel("Value of Statistic")
>>> ax.set_ylabel("Frequency")
>>> plt.show()
================================================================================

mood:
Firma: (x, y, axis=0, alternative='two-sided', *, nan_policy='propagate', keepdims=False)

Docstring:
Perform Mood's test for equal scale parameters.

Mood's two-sample test for scale parameters is a non-parametric
test for the null hypothesis that two samples are drawn from the
same distribution with the same scale parameter.

Parameters
----------
x, y : array_like
    Arrays of sample data. There must be at least three observations
    total.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:
    
    * 'two-sided': the scales of the distributions underlying `x` and `y`
      are different.
    * 'less': the scale of the distribution underlying `x` is less than
      the scale of the distribution underlying `y`.
    * 'greater': the scale of the distribution underlying `x` is greater
      than the scale of the distribution underlying `y`.
    
    .. versionadded:: 1.7.0
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
res : SignificanceResult
    An object containing attributes:
    
    statistic : scalar or ndarray
        The z-score for the hypothesis test.  For 1-D inputs a scalar is
        returned.
    pvalue : scalar ndarray
        The p-value for the hypothesis test.

See Also
--------

:func:`fligner`
    A non-parametric test for the equality of k variances
:func:`ansari`
    A non-parametric test for the equality of 2 variances
:func:`bartlett`
    A parametric test for equality of k variances in normal samples
:func:`levene`
    A parametric test for equality of k variances


Notes
-----
The data are assumed to be drawn from probability distributions ``f(x)``
and ``f(x/s) / s`` respectively, for some probability density function f.
The null hypothesis is that ``s == 1``.

For multi-dimensional arrays, if the inputs are of shapes
``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the
resulting z and p values will have shape ``(n0, n2, n3)``.  Note that
``n1`` and ``m1`` don't have to be equal, but the other dimensions do.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
[1] Mielke, Paul W. "Note on Some Squared Rank Tests with Existing Ties."
    Technometrics, vol. 9, no. 2, 1967, pp. 312-14. JSTOR,
    https://doi.org/10.2307/1266427. Accessed 18 May 2022.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x2 = rng.standard_normal((2, 45, 6, 7))
>>> x1 = rng.standard_normal((2, 30, 6, 7))
>>> res = stats.mood(x1, x2, axis=1)
>>> res.pvalue.shape
(2, 6, 7)

Find the number of points where the difference in scale is not significant:

>>> (res.pvalue > 0.1).sum()
78

Perform the test with different scales:

>>> x1 = rng.standard_normal((2, 30))
>>> x2 = rng.standard_normal((2, 35)) * 10.0
>>> stats.mood(x1, x2, axis=1)
SignificanceResult(statistic=array([-5.76174136, -6.12650783]),
                   pvalue=array([8.32505043e-09, 8.98287869e-10]))
================================================================================

moyal:
Firma: (*args, **kwds)

Docstring:
A Moyal continuous random variable.

As an instance of the `rv_continuous` class, `moyal` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `moyal` is:

.. math::

    f(x) = \exp(-(x + \exp(-x))/2) / \sqrt{2\pi}

for a real number :math:`x`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``moyal.pdf(x, loc, scale)`` is identically
equivalent to ``moyal.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

This distribution has utility in high-energy physics and radiation
detection. It describes the energy loss of a charged relativistic
particle due to ionization of the medium [1]_. It also provides an
approximation for the Landau distribution. For an in depth description
see [2]_. For additional description, see [3]_.

References
----------
.. [1] J.E. Moyal, "XXX. Theory of ionization fluctuations",
       The London, Edinburgh, and Dublin Philosophical Magazine
       and Journal of Science, vol 46, 263-280, (1955).
       :doi:`10.1080/14786440308521076` (gated)
.. [2] G. Cordeiro et al., "The beta Moyal: a useful skew distribution",
       International Journal of Research and Reviews in Applied Sciences,
       vol 10, 171-192, (2012).
       http://www.arpapress.com/Volumes/Vol10Issue2/IJRRAS_10_2_02.pdf
.. [3] C. Walck, "Handbook on Statistical Distributions for
       Experimentalists; International Report SUF-PFY/96-01", Chapter 26,
       University of Stockholm: Stockholm, Sweden, (2007).
       http://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf

.. versionadded:: 1.1.0

Examples
--------
>>> import numpy as np
>>> from scipy.stats import moyal
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = moyal.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(moyal.ppf(0.01),
...                 moyal.ppf(0.99), 100)
>>> ax.plot(x, moyal.pdf(x),
...        'r-', lw=5, alpha=0.6, label='moyal pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = moyal()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = moyal.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], moyal.cdf(vals))
True

Generate random numbers:

>>> r = moyal.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

multinomial:
Firma: (n, p, seed=None)

Docstring:
A multinomial random variable.

Methods
-------
pmf(x, n, p)
    Probability mass function.
logpmf(x, n, p)
    Log of the probability mass function.
rvs(n, p, size=1, random_state=None)
    Draw random samples from a multinomial distribution.
entropy(n, p)
    Compute the entropy of the multinomial distribution.
cov(n, p)
    Compute the covariance matrix of the multinomial distribution.

Parameters
----------
n : int
    Number of trials
p : array_like
    Probability of a trial falling into each category; should sum to 1
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
`n` should be a nonnegative integer. Each element of `p` should be in the
interval :math:`[0,1]` and the elements should sum to 1. If they do not sum to
1, the last element of the `p` array is not used and is replaced with the
remaining probability left over from the earlier elements.

The probability mass function for `multinomial` is

.. math::

    f(x) = \frac{n!}{x_1! \cdots x_k!} p_1^{x_1} \cdots p_k^{x_k},

supported on :math:`x=(x_1, \ldots, x_k)` where each :math:`x_i` is a
nonnegative integer and their sum is :math:`n`.

.. versionadded:: 0.19.0

Examples
--------

>>> from scipy.stats import multinomial
>>> rv = multinomial(8, [0.3, 0.2, 0.5])
>>> rv.pmf([1, 3, 4])
0.042000000000000072

The multinomial distribution for :math:`k=2` is identical to the
corresponding binomial distribution (tiny numerical differences
notwithstanding):

>>> from scipy.stats import binom
>>> multinomial.pmf([3, 4], n=7, p=[0.4, 0.6])
0.29030399999999973
>>> binom.pmf(3, 7, 0.4)
0.29030400000000012

The functions ``pmf``, ``logpmf``, ``entropy``, and ``cov`` support
broadcasting, under the convention that the vector parameters (``x`` and
``p``) are interpreted as if each row along the last axis is a single
object. For instance:

>>> multinomial.pmf([[3, 4], [3, 5]], n=[7, 8], p=[.3, .7])
array([0.2268945,  0.25412184])

Here, ``x.shape == (2, 2)``, ``n.shape == (2,)``, and ``p.shape == (2,)``,
but following the rules mentioned above they behave as if the rows
``[3, 4]`` and ``[3, 5]`` in ``x`` and ``[.3, .7]`` in ``p`` were a single
object, and as if we had ``x.shape = (2,)``, ``n.shape = (2,)``, and
``p.shape = ()``. To obtain the individual elements without broadcasting,
we would do this:

>>> multinomial.pmf([3, 4], n=7, p=[.3, .7])
0.2268945
>>> multinomial.pmf([3, 5], 8, p=[.3, .7])
0.25412184

This broadcasting also works for ``cov``, where the output objects are
square matrices of size ``p.shape[-1]``. For example:

>>> multinomial.cov([4, 5], [[.3, .7], [.4, .6]])
array([[[ 0.84, -0.84],
        [-0.84,  0.84]],
       [[ 1.2 , -1.2 ],
        [-1.2 ,  1.2 ]]])

In this example, ``n.shape == (2,)`` and ``p.shape == (2, 2)``, and
following the rules above, these broadcast as if ``p.shape == (2,)``.
Thus the result should also be of shape ``(2,)``, but since each output is
a :math:`2 \times 2` matrix, the result in fact has shape ``(2, 2, 2)``,
where ``result[0]`` is equal to ``multinomial.cov(n=4, p=[.3, .7])`` and
``result[1]`` is equal to ``multinomial.cov(n=5, p=[.4, .6])``.

Alternatively, the object may be called (as a function) to fix the `n` and
`p` parameters, returning a "frozen" multinomial random variable:

>>> rv = multinomial(n=7, p=[.3, .7])
>>> # Frozen object with the same methods but holding the given
>>> # degrees of freedom and scale fixed.

See also
--------
scipy.stats.binom : The binomial distribution.
numpy.random.Generator.multinomial : Sampling from the multinomial distribution.
scipy.stats.multivariate_hypergeom :
    The multivariate hypergeometric distribution.
================================================================================

multiscale_graphcorr:
Firma: (x, y, compute_distance=<function _euclidean_dist at 0x00000255C3ABC2C0>, reps=1000, workers=1, is_twosamp=False, random_state=None)

Docstring:
Computes the Multiscale Graph Correlation (MGC) test statistic.

Specifically, for each point, MGC finds the :math:`k`-nearest neighbors for
one property (e.g. cloud density), and the :math:`l`-nearest neighbors for
the other property (e.g. grass wetness) [1]_. This pair :math:`(k, l)` is
called the "scale". A priori, however, it is not know which scales will be
most informative. So, MGC computes all distance pairs, and then efficiently
computes the distance correlations for all scales. The local correlations
illustrate which scales are relatively informative about the relationship.
The key, therefore, to successfully discover and decipher relationships
between disparate data modalities is to adaptively determine which scales
are the most informative, and the geometric implication for the most
informative scales. Doing so not only provides an estimate of whether the
modalities are related, but also provides insight into how the
determination was made. This is especially important in high-dimensional
data, where simple visualizations do not reveal relationships to the
unaided human eye. Characterizations of this implementation in particular
have been derived from and benchmarked within in [2]_.

Parameters
----------
x, y : ndarray
    If ``x`` and ``y`` have shapes ``(n, p)`` and ``(n, q)`` where `n` is
    the number of samples and `p` and `q` are the number of dimensions,
    then the MGC independence test will be run.  Alternatively, ``x`` and
    ``y`` can have shapes ``(n, n)`` if they are distance or similarity
    matrices, and ``compute_distance`` must be sent to ``None``. If ``x``
    and ``y`` have shapes ``(n, p)`` and ``(m, p)``, an unpaired
    two-sample MGC test will be run.
compute_distance : callable, optional
    A function that computes the distance or similarity among the samples
    within each data matrix. Set to ``None`` if ``x`` and ``y`` are
    already distance matrices. The default uses the euclidean norm metric.
    If you are calling a custom function, either create the distance
    matrix before-hand or create a function of the form
    ``compute_distance(x)`` where `x` is the data matrix for which
    pairwise distances are calculated.
reps : int, optional
    The number of replications used to estimate the null when using the
    permutation test. The default is ``1000``.
workers : int or map-like callable, optional
    If ``workers`` is an int the population is subdivided into ``workers``
    sections and evaluated in parallel (uses ``multiprocessing.Pool
    <multiprocessing>``). Supply ``-1`` to use all cores available to the
    Process. Alternatively supply a map-like callable, such as
    ``multiprocessing.Pool.map`` for evaluating the p-value in parallel.
    This evaluation is carried out as ``workers(func, iterable)``.
    Requires that `func` be pickleable. The default is ``1``.
is_twosamp : bool, optional
    If `True`, a two sample test will be run. If ``x`` and ``y`` have
    shapes ``(n, p)`` and ``(m, p)``, this optional will be overridden and
    set to ``True``. Set to ``True`` if ``x`` and ``y`` both have shapes
    ``(n, p)`` and a two sample test is desired. The default is ``False``.
    Note that this will not run if inputs are distance matrices.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

Returns
-------
res : MGCResult
    An object containing attributes:

    statistic : float
        The sample MGC test statistic within ``[-1, 1]``.
    pvalue : float
        The p-value obtained via permutation.
    mgc_dict : dict
        Contains additional useful results:

            - mgc_map : ndarray
                A 2D representation of the latent geometry of the
                relationship.
            - opt_scale : (int, int)
                The estimated optimal scale as a ``(x, y)`` pair.
            - null_dist : list
                The null distribution derived from the permuted matrices.

See Also
--------
pearsonr : Pearson correlation coefficient and p-value for testing
           non-correlation.
kendalltau : Calculates Kendall's tau.
spearmanr : Calculates a Spearman rank-order correlation coefficient.

Notes
-----
A description of the process of MGC and applications on neuroscience data
can be found in [1]_. It is performed using the following steps:

#. Two distance matrices :math:`D^X` and :math:`D^Y` are computed and
   modified to be mean zero columnwise. This results in two
   :math:`n \times n` distance matrices :math:`A` and :math:`B` (the
   centering and unbiased modification) [3]_.

#. For all values :math:`k` and :math:`l` from :math:`1, ..., n`,

   * The :math:`k`-nearest neighbor and :math:`l`-nearest neighbor graphs
     are calculated for each property. Here, :math:`G_k (i, j)` indicates
     the :math:`k`-smallest values of the :math:`i`-th row of :math:`A`
     and :math:`H_l (i, j)` indicates the :math:`l` smallested values of
     the :math:`i`-th row of :math:`B`

   * Let :math:`\circ` denotes the entry-wise matrix product, then local
     correlations are summed and normalized using the following statistic:

.. math::

    c^{kl} = \frac{\sum_{ij} A G_k B H_l}
                  {\sqrt{\sum_{ij} A^2 G_k \times \sum_{ij} B^2 H_l}}

#. The MGC test statistic is the smoothed optimal local correlation of
   :math:`\{ c^{kl} \}`. Denote the smoothing operation as :math:`R(\cdot)`
   (which essentially set all isolated large correlations) as 0 and
   connected large correlations the same as before, see [3]_.) MGC is,

.. math::

    MGC_n (x, y) = \max_{(k, l)} R \left(c^{kl} \left( x_n, y_n \right)
                                                \right)

The test statistic returns a value between :math:`(-1, 1)` since it is
normalized.

The p-value returned is calculated using a permutation test. This process
is completed by first randomly permuting :math:`y` to estimate the null
distribution and then calculating the probability of observing a test
statistic, under the null, at least as extreme as the observed test
statistic.

MGC requires at least 5 samples to run with reliable results. It can also
handle high-dimensional data sets.
In addition, by manipulating the input data matrices, the two-sample
testing problem can be reduced to the independence testing problem [4]_.
Given sample data :math:`U` and :math:`V` of sizes :math:`p \times n`
:math:`p \times m`, data matrix :math:`X` and :math:`Y` can be created as
follows:

.. math::

    X = [U | V] \in \mathcal{R}^{p \times (n + m)}
    Y = [0_{1 \times n} | 1_{1 \times m}] \in \mathcal{R}^{(n + m)}

Then, the MGC statistic can be calculated as normal. This methodology can
be extended to similar tests such as distance correlation [4]_.

.. versionadded:: 1.4.0

References
----------
.. [1] Vogelstein, J. T., Bridgeford, E. W., Wang, Q., Priebe, C. E.,
       Maggioni, M., & Shen, C. (2019). Discovering and deciphering
       relationships across disparate data modalities. ELife.
.. [2] Panda, S., Palaniappan, S., Xiong, J., Swaminathan, A.,
       Ramachandran, S., Bridgeford, E. W., ... Vogelstein, J. T. (2019).
       mgcpy: A Comprehensive High Dimensional Independence Testing Python
       Package. :arXiv:`1907.02088`
.. [3] Shen, C., Priebe, C.E., & Vogelstein, J. T. (2019). From distance
       correlation to multiscale graph correlation. Journal of the American
       Statistical Association.
.. [4] Shen, C. & Vogelstein, J. T. (2018). The Exact Equivalence of
       Distance and Kernel Methods for Hypothesis Testing.
       :arXiv:`1806.05514`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import multiscale_graphcorr
>>> x = np.arange(100)
>>> y = x
>>> res = multiscale_graphcorr(x, y)
>>> res.statistic, res.pvalue
(1.0, 0.001)

To run an unpaired two-sample test,

>>> x = np.arange(100)
>>> y = np.arange(79)
>>> res = multiscale_graphcorr(x, y)
>>> res.statistic, res.pvalue  # doctest: +SKIP
(0.033258146255703246, 0.023)

or, if shape of the inputs are the same,

>>> x = np.arange(100)
>>> y = x
>>> res = multiscale_graphcorr(x, y, is_twosamp=True)
>>> res.statistic, res.pvalue  # doctest: +SKIP
(-0.008021809890200488, 1.0)
================================================================================

multivariate_hypergeom:
Firma: (m, n, seed=None)

Docstring:
A multivariate hypergeometric random variable.

Methods
-------
pmf(x, m, n)
    Probability mass function.
logpmf(x, m, n)
    Log of the probability mass function.
rvs(m, n, size=1, random_state=None)
    Draw random samples from a multivariate hypergeometric
    distribution.
mean(m, n)
    Mean of the multivariate hypergeometric distribution.
var(m, n)
    Variance of the multivariate hypergeometric distribution.
cov(m, n)
    Compute the covariance matrix of the multivariate
    hypergeometric distribution.

Parameters
----------
m : array_like
    The number of each type of object in the population.
    That is, :math:`m[i]` is the number of objects of
    type :math:`i`.
n : array_like
    The number of samples taken from the population.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
`m` must be an array of positive integers. If the quantile
:math:`i` contains values out of the range :math:`[0, m_i]`
where :math:`m_i` is the number of objects of type :math:`i`
in the population or if the parameters are inconsistent with one
another (e.g. ``x.sum() != n``), methods return the appropriate
value (e.g. ``0`` for ``pmf``). If `m` or `n` contain negative
values, the result will contain ``nan`` there.

The probability mass function for `multivariate_hypergeom` is

.. math::

    P(X_1 = x_1, X_2 = x_2, \ldots, X_k = x_k) = \frac{\binom{m_1}{x_1}
    \binom{m_2}{x_2} \cdots \binom{m_k}{x_k}}{\binom{M}{n}}, \\ \quad
    (x_1, x_2, \ldots, x_k) \in \mathbb{N}^k \text{ with }
    \sum_{i=1}^k x_i = n

where :math:`m_i` are the number of objects of type :math:`i`, :math:`M`
is the total number of objects in the population (sum of all the
:math:`m_i`), and :math:`n` is the size of the sample to be taken
from the population.

.. versionadded:: 1.6.0

Examples
--------
To evaluate the probability mass function of the multivariate
hypergeometric distribution, with a dichotomous population of size
:math:`10` and :math:`20`, at a sample of size :math:`12` with
:math:`8` objects of the first type and :math:`4` objects of the
second type, use:

>>> from scipy.stats import multivariate_hypergeom
>>> multivariate_hypergeom.pmf(x=[8, 4], m=[10, 20], n=12)
0.0025207176631464523

The `multivariate_hypergeom` distribution is identical to the
corresponding `hypergeom` distribution (tiny numerical differences
notwithstanding) when only two types (good and bad) of objects
are present in the population as in the example above. Consider
another example for a comparison with the hypergeometric distribution:

>>> from scipy.stats import hypergeom
>>> multivariate_hypergeom.pmf(x=[3, 1], m=[10, 5], n=4)
0.4395604395604395
>>> hypergeom.pmf(k=3, M=15, n=4, N=10)
0.43956043956044005

The functions ``pmf``, ``logpmf``, ``mean``, ``var``, ``cov``, and ``rvs``
support broadcasting, under the convention that the vector parameters
(``x``, ``m``, and ``n``) are interpreted as if each row along the last
axis is a single object. For instance, we can combine the previous two
calls to `multivariate_hypergeom` as

>>> multivariate_hypergeom.pmf(x=[[8, 4], [3, 1]], m=[[10, 20], [10, 5]],
...                            n=[12, 4])
array([0.00252072, 0.43956044])

This broadcasting also works for ``cov``, where the output objects are
square matrices of size ``m.shape[-1]``. For example:

>>> multivariate_hypergeom.cov(m=[[7, 9], [10, 15]], n=[8, 12])
array([[[ 1.05, -1.05],
        [-1.05,  1.05]],
       [[ 1.56, -1.56],
        [-1.56,  1.56]]])

That is, ``result[0]`` is equal to
``multivariate_hypergeom.cov(m=[7, 9], n=8)`` and ``result[1]`` is equal
to ``multivariate_hypergeom.cov(m=[10, 15], n=12)``.

Alternatively, the object may be called (as a function) to fix the `m`
and `n` parameters, returning a "frozen" multivariate hypergeometric
random variable.

>>> rv = multivariate_hypergeom(m=[10, 20], n=12)
>>> rv.pmf(x=[8, 4])
0.0025207176631464523

See Also
--------
scipy.stats.hypergeom : The hypergeometric distribution.
scipy.stats.multinomial : The multinomial distribution.

References
----------
.. [1] The Multivariate Hypergeometric Distribution,
       http://www.randomservices.org/random/urn/MultiHypergeometric.html
.. [2] Thomas J. Sargent and John Stachurski, 2020,
       Multivariate Hypergeometric Distribution
       https://python.quantecon.org/multi_hyper.html
================================================================================

multivariate_normal:
Firma: (mean=None, cov=1, allow_singular=False, seed=None)

Docstring:
A multivariate normal random variable.

The `mean` keyword specifies the mean. The `cov` keyword specifies the
covariance matrix.

Methods
-------
pdf(x, mean=None, cov=1, allow_singular=False)
    Probability density function.
logpdf(x, mean=None, cov=1, allow_singular=False)
    Log of the probability density function.
cdf(x, mean=None, cov=1, allow_singular=False, maxpts=1000000*dim, abseps=1e-5, releps=1e-5, lower_limit=None)
    Cumulative distribution function.
logcdf(x, mean=None, cov=1, allow_singular=False, maxpts=1000000*dim, abseps=1e-5, releps=1e-5)
    Log of the cumulative distribution function.
rvs(mean=None, cov=1, size=1, random_state=None)
    Draw random samples from a multivariate normal distribution.
entropy(mean=None, cov=1)
    Compute the differential entropy of the multivariate normal.
fit(x, fix_mean=None, fix_cov=None)
    Fit a multivariate normal distribution to data.

Parameters
----------
mean : array_like, default: ``[0]``
    Mean of the distribution.
cov : array_like or `Covariance`, default: ``[1]``
    Symmetric positive (semi)definite covariance matrix of the distribution.
allow_singular : bool, default: ``False``
    Whether to allow a singular covariance matrix. This is ignored if `cov` is
    a `Covariance` object.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
Setting the parameter `mean` to `None` is equivalent to having `mean`
be the zero-vector. The parameter `cov` can be a scalar, in which case
the covariance matrix is the identity times that value, a vector of
diagonal entries for the covariance matrix, a two-dimensional array_like,
or a `Covariance` object.

The covariance matrix `cov` may be an instance of a subclass of
`Covariance`, e.g. `scipy.stats.CovViaPrecision`. If so, `allow_singular`
is ignored.

Otherwise, `cov` must be a symmetric positive semidefinite
matrix when `allow_singular` is True; it must be (strictly) positive
definite when `allow_singular` is False.
Symmetry is not checked; only the lower triangular portion is used.
The determinant and inverse of `cov` are computed
as the pseudo-determinant and pseudo-inverse, respectively, so
that `cov` does not need to have full rank.

The probability density function for `multivariate_normal` is

.. math::

    f(x) = \frac{1}{\sqrt{(2 \pi)^k \det \Sigma}}
           \exp\left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right),

where :math:`\mu` is the mean, :math:`\Sigma` the covariance matrix,
:math:`k` the rank of :math:`\Sigma`. In case of singular :math:`\Sigma`,
SciPy extends this definition according to [1]_.

.. versionadded:: 0.14.0

References
----------
.. [1] Multivariate Normal Distribution - Degenerate Case, Wikipedia,
       https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import multivariate_normal

>>> x = np.linspace(0, 5, 10, endpoint=False)
>>> y = multivariate_normal.pdf(x, mean=2.5, cov=0.5); y
array([ 0.00108914,  0.01033349,  0.05946514,  0.20755375,  0.43939129,
        0.56418958,  0.43939129,  0.20755375,  0.05946514,  0.01033349])
>>> fig1 = plt.figure()
>>> ax = fig1.add_subplot(111)
>>> ax.plot(x, y)
>>> plt.show()

Alternatively, the object may be called (as a function) to fix the mean
and covariance parameters, returning a "frozen" multivariate normal
random variable:

>>> rv = multivariate_normal(mean=None, cov=1, allow_singular=False)
>>> # Frozen object with the same methods but holding the given
>>> # mean and covariance fixed.

The input quantiles can be any shape of array, as long as the last
axis labels the components.  This allows us for instance to
display the frozen pdf for a non-isotropic random variable in 2D as
follows:

>>> x, y = np.mgrid[-1:1:.01, -1:1:.01]
>>> pos = np.dstack((x, y))
>>> rv = multivariate_normal([0.5, -0.2], [[2.0, 0.3], [0.3, 0.5]])
>>> fig2 = plt.figure()
>>> ax2 = fig2.add_subplot(111)
>>> ax2.contourf(x, y, rv.pdf(pos))
================================================================================

multivariate_t:
Firma: (loc=None, shape=1, df=1, allow_singular=False, seed=None)

Docstring:
A multivariate t-distributed random variable.

The `loc` parameter specifies the location. The `shape` parameter specifies
the positive semidefinite shape matrix. The `df` parameter specifies the
degrees of freedom.

In addition to calling the methods below, the object itself may be called
as a function to fix the location, shape matrix, and degrees of freedom
parameters, returning a "frozen" multivariate t-distribution random.

Methods
-------
pdf(x, loc=None, shape=1, df=1, allow_singular=False)
    Probability density function.
logpdf(x, loc=None, shape=1, df=1, allow_singular=False)
    Log of the probability density function.
cdf(x, loc=None, shape=1, df=1, allow_singular=False, *,
    maxpts=None, lower_limit=None, random_state=None)
    Cumulative distribution function.
rvs(loc=None, shape=1, df=1, size=1, random_state=None)
    Draw random samples from a multivariate t-distribution.
entropy(loc=None, shape=1, df=1)
    Differential entropy of a multivariate t-distribution.

Parameters
----------
loc : array_like, optional
    Location of the distribution. (default ``0``)
shape : array_like, optional
    Positive semidefinite matrix of the distribution. (default ``1``)
df : float, optional
    Degrees of freedom of the distribution; must be greater than zero.
    If ``np.inf`` then results are multivariate normal. The default is ``1``.
allow_singular : bool, optional
    Whether to allow a singular matrix. (default ``False``)
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
Setting the parameter `loc` to ``None`` is equivalent to having `loc`
be the zero-vector. The parameter `shape` can be a scalar, in which case
the shape matrix is the identity times that value, a vector of
diagonal entries for the shape matrix, or a two-dimensional array_like.
The matrix `shape` must be a (symmetric) positive semidefinite matrix. The
determinant and inverse of `shape` are computed as the pseudo-determinant
and pseudo-inverse, respectively, so that `shape` does not need to have
full rank.

The probability density function for `multivariate_t` is

.. math::

    f(x) = \frac{\Gamma((\nu + p)/2)}{\Gamma(\nu/2)\nu^{p/2}\pi^{p/2}|\Sigma|^{1/2}}
           \left[1 + \frac{1}{\nu} (\mathbf{x} - \boldsymbol{\mu})^{\top}
           \boldsymbol{\Sigma}^{-1}
           (\mathbf{x} - \boldsymbol{\mu}) \right]^{-(\nu + p)/2},

where :math:`p` is the dimension of :math:`\mathbf{x}`,
:math:`\boldsymbol{\mu}` is the :math:`p`-dimensional location,
:math:`\boldsymbol{\Sigma}` the :math:`p \times p`-dimensional shape
matrix, and :math:`\nu` is the degrees of freedom.

.. versionadded:: 1.6.0

References
----------
.. [1] Arellano-Valle et al. "Shannon Entropy and Mutual Information for
       Multivariate Skew-Elliptical Distributions". Scandinavian Journal
       of Statistics. Vol. 40, issue 1.

Examples
--------
The object may be called (as a function) to fix the `loc`, `shape`,
`df`, and `allow_singular` parameters, returning a "frozen"
multivariate_t random variable:

>>> import numpy as np
>>> from scipy.stats import multivariate_t
>>> rv = multivariate_t([1.0, -0.5], [[2.1, 0.3], [0.3, 1.5]], df=2)
>>> # Frozen object with the same methods but holding the given location,
>>> # scale, and degrees of freedom fixed.

Create a contour plot of the PDF.

>>> import matplotlib.pyplot as plt
>>> x, y = np.mgrid[-1:3:.01, -2:1.5:.01]
>>> pos = np.dstack((x, y))
>>> fig, ax = plt.subplots(1, 1)
>>> ax.set_aspect('equal')
>>> plt.contourf(x, y, rv.pdf(pos))
================================================================================

mvsdist:
Firma: (data)

Docstring:
'Frozen' distributions for mean, variance, and standard deviation of data.

Parameters
----------
data : array_like
    Input array. Converted to 1-D using ravel.
    Requires 2 or more data-points.

Returns
-------
mdist : "frozen" distribution object
    Distribution object representing the mean of the data.
vdist : "frozen" distribution object
    Distribution object representing the variance of the data.
sdist : "frozen" distribution object
    Distribution object representing the standard deviation of the data.

See Also
--------
bayes_mvs

Notes
-----
The return values from ``bayes_mvs(data)`` is equivalent to
``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.

In other words, calling ``<dist>.mean()`` and ``<dist>.interval(0.90)``
on the three distribution objects returned from this function will give
the same results that are returned from `bayes_mvs`.

References
----------
T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
2006.

Examples
--------
>>> from scipy import stats
>>> data = [6, 9, 12, 7, 8, 8, 13]
>>> mean, var, std = stats.mvsdist(data)

We now have frozen distribution objects "mean", "var" and "std" that we can
examine:

>>> mean.mean()
9.0
>>> mean.interval(0.95)
(6.6120585482655692, 11.387941451734431)
>>> mean.std()
1.1952286093343936
================================================================================

nakagami:
Firma: (*args, **kwds)

Docstring:
A Nakagami continuous random variable.

As an instance of the `rv_continuous` class, `nakagami` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(nu, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, nu, loc=0, scale=1)
    Probability density function.
logpdf(x, nu, loc=0, scale=1)
    Log of the probability density function.
cdf(x, nu, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, nu, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, nu, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, nu, loc=0, scale=1)
    Log of the survival function.
ppf(q, nu, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, nu, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, nu, loc=0, scale=1)
    Non-central moment of the specified order.
stats(nu, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(nu, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(nu,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(nu, loc=0, scale=1)
    Median of the distribution.
mean(nu, loc=0, scale=1)
    Mean of the distribution.
var(nu, loc=0, scale=1)
    Variance of the distribution.
std(nu, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, nu, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `nakagami` is:

.. math::

    f(x, \nu) = \frac{2 \nu^\nu}{\Gamma(\nu)} x^{2\nu-1} \exp(-\nu x^2)

for :math:`x >= 0`, :math:`\nu > 0`. The distribution was introduced in
[2]_, see also [1]_ for further information.

`nakagami` takes ``nu`` as a shape parameter for :math:`\nu`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``nakagami.pdf(x, nu, loc, scale)`` is identically
equivalent to ``nakagami.pdf(y, nu) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] "Nakagami distribution", Wikipedia
       https://en.wikipedia.org/wiki/Nakagami_distribution
.. [2] M. Nakagami, "The m-distribution - A general formula of intensity
       distribution of rapid fading", Statistical methods in radio wave
       propagation, Pergamon Press, 1960, 3-36.
       :doi:`10.1016/B978-0-08-009306-2.50005-4`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nakagami
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> nu = 4.97
>>> mean, var, skew, kurt = nakagami.stats(nu, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(nakagami.ppf(0.01, nu),
...                 nakagami.ppf(0.99, nu), 100)
>>> ax.plot(x, nakagami.pdf(x, nu),
...        'r-', lw=5, alpha=0.6, label='nakagami pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = nakagami(nu)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = nakagami.ppf([0.001, 0.5, 0.999], nu)
>>> np.allclose([0.001, 0.5, 0.999], nakagami.cdf(vals, nu))
True

Generate random numbers:

>>> r = nakagami.rvs(nu, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

nbinom:
Firma: (*args, **kwds)

Docstring:
A negative binomial discrete random variable.

As an instance of the `rv_discrete` class, `nbinom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(n, p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, n, p, loc=0)
    Probability mass function.
logpmf(k, n, p, loc=0)
    Log of the probability mass function.
cdf(k, n, p, loc=0)
    Cumulative distribution function.
logcdf(k, n, p, loc=0)
    Log of the cumulative distribution function.
sf(k, n, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, n, p, loc=0)
    Log of the survival function.
ppf(q, n, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, n, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(n, p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(n, p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(n, p), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(n, p, loc=0)
    Median of the distribution.
mean(n, p, loc=0)
    Mean of the distribution.
var(n, p, loc=0)
    Variance of the distribution.
std(n, p, loc=0)
    Standard deviation of the distribution.
interval(confidence, n, p, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
Negative binomial distribution describes a sequence of i.i.d. Bernoulli
trials, repeated until a predefined, non-random number of successes occurs.

The probability mass function of the number of failures for `nbinom` is:

.. math::

   f(k) = \binom{k+n-1}{n-1} p^n (1-p)^k

for :math:`k \ge 0`, :math:`0 < p \leq 1`

`nbinom` takes :math:`n` and :math:`p` as shape parameters where :math:`n`
is the number of successes, :math:`p` is the probability of a single
success, and :math:`1-p` is the probability of a single failure.

Another common parameterization of the negative binomial distribution is
in terms of the mean number of failures :math:`\mu` to achieve :math:`n`
successes. The mean :math:`\mu` is related to the probability of success
as

.. math::

   p = \frac{n}{n + \mu}

The number of successes :math:`n` may also be specified in terms of a
"dispersion", "heterogeneity", or "aggregation" parameter :math:`\alpha`,
which relates the mean :math:`\mu` to the variance :math:`\sigma^2`,
e.g. :math:`\sigma^2 = \mu + \alpha \mu^2`. Regardless of the convention
used for :math:`\alpha`,

.. math::

   p &= \frac{\mu}{\sigma^2} \\
   n &= \frac{\mu^2}{\sigma^2 - \mu}

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pmf``, ``cdf``, ``sf``, ``ppf``, ``isf``
and ``stats`` methods. [1]_

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``nbinom.pmf(k, n, p, loc)`` is identically
equivalent to ``nbinom.pmf(k - loc, n, p)``.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nbinom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> n, p = 5, 0.5
>>> mean, var, skew, kurt = nbinom.stats(n, p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(nbinom.ppf(0.01, n, p),
...               nbinom.ppf(0.99, n, p))
>>> ax.plot(x, nbinom.pmf(x, n, p), 'bo', ms=8, label='nbinom pmf')
>>> ax.vlines(x, 0, nbinom.pmf(x, n, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = nbinom(n, p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = nbinom.cdf(x, n, p)
>>> np.allclose(x, nbinom.ppf(prob, n, p))
True

Generate random numbers:

>>> r = nbinom.rvs(n, p, size=1000)

See Also
--------
hypergeom, binom, nhypergeom
================================================================================

ncf:
Firma: (*args, **kwds)

Docstring:
A non-central F distribution continuous random variable.

As an instance of the `rv_continuous` class, `ncf` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(dfn, dfd, nc, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, dfn, dfd, nc, loc=0, scale=1)
    Probability density function.
logpdf(x, dfn, dfd, nc, loc=0, scale=1)
    Log of the probability density function.
cdf(x, dfn, dfd, nc, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, dfn, dfd, nc, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, dfn, dfd, nc, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, dfn, dfd, nc, loc=0, scale=1)
    Log of the survival function.
ppf(q, dfn, dfd, nc, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, dfn, dfd, nc, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, dfn, dfd, nc, loc=0, scale=1)
    Non-central moment of the specified order.
stats(dfn, dfd, nc, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(dfn, dfd, nc, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(dfn, dfd, nc), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(dfn, dfd, nc, loc=0, scale=1)
    Median of the distribution.
mean(dfn, dfd, nc, loc=0, scale=1)
    Mean of the distribution.
var(dfn, dfd, nc, loc=0, scale=1)
    Variance of the distribution.
std(dfn, dfd, nc, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, dfn, dfd, nc, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
scipy.stats.f : Fisher distribution

Notes
-----
The probability density function for `ncf` is:

.. math::

    f(x, n_1, n_2, \lambda) =
        \exp\left(\frac{\lambda}{2} +
                  \lambda n_1 \frac{x}{2(n_1 x + n_2)}
            \right)
        n_1^{n_1/2} n_2^{n_2/2} x^{n_1/2 - 1} \\
        (n_2 + n_1 x)^{-(n_1 + n_2)/2}
        \gamma(n_1/2) \gamma(1 + n_2/2) \\
        \frac{L^{\frac{n_1}{2}-1}_{n_2/2}
            \left(-\lambda n_1 \frac{x}{2(n_1 x + n_2)}\right)}
        {B(n_1/2, n_2/2)
            \gamma\left(\frac{n_1 + n_2}{2}\right)}

for :math:`n_1, n_2 > 0`, :math:`\lambda \ge 0`.  Here :math:`n_1` is the
degrees of freedom in the numerator, :math:`n_2` the degrees of freedom in
the denominator, :math:`\lambda` the non-centrality parameter,
:math:`\gamma` is the logarithm of the Gamma function, :math:`L_n^k` is a
generalized Laguerre polynomial and :math:`B` is the beta function.

`ncf` takes ``dfn``, ``dfd`` and ``nc`` as shape parameters. If ``nc=0``,
the distribution becomes equivalent to the Fisher distribution.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pdf``, ``cdf``, ``ppf``, ``stats``, ``sf`` and
``isf`` methods. [1]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``ncf.pdf(x, dfn, dfd, nc, loc, scale)`` is identically
equivalent to ``ncf.pdf(y, dfn, dfd, nc) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import ncf
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> dfn, dfd, nc = 27, 27, 0.416
>>> mean, var, skew, kurt = ncf.stats(dfn, dfd, nc, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(ncf.ppf(0.01, dfn, dfd, nc),
...                 ncf.ppf(0.99, dfn, dfd, nc), 100)
>>> ax.plot(x, ncf.pdf(x, dfn, dfd, nc),
...        'r-', lw=5, alpha=0.6, label='ncf pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = ncf(dfn, dfd, nc)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = ncf.ppf([0.001, 0.5, 0.999], dfn, dfd, nc)
>>> np.allclose([0.001, 0.5, 0.999], ncf.cdf(vals, dfn, dfd, nc))
True

Generate random numbers:

>>> r = ncf.rvs(dfn, dfd, nc, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

nchypergeom_fisher:
Firma: (*args, **kwds)

Docstring:
A Fisher's noncentral hypergeometric discrete random variable.

Fisher's noncentral hypergeometric distribution models drawing objects of
two types from a bin. `M` is the total number of objects, `n` is the
number of Type I objects, and `odds` is the odds ratio: the odds of
selecting a Type I object rather than a Type II object when there is only
one object of each type.
The random variate represents the number of Type I objects drawn if we
take a handful of objects from the bin at once and find out afterwards
that we took `N` objects.

As an instance of the `rv_discrete` class, `nchypergeom_fisher` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(M, n, N, odds, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, M, n, N, odds, loc=0)
    Probability mass function.
logpmf(k, M, n, N, odds, loc=0)
    Log of the probability mass function.
cdf(k, M, n, N, odds, loc=0)
    Cumulative distribution function.
logcdf(k, M, n, N, odds, loc=0)
    Log of the cumulative distribution function.
sf(k, M, n, N, odds, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, M, n, N, odds, loc=0)
    Log of the survival function.
ppf(q, M, n, N, odds, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, M, n, N, odds, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(M, n, N, odds, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(M, n, N, odds, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(M, n, N, odds), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(M, n, N, odds, loc=0)
    Median of the distribution.
mean(M, n, N, odds, loc=0)
    Mean of the distribution.
var(M, n, N, odds, loc=0)
    Variance of the distribution.
std(M, n, N, odds, loc=0)
    Standard deviation of the distribution.
interval(confidence, M, n, N, odds, loc=0)
    Confidence interval with equal areas around the median.

See Also
--------
nchypergeom_wallenius, hypergeom, nhypergeom

Notes
-----
Let mathematical symbols :math:`N`, :math:`n`, and :math:`M` correspond
with parameters `N`, `n`, and `M` (respectively) as defined above.

The probability mass function is defined as

.. math::

    p(x; M, n, N, \omega) =
    \frac{\binom{n}{x}\binom{M - n}{N-x}\omega^x}{P_0},

for
:math:`x \in [x_l, x_u]`,
:math:`M \in {\mathbb N}`,
:math:`n \in [0, M]`,
:math:`N \in [0, M]`,
:math:`\omega > 0`,
where
:math:`x_l = \max(0, N - (M - n))`,
:math:`x_u = \min(N, n)`,

.. math::

    P_0 = \sum_{y=x_l}^{x_u} \binom{n}{y}\binom{M - n}{N-y}\omega^y,

and the binomial coefficients are defined as

.. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}.

`nchypergeom_fisher` uses the BiasedUrn package by Agner Fog with
permission for it to be distributed under SciPy's license.

The symbols used to denote the shape parameters (`N`, `n`, and `M`) are not
universally accepted; they are chosen for consistency with `hypergeom`.

Note that Fisher's noncentral hypergeometric distribution is distinct
from Wallenius' noncentral hypergeometric distribution, which models
drawing a pre-determined `N` objects from a bin one by one.
When the odds ratio is unity, however, both distributions reduce to the
ordinary hypergeometric distribution.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``nchypergeom_fisher.pmf(k, M, n, N, odds, loc)`` is identically
equivalent to ``nchypergeom_fisher.pmf(k - loc, M, n, N, odds)``.

References
----------
.. [1] Agner Fog, "Biased Urn Theory".
       https://cran.r-project.org/web/packages/BiasedUrn/vignettes/UrnTheory.pdf

.. [2] "Fisher's noncentral hypergeometric distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Fisher's_noncentral_hypergeometric_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nchypergeom_fisher
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> M, n, N, odds = 140, 80, 60, 0.5
>>> mean, var, skew, kurt = nchypergeom_fisher.stats(M, n, N, odds, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(nchypergeom_fisher.ppf(0.01, M, n, N, odds),
...               nchypergeom_fisher.ppf(0.99, M, n, N, odds))
>>> ax.plot(x, nchypergeom_fisher.pmf(x, M, n, N, odds), 'bo', ms=8, label='nchypergeom_fisher pmf')
>>> ax.vlines(x, 0, nchypergeom_fisher.pmf(x, M, n, N, odds), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = nchypergeom_fisher(M, n, N, odds)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = nchypergeom_fisher.cdf(x, M, n, N, odds)
>>> np.allclose(x, nchypergeom_fisher.ppf(prob, M, n, N, odds))
True

Generate random numbers:

>>> r = nchypergeom_fisher.rvs(M, n, N, odds, size=1000)
================================================================================

nchypergeom_wallenius:
Firma: (*args, **kwds)

Docstring:
A Wallenius' noncentral hypergeometric discrete random variable.

Wallenius' noncentral hypergeometric distribution models drawing objects of
two types from a bin. `M` is the total number of objects, `n` is the
number of Type I objects, and `odds` is the odds ratio: the odds of
selecting a Type I object rather than a Type II object when there is only
one object of each type.
The random variate represents the number of Type I objects drawn if we
draw a pre-determined `N` objects from a bin one by one.

As an instance of the `rv_discrete` class, `nchypergeom_wallenius` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(M, n, N, odds, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, M, n, N, odds, loc=0)
    Probability mass function.
logpmf(k, M, n, N, odds, loc=0)
    Log of the probability mass function.
cdf(k, M, n, N, odds, loc=0)
    Cumulative distribution function.
logcdf(k, M, n, N, odds, loc=0)
    Log of the cumulative distribution function.
sf(k, M, n, N, odds, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, M, n, N, odds, loc=0)
    Log of the survival function.
ppf(q, M, n, N, odds, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, M, n, N, odds, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(M, n, N, odds, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(M, n, N, odds, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(M, n, N, odds), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(M, n, N, odds, loc=0)
    Median of the distribution.
mean(M, n, N, odds, loc=0)
    Mean of the distribution.
var(M, n, N, odds, loc=0)
    Variance of the distribution.
std(M, n, N, odds, loc=0)
    Standard deviation of the distribution.
interval(confidence, M, n, N, odds, loc=0)
    Confidence interval with equal areas around the median.

See Also
--------
nchypergeom_fisher, hypergeom, nhypergeom

Notes
-----
Let mathematical symbols :math:`N`, :math:`n`, and :math:`M` correspond
with parameters `N`, `n`, and `M` (respectively) as defined above.

The probability mass function is defined as

.. math::

    p(x; N, n, M) = \binom{n}{x} \binom{M - n}{N-x}
    \int_0^1 \left(1-t^{\omega/D}\right)^x\left(1-t^{1/D}\right)^{N-x} dt

for
:math:`x \in [x_l, x_u]`,
:math:`M \in {\mathbb N}`,
:math:`n \in [0, M]`,
:math:`N \in [0, M]`,
:math:`\omega > 0`,
where
:math:`x_l = \max(0, N - (M - n))`,
:math:`x_u = \min(N, n)`,

.. math::

    D = \omega(n - x) + ((M - n)-(N-x)),

and the binomial coefficients are defined as

.. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}.

`nchypergeom_wallenius` uses the BiasedUrn package by Agner Fog with
permission for it to be distributed under SciPy's license.

The symbols used to denote the shape parameters (`N`, `n`, and `M`) are not
universally accepted; they are chosen for consistency with `hypergeom`.

Note that Wallenius' noncentral hypergeometric distribution is distinct
from Fisher's noncentral hypergeometric distribution, which models
take a handful of objects from the bin at once, finding out afterwards
that `N` objects were taken.
When the odds ratio is unity, however, both distributions reduce to the
ordinary hypergeometric distribution.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``nchypergeom_wallenius.pmf(k, M, n, N, odds, loc)`` is identically
equivalent to ``nchypergeom_wallenius.pmf(k - loc, M, n, N, odds)``.

References
----------
.. [1] Agner Fog, "Biased Urn Theory".
       https://cran.r-project.org/web/packages/BiasedUrn/vignettes/UrnTheory.pdf

.. [2] "Wallenius' noncentral hypergeometric distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Wallenius'_noncentral_hypergeometric_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nchypergeom_wallenius
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> M, n, N, odds = 140, 80, 60, 0.5
>>> mean, var, skew, kurt = nchypergeom_wallenius.stats(M, n, N, odds, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(nchypergeom_wallenius.ppf(0.01, M, n, N, odds),
...               nchypergeom_wallenius.ppf(0.99, M, n, N, odds))
>>> ax.plot(x, nchypergeom_wallenius.pmf(x, M, n, N, odds), 'bo', ms=8, label='nchypergeom_wallenius pmf')
>>> ax.vlines(x, 0, nchypergeom_wallenius.pmf(x, M, n, N, odds), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = nchypergeom_wallenius(M, n, N, odds)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = nchypergeom_wallenius.cdf(x, M, n, N, odds)
>>> np.allclose(x, nchypergeom_wallenius.ppf(prob, M, n, N, odds))
True

Generate random numbers:

>>> r = nchypergeom_wallenius.rvs(M, n, N, odds, size=1000)
================================================================================

nct:
Firma: (*args, **kwds)

Docstring:
A non-central Student's t continuous random variable.

As an instance of the `rv_continuous` class, `nct` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(df, nc, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, df, nc, loc=0, scale=1)
    Probability density function.
logpdf(x, df, nc, loc=0, scale=1)
    Log of the probability density function.
cdf(x, df, nc, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, df, nc, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, df, nc, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, df, nc, loc=0, scale=1)
    Log of the survival function.
ppf(q, df, nc, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, df, nc, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, df, nc, loc=0, scale=1)
    Non-central moment of the specified order.
stats(df, nc, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(df, nc, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(df, nc), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(df, nc, loc=0, scale=1)
    Median of the distribution.
mean(df, nc, loc=0, scale=1)
    Mean of the distribution.
var(df, nc, loc=0, scale=1)
    Variance of the distribution.
std(df, nc, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, df, nc, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
If :math:`Y` is a standard normal random variable and :math:`V` is
an independent chi-square random variable (`chi2`) with :math:`k` degrees
of freedom, then

.. math::

    X = \frac{Y + c}{\sqrt{V/k}}

has a non-central Student's t distribution on the real line.
The degrees of freedom parameter :math:`k` (denoted ``df`` in the
implementation) satisfies :math:`k > 0` and the noncentrality parameter
:math:`c` (denoted ``nc`` in the implementation) is a real number.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pdf``, ``cdf``, ``ppf``, ``sf`` and ``isf``
methods. [1]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``nct.pdf(x, df, nc, loc, scale)`` is identically
equivalent to ``nct.pdf(y, df, nc) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nct
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> df, nc = 14, 0.24
>>> mean, var, skew, kurt = nct.stats(df, nc, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(nct.ppf(0.01, df, nc),
...                 nct.ppf(0.99, df, nc), 100)
>>> ax.plot(x, nct.pdf(x, df, nc),
...        'r-', lw=5, alpha=0.6, label='nct pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = nct(df, nc)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = nct.ppf([0.001, 0.5, 0.999], df, nc)
>>> np.allclose([0.001, 0.5, 0.999], nct.cdf(vals, df, nc))
True

Generate random numbers:

>>> r = nct.rvs(df, nc, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

ncx2:
Firma: (*args, **kwds)

Docstring:
A non-central chi-squared continuous random variable.

As an instance of the `rv_continuous` class, `ncx2` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(df, nc, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, df, nc, loc=0, scale=1)
    Probability density function.
logpdf(x, df, nc, loc=0, scale=1)
    Log of the probability density function.
cdf(x, df, nc, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, df, nc, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, df, nc, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, df, nc, loc=0, scale=1)
    Log of the survival function.
ppf(q, df, nc, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, df, nc, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, df, nc, loc=0, scale=1)
    Non-central moment of the specified order.
stats(df, nc, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(df, nc, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(df, nc), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(df, nc, loc=0, scale=1)
    Median of the distribution.
mean(df, nc, loc=0, scale=1)
    Mean of the distribution.
var(df, nc, loc=0, scale=1)
    Variance of the distribution.
std(df, nc, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, df, nc, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `ncx2` is:

.. math::

    f(x, k, \lambda) = \frac{1}{2} \exp(-(\lambda+x)/2)
        (x/\lambda)^{(k-2)/4}  I_{(k-2)/2}(\sqrt{\lambda x})

for :math:`x >= 0`, :math:`k > 0` and :math:`\lambda \ge 0`.
:math:`k` specifies the degrees of freedom (denoted ``df`` in the
implementation) and :math:`\lambda` is the non-centrality parameter
(denoted ``nc`` in the implementation). :math:`I_\nu` denotes the
modified Bessel function of first order of degree :math:`\nu`
(`scipy.special.iv`).

`ncx2` takes ``df`` and ``nc`` as shape parameters.

This distribution uses routines from the Boost Math C++ library for
the computation of the ``pdf``, ``cdf``, ``ppf``, ``sf`` and ``isf``
methods. [1]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``ncx2.pdf(x, df, nc, loc, scale)`` is identically
equivalent to ``ncx2.pdf(y, df, nc) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import ncx2
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> df, nc = 21, 1.06
>>> mean, var, skew, kurt = ncx2.stats(df, nc, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(ncx2.ppf(0.01, df, nc),
...                 ncx2.ppf(0.99, df, nc), 100)
>>> ax.plot(x, ncx2.pdf(x, df, nc),
...        'r-', lw=5, alpha=0.6, label='ncx2 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = ncx2(df, nc)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = ncx2.ppf([0.001, 0.5, 0.999], df, nc)
>>> np.allclose([0.001, 0.5, 0.999], ncx2.cdf(vals, df, nc))
True

Generate random numbers:

>>> r = ncx2.rvs(df, nc, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

nhypergeom:
Firma: (*args, **kwds)

Docstring:
A negative hypergeometric discrete random variable.

Consider a box containing :math:`M` balls:, :math:`n` red and
:math:`M-n` blue. We randomly sample balls from the box, one
at a time and *without* replacement, until we have picked :math:`r`
blue balls. `nhypergeom` is the distribution of the number of
red balls :math:`k` we have picked.

As an instance of the `rv_discrete` class, `nhypergeom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(M, n, r, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, M, n, r, loc=0)
    Probability mass function.
logpmf(k, M, n, r, loc=0)
    Log of the probability mass function.
cdf(k, M, n, r, loc=0)
    Cumulative distribution function.
logcdf(k, M, n, r, loc=0)
    Log of the cumulative distribution function.
sf(k, M, n, r, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, M, n, r, loc=0)
    Log of the survival function.
ppf(q, M, n, r, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, M, n, r, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(M, n, r, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(M, n, r, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(M, n, r), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(M, n, r, loc=0)
    Median of the distribution.
mean(M, n, r, loc=0)
    Mean of the distribution.
var(M, n, r, loc=0)
    Variance of the distribution.
std(M, n, r, loc=0)
    Standard deviation of the distribution.
interval(confidence, M, n, r, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The symbols used to denote the shape parameters (`M`, `n`, and `r`) are not
universally accepted. See the Examples for a clarification of the
definitions used here.

The probability mass function is defined as,

.. math:: f(k; M, n, r) = \frac{{{k+r-1}\choose{k}}{{M-r-k}\choose{n-k}}}
                               {{M \choose n}}

for :math:`k \in [0, n]`, :math:`n \in [0, M]`, :math:`r \in [0, M-n]`,
and the binomial coefficient is:

.. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}.

It is equivalent to observing :math:`k` successes in :math:`k+r-1`
samples with :math:`k+r`'th sample being a failure. The former
can be modelled as a hypergeometric distribution. The probability
of the latter is simply the number of failures remaining
:math:`M-n-(r-1)` divided by the size of the remaining population
:math:`M-(k+r-1)`. This relationship can be shown as:

.. math:: NHG(k;M,n,r) = HG(k;M,n,k+r-1)\frac{(M-n-(r-1))}{(M-(k+r-1))}

where :math:`NHG` is probability mass function (PMF) of the
negative hypergeometric distribution and :math:`HG` is the
PMF of the hypergeometric distribution.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``nhypergeom.pmf(k, M, n, r, loc)`` is identically
equivalent to ``nhypergeom.pmf(k - loc, M, n, r)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import nhypergeom
>>> import matplotlib.pyplot as plt

Suppose we have a collection of 20 animals, of which 7 are dogs.
Then if we want to know the probability of finding a given number
of dogs (successes) in a sample with exactly 12 animals that
aren't dogs (failures), we can initialize a frozen distribution
and plot the probability mass function:

>>> M, n, r = [20, 7, 12]
>>> rv = nhypergeom(M, n, r)
>>> x = np.arange(0, n+2)
>>> pmf_dogs = rv.pmf(x)

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(x, pmf_dogs, 'bo')
>>> ax.vlines(x, 0, pmf_dogs, lw=2)
>>> ax.set_xlabel('# of dogs in our group with given 12 failures')
>>> ax.set_ylabel('nhypergeom PMF')
>>> plt.show()

Instead of using a frozen distribution we can also use `nhypergeom`
methods directly.  To for example obtain the probability mass
function, use:

>>> prb = nhypergeom.pmf(x, M, n, r)

And to generate random numbers:

>>> R = nhypergeom.rvs(M, n, r, size=10)

To verify the relationship between `hypergeom` and `nhypergeom`, use:

>>> from scipy.stats import hypergeom, nhypergeom
>>> M, n, r = 45, 13, 8
>>> k = 6
>>> nhypergeom.pmf(k, M, n, r)
0.06180776620271643
>>> hypergeom.pmf(k, M, n, k+r-1) * (M - n - (r-1)) / (M - (k+r-1))
0.06180776620271644

See Also
--------
hypergeom, binom, nbinom

References
----------
.. [1] Negative Hypergeometric Distribution on Wikipedia
       https://en.wikipedia.org/wiki/Negative_hypergeometric_distribution

.. [2] Negative Hypergeometric Distribution from
       http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Negativehypergeometric.pdf
================================================================================

norm:
Firma: (*args, **kwds)

Docstring:
A normal continuous random variable.

The location (``loc``) keyword specifies the mean.
The scale (``scale``) keyword specifies the standard deviation.

As an instance of the `rv_continuous` class, `norm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `norm` is:

.. math::

    f(x) = \frac{\exp(-x^2/2)}{\sqrt{2\pi}}

for a real number :math:`x`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``norm.pdf(x, loc, scale)`` is identically
equivalent to ``norm.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import norm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = norm.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(norm.ppf(0.01),
...                 norm.ppf(0.99), 100)
>>> ax.plot(x, norm.pdf(x),
...        'r-', lw=5, alpha=0.6, label='norm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = norm()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = norm.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], norm.cdf(vals))
True

Generate random numbers:

>>> r = norm.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

normal_inverse_gamma:
Firma: (mu=0, lmbda=1, a=1, b=1, seed=None)

Docstring:
Normal-inverse-gamma distribution.

The normal-inverse-gamma distribution is the conjugate prior of a normal
distribution with unknown mean and variance.

Methods
-------
pdf(x, s2, mu=0, lmbda=1, a=1, b=1)
    Probability density function.
logpdf(x, s2, mu=0, lmbda=1, a=1, b=1)
    Log of the probability density function.
mean(mu=0, lmbda=1, a=1, b=1)
    Distribution mean.
var(mu=0, lmbda=1, a=1, b=1)
    Distribution variance.
rvs(mu=0, lmbda=1, a=1, b=1, size=None, random_state=None)
    Draw random samples.

Parameters
----------
mu, lmbda, a, b  : array_like
    Shape parameters of the distribution. See notes.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

See Also
--------
norm
invgamma

Notes
-----

The probability density function of `normal_inverse_gamma` is:

.. math::

    f(x, \sigma^2; \mu, \lambda, \alpha, \beta) =
        \frac{\sqrt{\lambda}}{\sqrt{2 \pi \sigma^2}}
        \frac{\beta^\alpha}{\Gamma(\alpha)}
        \left( \frac{1}{\sigma^2} \right)^{\alpha + 1}
        \exp \left(- \frac{2 \beta + \lambda (x - \mu)^2} {2 \sigma^2} \right)

where all parameters are real and finite, and :math:`\sigma^2 > 0`,
:math:`\lambda > 0`, :math:`\alpha > 0`, and :math:`\beta > 0`.

Methods ``normal_inverse_gamma.pdf`` and ``normal_inverse_gamma.logpdf``
accept `x` and `s2` for arguments :math:`x` and :math:`\sigma^2`.
All methods accept `mu`, `lmbda`, `a`, and `b` for shape parameters
:math:`\mu`, :math:`\lambda`, :math:`\alpha`, and :math:`\beta`,
respectively.

.. versionadded:: 1.15

References
----------
.. [1] Normal-inverse-gamma distribution, Wikipedia,
       https://en.wikipedia.org/wiki/Normal-inverse-gamma_distribution

Examples
--------
Suppose we wish to investigate the relationship between the
normal-inverse-gamma distribution and the inverse gamma distribution.

>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng(527484872345)
>>> mu, lmbda, a, b = 0, 1, 20, 20
>>> norm_inv_gamma = stats.normal_inverse_gamma(mu, lmbda, a, b)
>>> inv_gamma = stats.invgamma(a, scale=b)

One approach is to compare the distribution of the `s2` elements of
random variates against the PDF of an inverse gamma distribution.

>>> _, s2 = norm_inv_gamma.rvs(size=10000, random_state=rng)
>>> bins = np.linspace(s2.min(), s2.max(), 50)
>>> plt.hist(s2, bins=bins, density=True, label='Frequency density')
>>> s2 = np.linspace(s2.min(), s2.max(), 300)
>>> plt.plot(s2, inv_gamma.pdf(s2), label='PDF')
>>> plt.xlabel(r'$\sigma^2$')
>>> plt.ylabel('Frequency density / PMF')
>>> plt.show()

Similarly, we can compare the marginal distribution of `s2` against
an inverse gamma distribution.

>>> from scipy.integrate import quad_vec
>>> from scipy import integrate
>>> s2 = np.linspace(0.5, 3, 6)
>>> res = quad_vec(lambda x: norm_inv_gamma.pdf(x, s2), -np.inf, np.inf)[0]
>>> np.allclose(res, inv_gamma.pdf(s2))
True

The sample mean is comparable to the mean of the distribution.

>>> x, s2 = norm_inv_gamma.rvs(size=10000, random_state=rng)
>>> x.mean(), s2.mean()
(np.float64(-0.005254750127304425), np.float64(1.050438111436508))
>>> norm_inv_gamma.mean()
(np.float64(0.0), np.float64(1.0526315789473684))

Similarly, for the variance:

>>> x.var(ddof=1), s2.var(ddof=1)
(np.float64(1.0546150578185023), np.float64(0.061829865266330754))
>>> norm_inv_gamma.var()
(np.float64(1.0526315789473684), np.float64(0.061557402277623886))
================================================================================

normaltest:
Firma: (a, axis=0, nan_policy='propagate', *, keepdims=False)

Docstring:
Test whether a sample differs from a normal distribution.

This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D'Agostino and
Pearson's [1]_, [2]_ test that combines skew and kurtosis to
produce an omnibus test of normality.

Parameters
----------
a : array_like
    The array containing the sample to be tested. Must contain
    at least eight observations.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float or array
    ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and
    ``k`` is the z-score returned by `kurtosistest`.
pvalue : float or array
    A 2-sided chi squared probability for the hypothesis test.

See Also
--------

:ref:`hypothesis_normaltest`
    Extended example


Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
        moderate and large sample size", Biometrika, 58, 341-348
.. [2] D'Agostino, R. and Pearson, E. S. (1973), "Tests for departure from
        normality", Biometrika, 60, 613-622

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> pts = 1000
>>> a = rng.normal(0, 1, size=pts)
>>> b = rng.normal(2, 1, size=pts)
>>> x = np.concatenate((a, b))
>>> res = stats.normaltest(x)
>>> res.statistic
53.619...  # random
>>> res.pvalue
2.273917413209226e-12  # random

For a more detailed example, see :ref:`hypothesis_normaltest`.
================================================================================

norminvgauss:
Firma: (*args, **kwds)

Docstring:
A Normal Inverse Gaussian continuous random variable.

As an instance of the `rv_continuous` class, `norminvgauss` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `norminvgauss` is:

.. math::

    f(x, a, b) = \frac{a \, K_1(a \sqrt{1 + x^2})}{\pi \sqrt{1 + x^2}} \,
                 \exp(\sqrt{a^2 - b^2} + b x)

where :math:`x` is a real number, the parameter :math:`a` is the tail
heaviness and :math:`b` is the asymmetry parameter satisfying
:math:`a > 0` and :math:`|b| <= a`.
:math:`K_1` is the modified Bessel function of second kind
(`scipy.special.k1`).

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``norminvgauss.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``norminvgauss.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

A normal inverse Gaussian random variable `Y` with parameters `a` and `b`
can be expressed as a normal mean-variance mixture:
``Y = b * V + sqrt(V) * X`` where `X` is ``norm(0,1)`` and `V` is
``invgauss(mu=1/sqrt(a**2 - b**2))``. This representation is used
to generate random variates.

Another common parametrization of the distribution (see Equation 2.1 in
[2]_) is given by the following expression of the pdf:

.. math::

    g(x, \alpha, \beta, \delta, \mu) =
    \frac{\alpha\delta K_1\left(\alpha\sqrt{\delta^2 + (x - \mu)^2}\right)}
    {\pi \sqrt{\delta^2 + (x - \mu)^2}} \,
    e^{\delta \sqrt{\alpha^2 - \beta^2} + \beta (x - \mu)}

In SciPy, this corresponds to
`a = alpha * delta, b = beta * delta, loc = mu, scale=delta`.

References
----------
.. [1] O. Barndorff-Nielsen, "Hyperbolic Distributions and Distributions on
       Hyperbolae", Scandinavian Journal of Statistics, Vol. 5(3),
       pp. 151-157, 1978.

.. [2] O. Barndorff-Nielsen, "Normal Inverse Gaussian Distributions and
       Stochastic Volatility Modelling", Scandinavian Journal of
       Statistics, Vol. 24, pp. 1-13, 1997.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import norminvgauss
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 1.25, 0.5
>>> mean, var, skew, kurt = norminvgauss.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(norminvgauss.ppf(0.01, a, b),
...                 norminvgauss.ppf(0.99, a, b), 100)
>>> ax.plot(x, norminvgauss.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='norminvgauss pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = norminvgauss(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = norminvgauss.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], norminvgauss.cdf(vals, a, b))
True

Generate random numbers:

>>> r = norminvgauss.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

obrientransform:
Firma: (*samples)

Docstring:
Compute the O'Brien transform on input data (any number of arrays).

Used to test for homogeneity of variance prior to running one-way stats.
Each array in ``*samples`` is one level of a factor.
If `f_oneway` is run on the transformed data and found significant,
the variances are unequal.  From Maxwell and Delaney [1]_, p.112.

Parameters
----------
sample1, sample2, ... : array_like
    Any number of arrays.

Returns
-------
obrientransform : ndarray
    Transformed data for use in an ANOVA.  The first dimension
    of the result corresponds to the sequence of transformed
    arrays.  If the arrays given are all 1-D of the same length,
    the return value is a 2-D array; otherwise it is a 1-D array
    of type object, with each element being an ndarray.

Raises
------
ValueError
    If the mean of the transformed data is not equal to the original
    variance, indicating a lack of convergence in the O'Brien transform.

References
----------
.. [1] S. E. Maxwell and H. D. Delaney, "Designing Experiments and
       Analyzing Data: A Model Comparison Perspective", Wadsworth, 1990.

Examples
--------
We'll test the following data sets for differences in their variance.

>>> x = [10, 11, 13, 9, 7, 12, 12, 9, 10]
>>> y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]

Apply the O'Brien transform to the data.

>>> from scipy.stats import obrientransform
>>> tx, ty = obrientransform(x, y)

Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the
transformed data.

>>> from scipy.stats import f_oneway
>>> F, p = f_oneway(tx, ty)
>>> p
0.1314139477040335

If we require that ``p < 0.05`` for significance, we cannot conclude
that the variances are different.
================================================================================

order_statistic:
Firma: (X, /, *, r, n)

Docstring:
Probability distribution of an order statistic

Returns a random variable that follows the distribution underlying the
:math:`r^{\text{th}}` order statistic of a sample of :math:`n`
observations of a random variable :math:`X`.

Parameters
----------
X : `ContinuousDistribution`
    The random variable :math:`X`
r : array_like
    The (positive integer) rank of the order statistic :math:`r`
n : array_like
    The (positive integer) sample size :math:`n`

Returns
-------
Y : `ContinuousDistribution`
    A random variable that follows the distribution of the prescribed
    order statistic.

Notes
-----
If we make :math:`n` observations of a continuous random variable
:math:`X` and sort them in increasing order
:math:`X_{(1)}, \dots, X_{(r)}, \dots, X_{(n)}`,
:math:`X_{(r)}` is known as the :math:`r^{\text{th}}` order statistic.

If the PDF, CDF, and CCDF underlying math:`X` are denoted :math:`f`,
:math:`F`, and :math:`F'`, respectively, then the PDF underlying
math:`X_{(r)}` is given by:

.. math::

    f_r(x) = \frac{n!}{(r-1)! (n-r)!} f(x) F(x)^{r-1} F'(x)^{n - r}

The CDF and other methods of the distribution underlying :math:`X_{(r)}`
are calculated using the fact that :math:`X = F^{-1}(U)`, where :math:`U` is
a standard uniform random variable, and that the order statistics of
observations of `U` follow a beta distribution, :math:`B(r, n - r + 1)`.

References
----------
.. [1] Order statistic. *Wikipedia*. https://en.wikipedia.org/wiki/Order_statistic

Examples
--------
Suppose we are interested in order statistics of samples of size five drawn
from the standard normal distribution. Plot the PDF underlying each
order statistic and compare with a normalized histogram from simulation.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>>
>>> X = stats.Normal()
>>> data = X.sample(shape=(10000, 5))
>>> sorted = np.sort(data, axis=1)
>>> Y = stats.order_statistic(X, r=[1, 2, 3, 4, 5], n=5)
>>>
>>> ax = plt.gca()
>>> colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
>>> for i in range(5):
...     y = sorted[:, i]
...     ax.hist(y, density=True, bins=30, alpha=0.1, color=colors[i])
>>> Y.plot(ax=ax)
>>> plt.show()
================================================================================

ortho_group:
Firma: (dim=None, seed=None)

Docstring:
An Orthogonal matrix (O(N)) random variable.

Return a random orthogonal matrix, drawn from the O(N) Haar
distribution (the only uniform distribution on O(N)).

The `dim` keyword specifies the dimension N.

Methods
-------
rvs(dim=None, size=1, random_state=None)
    Draw random samples from O(N).

Parameters
----------
dim : scalar
    Dimension of matrices
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
This class is closely related to `special_ortho_group`.

Some care is taken to avoid numerical error, as per the paper by Mezzadri.

References
----------
.. [1] F. Mezzadri, "How to generate random matrices from the classical
       compact groups", :arXiv:`math-ph/0609050v2`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import ortho_group
>>> x = ortho_group.rvs(3)

>>> np.dot(x, x.T)
array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],
       [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],
       [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])

>>> import scipy.linalg
>>> np.fabs(scipy.linalg.det(x))
1.0

This generates one random matrix from O(3). It is orthogonal and
has a determinant of +1 or -1.

Alternatively, the object may be called (as a function) to fix the `dim`
parameter, returning a "frozen" ortho_group random variable:

>>> rv = ortho_group(5)
>>> # Frozen object with the same methods but holding the
>>> # dimension parameter fixed.

See Also
--------
special_ortho_group
================================================================================

page_trend_test:
Firma: (data, ranked=False, predicted_ranks=None, method='auto')

Docstring:
Perform Page's Test, a measure of trend in observations between treatments.

Page's Test (also known as Page's :math:`L` test) is useful when:

* there are :math:`n \geq 3` treatments,
* :math:`m \geq 2` subjects are observed for each treatment, and
* the observations are hypothesized to have a particular order.

Specifically, the test considers the null hypothesis that

.. math::

    m_1 = m_2 = m_3 \cdots = m_n,

where :math:`m_j` is the mean of the observed quantity under treatment
:math:`j`, against the alternative hypothesis that

.. math::

    m_1 \leq m_2 \leq m_3 \leq \cdots \leq m_n,

where at least one inequality is strict.

As noted by [4]_, Page's :math:`L` test has greater statistical power than
the Friedman test against the alternative that there is a difference in
trend, as Friedman's test only considers a difference in the means of the
observations without considering their order. Whereas Spearman :math:`\rho`
considers the correlation between the ranked observations of two variables
(e.g. the airspeed velocity of a swallow vs. the weight of the coconut it
carries), Page's :math:`L` is concerned with a trend in an observation
(e.g. the airspeed velocity of a swallow) across several distinct
treatments (e.g. carrying each of five coconuts of different weight) even
as the observation is repeated with multiple subjects (e.g. one European
swallow and one African swallow).

Parameters
----------
data : array-like
    A :math:`m \times n` array; the element in row :math:`i` and
    column :math:`j` is the observation corresponding with subject
    :math:`i` and treatment :math:`j`. By default, the columns are
    assumed to be arranged in order of increasing predicted mean.

ranked : boolean, optional
    By default, `data` is assumed to be observations rather than ranks;
    it will be ranked with `scipy.stats.rankdata` along ``axis=1``. If
    `data` is provided in the form of ranks, pass argument ``True``.

predicted_ranks : array-like, optional
    The predicted ranks of the column means. If not specified,
    the columns are assumed to be arranged in order of increasing
    predicted mean, so the default `predicted_ranks` are
    :math:`[1, 2, \dots, n-1, n]`.

method : {'auto', 'asymptotic', 'exact'}, optional
    Selects the method used to calculate the *p*-value. The following
    options are available.

    * 'auto': selects between 'exact' and 'asymptotic' to
      achieve reasonably accurate results in reasonable time (default)
    * 'asymptotic': compares the standardized test statistic against
      the normal distribution
    * 'exact': computes the exact *p*-value by comparing the observed
      :math:`L` statistic against those realized by all possible
      permutations of ranks (under the null hypothesis that each
      permutation is equally likely)

Returns
-------
res : PageTrendTestResult
    An object containing attributes:

    statistic : float
        Page's :math:`L` test statistic.
    pvalue : float
        The associated *p*-value
    method : {'asymptotic', 'exact'}
        The method used to compute the *p*-value

See Also
--------
rankdata, friedmanchisquare, spearmanr

Notes
-----
As noted in [1]_, "the :math:`n` 'treatments' could just as well represent
:math:`n` objects or events or performances or persons or trials ranked."
Similarly, the :math:`m` 'subjects' could equally stand for :math:`m`
"groupings by ability or some other control variable, or judges doing
the ranking, or random replications of some other sort."

The procedure for calculating the :math:`L` statistic, adapted from
[1]_, is:

1. "Predetermine with careful logic the appropriate hypotheses
   concerning the predicted ordering of the experimental results.
   If no reasonable basis for ordering any treatments is known, the
   :math:`L` test is not appropriate."
2. "As in other experiments, determine at what level of confidence
   you will reject the null hypothesis that there is no agreement of
   experimental results with the monotonic hypothesis."
3. "Cast the experimental material into a two-way table of :math:`n`
   columns (treatments, objects ranked, conditions) and :math:`m`
   rows (subjects, replication groups, levels of control variables)."
4. "When experimental observations are recorded, rank them across each
   row", e.g. ``ranks = scipy.stats.rankdata(data, axis=1)``.
5. "Add the ranks in each column", e.g.
   ``colsums = np.sum(ranks, axis=0)``.
6. "Multiply each sum of ranks by the predicted rank for that same
   column", e.g. ``products = predicted_ranks * colsums``.
7. "Sum all such products", e.g. ``L = products.sum()``.

[1]_ continues by suggesting use of the standardized statistic

.. math::

    \chi_L^2 = \frac{\left[12L-3mn(n+1)^2\right]^2}{mn^2(n^2-1)(n+1)}

"which is distributed approximately as chi-square with 1 degree of
freedom. The ordinary use of :math:`\chi^2` tables would be
equivalent to a two-sided test of agreement. If a one-sided test
is desired, *as will almost always be the case*, the probability
discovered in the chi-square table should be *halved*."

However, this standardized statistic does not distinguish between the
observed values being well correlated with the predicted ranks and being
_anti_-correlated with the predicted ranks. Instead, we follow [2]_
and calculate the standardized statistic

.. math::

    \Lambda = \frac{L - E_0}{\sqrt{V_0}},

where :math:`E_0 = \frac{1}{4} mn(n+1)^2` and
:math:`V_0 = \frac{1}{144} mn^2(n+1)(n^2-1)`, "which is asymptotically
normal under the null hypothesis".

The *p*-value for ``method='exact'`` is generated by comparing the observed
value of :math:`L` against the :math:`L` values generated for all
:math:`(n!)^m` possible permutations of ranks. The calculation is performed
using the recursive method of [5].

The *p*-values are not adjusted for the possibility of ties. When
ties are present, the reported  ``'exact'`` *p*-values may be somewhat
larger (i.e. more conservative) than the true *p*-value [2]_. The
``'asymptotic'``` *p*-values, however, tend to be smaller (i.e. less
conservative) than the ``'exact'`` *p*-values.

References
----------
.. [1] Ellis Batten Page, "Ordered hypotheses for multiple treatments:
   a significant test for linear ranks", *Journal of the American
   Statistical Association* 58(301), p. 216--230, 1963.

.. [2] Markus Neuhauser, *Nonparametric Statistical Test: A computational
   approach*, CRC Press, p. 150--152, 2012.

.. [3] Statext LLC, "Page's L Trend Test - Easy Statistics", *Statext -
   Statistics Study*, https://www.statext.com/practice/PageTrendTest03.php,
   Accessed July 12, 2020.

.. [4] "Page's Trend Test", *Wikipedia*, WikimediaFoundation,
   https://en.wikipedia.org/wiki/Page%27s_trend_test,
   Accessed July 12, 2020.

.. [5] Robert E. Odeh, "The exact distribution of Page's L-statistic in
   the two-way layout", *Communications in Statistics - Simulation and
   Computation*,  6(1), p. 49--61, 1977.

Examples
--------
We use the example from [3]_: 10 students are asked to rate three
teaching methods - tutorial, lecture, and seminar - on a scale of 1-5,
with 1 being the lowest and 5 being the highest. We have decided that
a confidence level of 99% is required to reject the null hypothesis in
favor of our alternative: that the seminar will have the highest ratings
and the tutorial will have the lowest. Initially, the data have been
tabulated with each row representing an individual student's ratings of
the three methods in the following order: tutorial, lecture, seminar.

>>> table = [[3, 4, 3],
...          [2, 2, 4],
...          [3, 3, 5],
...          [1, 3, 2],
...          [2, 3, 2],
...          [2, 4, 5],
...          [1, 2, 4],
...          [3, 4, 4],
...          [2, 4, 5],
...          [1, 3, 4]]

Because the tutorial is hypothesized to have the lowest ratings, the
column corresponding with tutorial rankings should be first; the seminar
is hypothesized to have the highest ratings, so its column should be last.
Since the columns are already arranged in this order of increasing
predicted mean, we can pass the table directly into `page_trend_test`.

>>> from scipy.stats import page_trend_test
>>> res = page_trend_test(table)
>>> res
PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822,
                    method='exact')

This *p*-value indicates that there is a 0.1819% chance that
the :math:`L` statistic would reach such an extreme value under the null
hypothesis. Because 0.1819% is less than 1%, we have evidence to reject
the null hypothesis in favor of our alternative at a 99% confidence level.

The value of the :math:`L` statistic is 133.5. To check this manually,
we rank the data such that high scores correspond with high ranks, settling
ties with an average rank:

>>> from scipy.stats import rankdata
>>> ranks = rankdata(table, axis=1)
>>> ranks
array([[1.5, 3. , 1.5],
       [1.5, 1.5, 3. ],
       [1.5, 1.5, 3. ],
       [1. , 3. , 2. ],
       [1.5, 3. , 1.5],
       [1. , 2. , 3. ],
       [1. , 2. , 3. ],
       [1. , 2.5, 2.5],
       [1. , 2. , 3. ],
       [1. , 2. , 3. ]])

We add the ranks within each column, multiply the sums by the
predicted ranks, and sum the products.

>>> import numpy as np
>>> m, n = ranks.shape
>>> predicted_ranks = np.arange(1, n+1)
>>> L = (predicted_ranks * np.sum(ranks, axis=0)).sum()
>>> res.statistic == L
True

As presented in [3]_, the asymptotic approximation of the *p*-value is the
survival function of the normal distribution evaluated at the standardized
test statistic:

>>> from scipy.stats import norm
>>> E0 = (m*n*(n+1)**2)/4
>>> V0 = (m*n**2*(n+1)*(n**2-1))/144
>>> Lambda = (L-E0)/np.sqrt(V0)
>>> p = norm.sf(Lambda)
>>> p
0.0012693433690751756

This does not precisely match the *p*-value reported by `page_trend_test`
above. The asymptotic distribution is not very accurate, nor conservative,
for :math:`m \leq 12` and :math:`n \leq 8`, so `page_trend_test` chose to
use ``method='exact'`` based on the dimensions of the table and the
recommendations in Page's original paper [1]_. To override
`page_trend_test`'s choice, provide the `method` argument.

>>> res = page_trend_test(table, method="asymptotic")
>>> res
PageTrendTestResult(statistic=133.5, pvalue=0.0012693433690751756,
                    method='asymptotic')

If the data are already ranked, we can pass in the ``ranks`` instead of
the ``table`` to save computation time.

>>> res = page_trend_test(ranks,             # ranks of data
...                       ranked=True,       # data is already ranked
...                       )
>>> res
PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822,
                    method='exact')

Suppose the raw data had been tabulated in an order different from the
order of predicted means, say lecture, seminar, tutorial.

>>> table = np.asarray(table)[:, [1, 2, 0]]

Since the arrangement of this table is not consistent with the assumed
ordering, we can either rearrange the table or provide the
`predicted_ranks`. Remembering that the lecture is predicted
to have the middle rank, the seminar the highest, and tutorial the lowest,
we pass:

>>> res = page_trend_test(table,             # data as originally tabulated
...                       predicted_ranks=[2, 3, 1],  # our predicted order
...                       )
>>> res
PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822,
                    method='exact')
================================================================================

pareto:
Firma: (*args, **kwds)

Docstring:
A Pareto continuous random variable.

As an instance of the `rv_continuous` class, `pareto` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, b, loc=0, scale=1)
    Probability density function.
logpdf(x, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(b,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(b, loc=0, scale=1)
    Median of the distribution.
mean(b, loc=0, scale=1)
    Mean of the distribution.
var(b, loc=0, scale=1)
    Variance of the distribution.
std(b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `pareto` is:

.. math::

    f(x, b) = \frac{b}{x^{b+1}}

for :math:`x \ge 1`, :math:`b > 0`.

`pareto` takes ``b`` as a shape parameter for :math:`b`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``pareto.pdf(x, b, loc, scale)`` is identically
equivalent to ``pareto.pdf(y, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import pareto
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> b = 2.62
>>> mean, var, skew, kurt = pareto.stats(b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(pareto.ppf(0.01, b),
...                 pareto.ppf(0.99, b), 100)
>>> ax.plot(x, pareto.pdf(x, b),
...        'r-', lw=5, alpha=0.6, label='pareto pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = pareto(b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = pareto.ppf([0.001, 0.5, 0.999], b)
>>> np.allclose([0.001, 0.5, 0.999], pareto.cdf(vals, b))
True

Generate random numbers:

>>> r = pareto.rvs(b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

pearson3:
Firma: (*args, **kwds)

Docstring:
A pearson type III continuous random variable.

As an instance of the `rv_continuous` class, `pearson3` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(skew, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, skew, loc=0, scale=1)
    Probability density function.
logpdf(x, skew, loc=0, scale=1)
    Log of the probability density function.
cdf(x, skew, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, skew, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, skew, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, skew, loc=0, scale=1)
    Log of the survival function.
ppf(q, skew, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, skew, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, skew, loc=0, scale=1)
    Non-central moment of the specified order.
stats(skew, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(skew, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(skew,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(skew, loc=0, scale=1)
    Median of the distribution.
mean(skew, loc=0, scale=1)
    Mean of the distribution.
var(skew, loc=0, scale=1)
    Variance of the distribution.
std(skew, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, skew, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `pearson3` is:

.. math::

    f(x, \kappa) = \frac{|\beta|}{\Gamma(\alpha)}
                   (\beta (x - \zeta))^{\alpha - 1}
                   \exp(-\beta (x - \zeta))

where:

.. math::

        \beta = \frac{2}{\kappa}

        \alpha = \beta^2 = \frac{4}{\kappa^2}

        \zeta = -\frac{\alpha}{\beta} = -\beta

:math:`\Gamma` is the gamma function (`scipy.special.gamma`).
Pass the skew :math:`\kappa` into `pearson3` as the shape parameter
``skew``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``pearson3.pdf(x, skew, loc, scale)`` is identically
equivalent to ``pearson3.pdf(y, skew) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import pearson3
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> skew = -2
>>> mean, var, skew, kurt = pearson3.stats(skew, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(pearson3.ppf(0.01, skew),
...                 pearson3.ppf(0.99, skew), 100)
>>> ax.plot(x, pearson3.pdf(x, skew),
...        'r-', lw=5, alpha=0.6, label='pearson3 pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = pearson3(skew)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = pearson3.ppf([0.001, 0.5, 0.999], skew)
>>> np.allclose([0.001, 0.5, 0.999], pearson3.cdf(vals, skew))
True

Generate random numbers:

>>> r = pearson3.rvs(skew, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


References
----------
R.W. Vogel and D.E. McMartin, "Probability Plot Goodness-of-Fit and
Skewness Estimation Procedures for the Pearson Type 3 Distribution", Water
Resources Research, Vol.27, 3149-3158 (1991).

L.R. Salvosa, "Tables of Pearson's Type III Function", Ann. Math. Statist.,
Vol.1, 191-198 (1930).

"Using Modern Computing Tools to Fit the Pearson Type III Distribution to
Aviation Loads Data", Office of Aviation Research (2003).
================================================================================

pearsonr:
Firma: (x, y, *, alternative='two-sided', method=None, axis=0)

Docstring:
Pearson correlation coefficient and p-value for testing non-correlation.

The Pearson correlation coefficient [1]_ measures the linear relationship
between two datasets. Like other correlation
coefficients, this one varies between -1 and +1 with 0 implying no
correlation. Correlations of -1 or +1 imply an exact linear relationship.
Positive correlations imply that as x increases, so does y. Negative
correlations imply that as x increases, y decreases.

This function also performs a test of the null hypothesis that the
distributions underlying the samples are uncorrelated and normally
distributed. (See Kowalski [3]_
for a discussion of the effects of non-normality of the input on the
distribution of the correlation coefficient.)
The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Pearson correlation at least as extreme
as the one computed from these datasets.

Parameters
----------
x : array_like
    Input array.
y : array_like
    Input array.
axis : int or None, default
    Axis along which to perform the calculation. Default is 0.
    If None, ravel both arrays before performing the calculation.

    .. versionadded:: 1.13.0
alternative : {'two-sided', 'greater', 'less'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the correlation is nonzero
    * 'less': the correlation is negative (less than zero)
    * 'greater':  the correlation is positive (greater than zero)

    .. versionadded:: 1.9.0
method : ResamplingMethod, optional
    Defines the method used to compute the p-value. If `method` is an
    instance of `PermutationMethod`/`MonteCarloMethod`, the p-value is
    computed using
    `scipy.stats.permutation_test`/`scipy.stats.monte_carlo_test` with the
    provided configuration options and other appropriate settings.
    Otherwise, the p-value is computed as documented in the notes.

    .. versionadded:: 1.11.0

Returns
-------
result : `~scipy.stats._result_classes.PearsonRResult`
    An object with the following attributes:

    statistic : float
        Pearson product-moment correlation coefficient.
    pvalue : float
        The p-value associated with the chosen alternative.

    The object has the following method:

    confidence_interval(confidence_level, method)
        This computes the confidence interval of the correlation
        coefficient `statistic` for the given confidence level.
        The confidence interval is returned in a ``namedtuple`` with
        fields `low` and `high`. If `method` is not provided, the
        confidence interval is computed using the Fisher transformation
        [1]_. If `method` is an instance of `BootstrapMethod`, the
        confidence interval is computed using `scipy.stats.bootstrap` with
        the provided configuration options and other appropriate settings.
        In some cases, confidence limits may be NaN due to a degenerate
        resample, and this is typical for very small samples (~6
        observations).

Raises
------
ValueError
    If `x` and `y` do not have length at least 2.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if an input is a constant array.  The correlation coefficient
    is not defined in this case, so ``np.nan`` is returned.

`~scipy.stats.NearConstantInputWarning`
    Raised if an input is "nearly" constant.  The array ``x`` is considered
    nearly constant if ``norm(x - mean(x)) < 1e-13 * abs(mean(x))``.
    Numerical errors in the calculation ``x - mean(x)`` in this case might
    result in an inaccurate calculation of r.

See Also
--------
spearmanr : Spearman rank-order correlation coefficient.
kendalltau : Kendall's tau, a correlation measure for ordinal data.

Notes
-----
The correlation coefficient is calculated as follows:

.. math::

    r = \frac{\sum (x - m_x) (y - m_y)}
             {\sqrt{\sum (x - m_x)^2 \sum (y - m_y)^2}}

where :math:`m_x` is the mean of the vector x and :math:`m_y` is
the mean of the vector y.

Under the assumption that x and y are drawn from
independent normal distributions (so the population correlation coefficient
is 0), the probability density function of the sample correlation
coefficient r is ([1]_, [2]_):

.. math::
    f(r) = \frac{{(1-r^2)}^{n/2-2}}{\mathrm{B}(\frac{1}{2},\frac{n}{2}-1)}

where n is the number of samples, and B is the beta function.  This
is sometimes referred to as the exact distribution of r.  This is
the distribution that is used in `pearsonr` to compute the p-value when
the `method` parameter is left at its default value (None).
The distribution is a beta distribution on the interval [-1, 1],
with equal shape parameters a = b = n/2 - 1.  In terms of SciPy's
implementation of the beta distribution, the distribution of r is::

    dist = scipy.stats.beta(n/2 - 1, n/2 - 1, loc=-1, scale=2)

The default p-value returned by `pearsonr` is a two-sided p-value. For a
given sample with correlation coefficient r, the p-value is
the probability that abs(r') of a random sample x' and y' drawn from
the population with zero correlation would be greater than or equal
to abs(r). In terms of the object ``dist`` shown above, the p-value
for a given r and length n can be computed as::

    p = 2*dist.cdf(-abs(r))

When n is 2, the above continuous distribution is not well-defined.
One can interpret the limit of the beta distribution as the shape
parameters a and b approach a = b = 0 as a discrete distribution with
equal probability masses at r = 1 and r = -1.  More directly, one
can observe that, given the data x = [x1, x2] and y = [y1, y2], and
assuming x1 != x2 and y1 != y2, the only possible values for r are 1
and -1.  Because abs(r') for any sample x' and y' with length 2 will
be 1, the two-sided p-value for a sample of length 2 is always 1.

For backwards compatibility, the object that is returned also behaves
like a tuple of length two that holds the statistic and the p-value.

References
----------
.. [1] "Pearson correlation coefficient", Wikipedia,
       https://en.wikipedia.org/wiki/Pearson_correlation_coefficient
.. [2] Student, "Probable error of a correlation coefficient",
       Biometrika, Volume 6, Issue 2-3, 1 September 1908, pp. 302-310.
.. [3] C. J. Kowalski, "On the Effects of Non-Normality on the Distribution
       of the Sample Product-Moment Correlation Coefficient"
       Journal of the Royal Statistical Society. Series C (Applied
       Statistics), Vol. 21, No. 1 (1972), pp. 1-12.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x, y = [1, 2, 3, 4, 5, 6, 7], [10, 9, 2.5, 6, 4, 3, 2]
>>> res = stats.pearsonr(x, y)
>>> res
PearsonRResult(statistic=-0.828503883588428, pvalue=0.021280260007523286)

To perform an exact permutation version of the test:

>>> rng = np.random.default_rng(7796654889291491997)
>>> method = stats.PermutationMethod(n_resamples=np.inf, random_state=rng)
>>> stats.pearsonr(x, y, method=method)
PearsonRResult(statistic=-0.828503883588428, pvalue=0.028174603174603175)

To perform the test under the null hypothesis that the data were drawn from
*uniform* distributions:

>>> method = stats.MonteCarloMethod(rvs=(rng.uniform, rng.uniform))
>>> stats.pearsonr(x, y, method=method)
PearsonRResult(statistic=-0.828503883588428, pvalue=0.0188)

To produce an asymptotic 90% confidence interval:

>>> res.confidence_interval(confidence_level=0.9)
ConfidenceInterval(low=-0.9644331982722841, high=-0.3460237473272273)

And for a bootstrap confidence interval:

>>> method = stats.BootstrapMethod(method='BCa', rng=rng)
>>> res.confidence_interval(confidence_level=0.9, method=method)
ConfidenceInterval(low=-0.9983163756488651, high=-0.22771001702132443)  # may vary

If N-dimensional arrays are provided, multiple tests are performed in a
single call according to the same conventions as most `scipy.stats` functions:

>>> rng = np.random.default_rng(2348246935601934321)
>>> x = rng.standard_normal((8, 15))
>>> y = rng.standard_normal((8, 15))
>>> stats.pearsonr(x, y, axis=0).statistic.shape  # between corresponding columns
(15,)
>>> stats.pearsonr(x, y, axis=1).statistic.shape  # between corresponding rows
(8,)

To perform all pairwise comparisons between slices of the arrays,
use standard NumPy broadcasting techniques. For instance, to compute the
correlation between all pairs of rows:

>>> stats.pearsonr(x[:, np.newaxis, :], y, axis=-1).statistic.shape
(8, 8)

There is a linear dependence between x and y if y = a + b*x + e, where
a,b are constants and e is a random error term, assumed to be independent
of x. For simplicity, assume that x is standard normal, a=0, b=1 and let
e follow a normal distribution with mean zero and standard deviation s>0.

>>> rng = np.random.default_rng()
>>> s = 0.5
>>> x = stats.norm.rvs(size=500, random_state=rng)
>>> e = stats.norm.rvs(scale=s, size=500, random_state=rng)
>>> y = x + e
>>> stats.pearsonr(x, y).statistic
0.9001942438244763

This should be close to the exact value given by

>>> 1/np.sqrt(1 + s**2)
0.8944271909999159

For s=0.5, we observe a high level of correlation. In general, a large
variance of the noise reduces the correlation, while the correlation
approaches one as the variance of the error goes to zero.

It is important to keep in mind that no correlation does not imply
independence unless (x, y) is jointly normal. Correlation can even be zero
when there is a very simple dependence structure: if X follows a
standard normal distribution, let y = abs(x). Note that the correlation
between x and y is zero. Indeed, since the expectation of x is zero,
cov(x, y) = E[x*y]. By definition, this equals E[x*abs(x)] which is zero
by symmetry. The following lines of code illustrate this observation:

>>> y = np.abs(x)
>>> stats.pearsonr(x, y)
PearsonRResult(statistic=-0.05444919272687482, pvalue=0.22422294836207743)

A non-zero correlation coefficient can be misleading. For example, if X has
a standard normal distribution, define y = x if x < 0 and y = 0 otherwise.
A simple calculation shows that corr(x, y) = sqrt(2/Pi) = 0.797...,
implying a high level of correlation:

>>> y = np.where(x < 0, x, 0)
>>> stats.pearsonr(x, y)
PearsonRResult(statistic=0.861985781588, pvalue=4.813432002751103e-149)

This is unintuitive since there is no dependence of x and y if x is larger
than zero which happens in about half of the cases if we sample x and y.
================================================================================

percentileofscore:
Firma: (a, score, kind='rank', nan_policy='propagate')

Docstring:
Compute the percentile rank of a score relative to a list of scores.

A `percentileofscore` of, for example, 80% means that 80% of the
scores in `a` are below the given score. In the case of gaps or
ties, the exact definition depends on the optional keyword, `kind`.

Parameters
----------
a : array_like
    A 1-D array to which `score` is compared.
score : array_like
    Scores to compute percentiles for.
kind : {'rank', 'weak', 'strict', 'mean'}, optional
    Specifies the interpretation of the resulting score.
    The following options are available (default is 'rank'):

      * 'rank': Average percentage ranking of score.  In case of multiple
        matches, average the percentage rankings of all matching scores.
      * 'weak': This kind corresponds to the definition of a cumulative
        distribution function.  A percentileofscore of 80% means that 80%
        of values are less than or equal to the provided score.
      * 'strict': Similar to "weak", except that only values that are
        strictly less than the given score are counted.
      * 'mean': The average of the "weak" and "strict" scores, often used
        in testing.  See https://en.wikipedia.org/wiki/Percentile_rank
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Specifies how to treat `nan` values in `a`.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan (for each value in `score`).
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
pcos : float
    Percentile-position of score (0-100) relative to `a`.

See Also
--------
numpy.percentile
scipy.stats.scoreatpercentile, scipy.stats.rankdata

Examples
--------
Three-quarters of the given values lie below a given score:

>>> import numpy as np
>>> from scipy import stats
>>> stats.percentileofscore([1, 2, 3, 4], 3)
75.0

With multiple matches, note how the scores of the two matches, 0.6
and 0.8 respectively, are averaged:

>>> stats.percentileofscore([1, 2, 3, 3, 4], 3)
70.0

Only 2/5 values are strictly less than 3:

>>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='strict')
40.0

But 4/5 values are less than or equal to 3:

>>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='weak')
80.0

The average between the weak and the strict scores is:

>>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='mean')
60.0

Score arrays (of any dimensionality) are supported:

>>> stats.percentileofscore([1, 2, 3, 3, 4], [2, 3])
array([40., 70.])

The inputs can be infinite:

>>> stats.percentileofscore([-np.inf, 0, 1, np.inf], [1, 2, np.inf])
array([75., 75., 100.])

If `a` is empty, then the resulting percentiles are all `nan`:

>>> stats.percentileofscore([], [1, 2])
array([nan, nan])
================================================================================

permutation_test:
Firma: (data, statistic, *, permutation_type='independent', vectorized=None, n_resamples=9999, batch=None, alternative='two-sided', axis=0, rng=None)

Docstring:
Performs a permutation test of a given statistic on provided data.

For independent sample statistics, the null hypothesis is that the data are
randomly sampled from the same distribution.
For paired sample statistics, two null hypothesis can be tested:
that the data are paired at random or that the data are assigned to samples
at random.

Parameters
----------
data : iterable of array-like
    Contains the samples, each of which is an array of observations.
    Dimensions of sample arrays must be compatible for broadcasting except
    along `axis`.
statistic : callable
    Statistic for which the p-value of the hypothesis test is to be
    calculated. `statistic` must be a callable that accepts samples
    as separate arguments (e.g. ``statistic(*data)``) and returns the
    resulting statistic.
    If `vectorized` is set ``True``, `statistic` must also accept a keyword
    argument `axis` and be vectorized to compute the statistic along the
    provided `axis` of the sample arrays.
permutation_type : {'independent', 'samples', 'pairings'}, optional
    The type of permutations to be performed, in accordance with the
    null hypothesis. The first two permutation types are for paired sample
    statistics, in which all samples contain the same number of
    observations and observations with corresponding indices along `axis`
    are considered to be paired; the third is for independent sample
    statistics.
    
    - ``'samples'`` : observations are assigned to different samples
      but remain paired with the same observations from other samples.
      This permutation type is appropriate for paired sample hypothesis
      tests such as the Wilcoxon signed-rank test and the paired t-test.
    - ``'pairings'`` : observations are paired with different observations,
      but they remain within the same sample. This permutation type is
      appropriate for association/correlation tests with statistics such
      as Spearman's :math:`\rho`, Kendall's :math:`\tau`, and Pearson's
      :math:`r`.
    - ``'independent'`` (default) : observations are assigned to different
      samples. Samples may contain different numbers of observations. This
      permutation type is appropriate for independent sample hypothesis
      tests such as the Mann-Whitney :math:`U` test and the independent
      sample t-test.
    
      Please see the Notes section below for more detailed descriptions
      of the permutation types.
vectorized : bool, optional
    If `vectorized` is set ``False``, `statistic` will not be passed
    keyword argument `axis` and is expected to calculate the statistic
    only for 1D samples. If ``True``, `statistic` will be passed keyword
    argument `axis` and is expected to calculate the statistic along `axis`
    when passed an ND sample array. If ``None`` (default), `vectorized`
    will be set ``True`` if ``axis`` is a parameter of `statistic`. Use
    of a vectorized statistic typically reduces computation time.
n_resamples : int or np.inf, default: 9999
    Number of random permutations (resamples) used to approximate the null
    distribution. If greater than or equal to the number of distinct
    permutations, the exact null distribution will be computed.
    Note that the number of distinct permutations grows very rapidly with
    the sizes of samples, so exact tests are feasible only for very small
    data sets.
batch : int, optional
    The number of permutations to process in each call to `statistic`.
    Memory usage is O( `batch` * ``n`` ), where ``n`` is the total size
    of all samples, regardless of the value of `vectorized`. Default is
    ``None``, in which case ``batch`` is the number of permutations.
alternative : {'two-sided', 'less', 'greater'}, optional
    The alternative hypothesis for which the p-value is calculated.
    For each alternative, the p-value is defined for exact tests as
    follows.
    
    - ``'greater'`` : the percentage of the null distribution that is
      greater than or equal to the observed value of the test statistic.
    - ``'less'`` : the percentage of the null distribution that is
      less than or equal to the observed value of the test statistic.
    - ``'two-sided'`` (default) : twice the smaller of the p-values above.
    
    Note that p-values for randomized tests are calculated according to the
    conservative (over-estimated) approximation suggested in [2]_ and [3]_
    rather than the unbiased estimator suggested in [4]_. That is, when
    calculating the proportion of the randomized null distribution that is
    as extreme as the observed value of the test statistic, the values in
    the numerator and denominator are both increased by one. An
    interpretation of this adjustment is that the observed value of the
    test statistic is always included as an element of the randomized
    null distribution.
    The convention used for two-sided p-values is not universal;
    the observed test statistic and null distribution are returned in
    case a different definition is preferred.
axis : int, default: 0
    The axis of the (broadcasted) samples over which to calculate the
    statistic. If samples have a different number of dimensions,
    singleton dimensions are prepended to samples with fewer dimensions
    before `axis` is considered.
rng : {None, int, `numpy.random.Generator`}, optional
    If `rng` is passed by keyword, types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.
    If `rng` is already a ``Generator`` instance, then the provided instance is
    used. Specify `rng` for repeatable function behavior.

    If this argument is passed by position or `random_state` is passed by keyword,
    legacy behavior for the argument `random_state` applies:

    - If `random_state` is None (or `numpy.random`), the `numpy.random.RandomState`
      singleton is used.
    - If `random_state` is an int, a new ``RandomState`` instance is used,
      seeded with `random_state`.
    - If `random_state` is already a ``Generator`` or ``RandomState`` instance then
      that instance is used.

    .. versionchanged:: 1.15.0
        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this keyword was changed from `random_state` to `rng`.
        For an interim period, both keywords will continue to work, although only one
        may be specified at a time. After the interim period, function calls using the
        `random_state` keyword will emit warnings. The behavior of both `random_state` and
        `rng` are outlined above, but only the `rng` keyword should be used in new code.
        

Returns
-------
res : PermutationTestResult
    An object with attributes:
    
    statistic : float or ndarray
        The observed test statistic of the data.
    pvalue : float or ndarray
        The p-value for the given alternative.
    null_distribution : ndarray
        The values of the test statistic generated under the null
        hypothesis.

Notes
-----
The three types of permutation tests supported by this function are
described below.

**Unpaired statistics** (``permutation_type='independent'``):

The null hypothesis associated with this permutation type is that all
observations are sampled from the same underlying distribution and that
they have been assigned to one of the samples at random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
When ``1 < n_resamples < binom(n, k)``, where

* ``k`` is the number of observations in ``a``,
* ``n`` is the total number of observations in ``a`` and ``b``, and
* ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),

the data are pooled (concatenated), randomly assigned to either the first
or second sample, and the statistic is calculated. This process is
performed repeatedly, `permutation` times, generating a distribution of the
statistic under the null hypothesis. The statistic of the original
data is compared to this distribution to determine the p-value.

When ``n_resamples >= binom(n, k)``, an exact test is performed: the data
are *partitioned* between the samples in each distinct way exactly once,
and the exact null distribution is formed.
Note that for a given partitioning of the data between the samples,
only one ordering/permutation of the data *within* each sample is
considered. For statistics that do not depend on the order of the data
within samples, this dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

For ``a = [a1, a2, a3, a4]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b3, a1, a2, b2]`` and ``y = [a4, b1, a3]``.
Because only one ordering/permutation of the data *within* each sample
is considered in an exact test, a resampling like ``x = [b3, a1, b2, a2]``
and ``y = [a4, a3, b1]`` would *not* be considered distinct from the
example above.

``permutation_type='independent'`` does not support one-sample statistics,
but it can be applied to statistics with more than two samples. In this
case, if ``n`` is an array of the number of observations within each
sample, the number of distinct partitions is::

    np.prod([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)])

**Paired statistics, permute pairings** (``permutation_type='pairings'``):

The null hypothesis associated with this permutation type is that
observations within each sample are drawn from the same underlying
distribution and that pairings with elements of other samples are
assigned at random.

Suppose ``data`` contains only one sample; e.g. ``a, = data``, and we
wish to consider all possible pairings of elements of ``a`` with elements
of a second sample, ``b``. Let ``n`` be the number of observations in
``a``, which must also equal the number of observations in ``b``.

When ``1 < n_resamples < factorial(n)``, the elements of ``a`` are
randomly permuted. The user-supplied statistic accepts one data argument,
say ``a_perm``, and calculates the statistic considering ``a_perm`` and
``b``. This process is performed repeatedly, `permutation` times,
generating a distribution of the statistic under the null hypothesis.
The statistic of the original data is compared to this distribution to
determine the p-value.

When ``n_resamples >= factorial(n)``, an exact test is performed:
``a`` is permuted in each distinct way exactly once. Therefore, the
`statistic` is computed for each unique pairing of samples between ``a``
and ``b`` exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``a_perm = [a3, a1, a2]`` while ``b`` is left
in its original order.

``permutation_type='pairings'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
All samples provided in ``data`` are permuted *independently*. Therefore,
if ``m`` is the number of samples and ``n`` is the number of observations
within each sample, then the number of permutations in an exact test is::

    factorial(n)**m

Note that if a two-sample statistic, for example, does not inherently
depend on the order in which observations are provided - only on the
*pairings* of observations - then only one of the two samples should be
provided in ``data``. This dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

**Paired statistics, permute samples** (``permutation_type='samples'``):

The null hypothesis associated with this permutation type is that
observations within each pair are drawn from the same underlying
distribution and that the sample to which they are assigned is random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
Let ``n`` be the number of observations in ``a``, which must also equal
the number of observations in ``b``.

When ``1 < n_resamples < 2**n``, the elements of ``a`` are ``b`` are
randomly swapped between samples (maintaining their pairings) and the
statistic is calculated. This process is performed repeatedly,
`permutation` times,  generating a distribution of the statistic under the
null hypothesis. The statistic of the original data is compared to this
distribution to determine the p-value.

When ``n_resamples >= 2**n``, an exact test is performed: the observations
are assigned to the two samples in each distinct way (while maintaining
pairings) exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b1, a2, b3]`` and ``y = [a1, b2, a3]``.

``permutation_type='samples'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
If ``data`` contains more than one sample, paired observations within
``data`` are exchanged between samples *independently*. Therefore, if ``m``
is the number of samples and ``n`` is the number of observations within
each sample, then the number of permutations in an exact test is::

    factorial(m)**n

Several paired-sample statistical tests, such as the Wilcoxon signed rank
test and paired-sample t-test, can be performed considering only the
*difference* between two paired elements. Accordingly, if ``data`` contains
only one sample, then the null distribution is formed by independently
changing the *sign* of each observation.

.. warning::
    The p-value is calculated by counting the elements of the null
    distribution that are as extreme or more extreme than the observed
    value of the statistic. Due to the use of finite precision arithmetic,
    some statistic functions return numerically distinct values when the
    theoretical values would be exactly equal. In some cases, this could
    lead to a large error in the calculated p-value. `permutation_test`
    guards against this by considering elements in the null distribution
    that are "close" (within a relative tolerance of 100 times the
    floating point epsilon of inexact dtypes) to the observed
    value of the test statistic as equal to the observed value of the
    test statistic. However, the user is advised to inspect the null
    distribution to assess whether this method of comparison is
    appropriate, and if not, calculate the p-value manually. See example
    below.

References
----------
.. [1] R. A. Fisher. The Design of Experiments, 6th Ed (1951).
.. [2] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
   Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
   Statistical Applications in Genetics and Molecular Biology 9.1 (2010).
.. [3] M. D. Ernst. "Permutation Methods: A Basis for Exact Inference".
   Statistical Science (2004).
.. [4] B. Efron and R. J. Tibshirani. An Introduction to the Bootstrap
   (1993).

Examples
--------
Suppose we wish to test whether two samples are drawn from the same
distribution. Assume that the underlying distributions are unknown to us,
and that before observing the data, we hypothesized that the mean of the
first sample would be less than that of the second sample. We decide that
we will use the difference between the sample means as a test statistic,
and we will consider a p-value of 0.05 to be statistically significant.

For efficiency, we write the function defining the test statistic in a
vectorized fashion: the samples ``x`` and ``y`` can be ND arrays, and the
statistic will be calculated for each axis-slice along `axis`.

>>> import numpy as np
>>> def statistic(x, y, axis):
...     return np.mean(x, axis=axis) - np.mean(y, axis=axis)

After collecting our data, we calculate the observed value of the test
statistic.

>>> from scipy.stats import norm
>>> rng = np.random.default_rng()
>>> x = norm.rvs(size=5, random_state=rng)
>>> y = norm.rvs(size=6, loc = 3, random_state=rng)
>>> statistic(x, y, 0)
-3.5411688580987266

Indeed, the test statistic is negative, suggesting that the true mean of
the distribution underlying ``x`` is less than that of the distribution
underlying ``y``. To determine the probability of this occurring by chance
if the two samples were drawn from the same distribution, we perform
a permutation test.

>>> from scipy.stats import permutation_test
>>> # because our statistic is vectorized, we pass `vectorized=True`
>>> # `n_resamples=np.inf` indicates that an exact test is to be performed
>>> res = permutation_test((x, y), statistic, vectorized=True,
...                        n_resamples=np.inf, alternative='less')
>>> print(res.statistic)
-3.5411688580987266
>>> print(res.pvalue)
0.004329004329004329

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is 0.4329%. This is less than our
chosen threshold of 5%, so we consider this to be significant evidence
against the null hypothesis in favor of the alternative.

Because the size of the samples above was small, `permutation_test` could
perform an exact test. For larger samples, we resort to a randomized
permutation test.

>>> x = norm.rvs(size=100, random_state=rng)
>>> y = norm.rvs(size=120, loc=0.2, random_state=rng)
>>> res = permutation_test((x, y), statistic, n_resamples=9999,
...                        vectorized=True, alternative='less',
...                        rng=rng)
>>> print(res.statistic)
-0.4230459671240913
>>> print(res.pvalue)
0.0015

The approximate probability of obtaining a test statistic less than or
equal to the observed value under the null hypothesis is 0.0225%. This is
again less than our chosen threshold of 5%, so again we have significant
evidence to reject the null hypothesis in favor of the alternative.

For large samples and number of permutations, the result is comparable to
that of the corresponding asymptotic test, the independent sample t-test.

>>> from scipy.stats import ttest_ind
>>> res_asymptotic = ttest_ind(x, y, alternative='less')
>>> print(res_asymptotic.pvalue)
0.0014669545224902675

The permutation distribution of the test statistic is provided for
further investigation.

>>> import matplotlib.pyplot as plt
>>> plt.hist(res.null_distribution, bins=50)
>>> plt.title("Permutation distribution of test statistic")
>>> plt.xlabel("Value of Statistic")
>>> plt.ylabel("Frequency")
>>> plt.show()

Inspection of the null distribution is essential if the statistic suffers
from inaccuracy due to limited machine precision. Consider the following
case:

>>> from scipy.stats import pearsonr
>>> x = [1, 2, 4, 3]
>>> y = [2, 4, 6, 8]
>>> def statistic(x, y, axis=-1):
...     return pearsonr(x, y, axis=axis).statistic
>>> res = permutation_test((x, y), statistic, vectorized=True,
...                        permutation_type='pairings',
...                        alternative='greater')
>>> r, pvalue, null = res.statistic, res.pvalue, res.null_distribution

In this case, some elements of the null distribution differ from the
observed value of the correlation coefficient ``r`` due to numerical noise.
We manually inspect the elements of the null distribution that are nearly
the same as the observed value of the test statistic.

>>> r
0.7999999999999999
>>> unique = np.unique(null)
>>> unique
array([-1. , -1. , -0.8, -0.8, -0.8, -0.6, -0.4, -0.4, -0.2, -0.2, -0.2,
    0. ,  0.2,  0.2,  0.2,  0.4,  0.4,  0.6,  0.8,  0.8,  0.8,  1. ,
    1. ])  # may vary
>>> unique[np.isclose(r, unique)].tolist()
[0.7999999999999998, 0.7999999999999999, 0.8]  # may vary

If `permutation_test` were to perform the comparison naively, the
elements of the null distribution with value ``0.7999999999999998`` would
not be considered as extreme or more extreme as the observed value of the
statistic, so the calculated p-value would be too small.

>>> incorrect_pvalue = np.count_nonzero(null >= r) / len(null)
>>> incorrect_pvalue
0.14583333333333334  # may vary

Instead, `permutation_test` treats elements of the null distribution that
are within ``max(1e-14, abs(r)*1e-14)`` of the observed value of the
statistic ``r`` to be equal to ``r``.

>>> correct_pvalue = np.count_nonzero(null >= r - 1e-14) / len(null)
>>> correct_pvalue
0.16666666666666666
>>> res.pvalue == correct_pvalue
True

This method of comparison is expected to be accurate in most practical
situations, but the user is advised to assess this by inspecting the
elements of the null distribution that are close to the observed value
of the statistic. Also, consider the use of statistics that can be
calculated using exact arithmetic (e.g. integer statistics).
================================================================================

planck:
Firma: (*args, **kwds)

Docstring:
A Planck discrete exponential random variable.

As an instance of the `rv_discrete` class, `planck` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(lambda_, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, lambda_, loc=0)
    Probability mass function.
logpmf(k, lambda_, loc=0)
    Log of the probability mass function.
cdf(k, lambda_, loc=0)
    Cumulative distribution function.
logcdf(k, lambda_, loc=0)
    Log of the cumulative distribution function.
sf(k, lambda_, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, lambda_, loc=0)
    Log of the survival function.
ppf(q, lambda_, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, lambda_, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(lambda_, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(lambda_, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(lambda_,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(lambda_, loc=0)
    Median of the distribution.
mean(lambda_, loc=0)
    Mean of the distribution.
var(lambda_, loc=0)
    Variance of the distribution.
std(lambda_, loc=0)
    Standard deviation of the distribution.
interval(confidence, lambda_, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `planck` is:

.. math::

    f(k) = (1-\exp(-\lambda)) \exp(-\lambda k)

for :math:`k \ge 0` and :math:`\lambda > 0`.

`planck` takes :math:`\lambda` as shape parameter. The Planck distribution
can be written as a geometric distribution (`geom`) with
:math:`p = 1 - \exp(-\lambda)` shifted by ``loc = -1``.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``planck.pmf(k, lambda_, loc)`` is identically
equivalent to ``planck.pmf(k - loc, lambda_)``.

See Also
--------
geom

Examples
--------
>>> import numpy as np
>>> from scipy.stats import planck
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> lambda_ = 0.51
>>> mean, var, skew, kurt = planck.stats(lambda_, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(planck.ppf(0.01, lambda_),
...               planck.ppf(0.99, lambda_))
>>> ax.plot(x, planck.pmf(x, lambda_), 'bo', ms=8, label='planck pmf')
>>> ax.vlines(x, 0, planck.pmf(x, lambda_), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = planck(lambda_)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = planck.cdf(x, lambda_)
>>> np.allclose(x, planck.ppf(prob, lambda_))
True

Generate random numbers:

>>> r = planck.rvs(lambda_, size=1000)
================================================================================

pmean:
Firma: (a, p, *, axis=0, dtype=None, weights=None, nan_policy='propagate', keepdims=False)

Docstring:
Calculate the weighted power mean along the specified axis.

The weighted power mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

    \left( \frac{ \sum_{i=1}^n w_i a_i^p }{ \sum_{i=1}^n w_i }
          \right)^{ 1 / p } \, ,

and, with equal weights, it gives:

.. math::

    \left( \frac{ 1 }{ n } \sum_{i=1}^n a_i^p \right)^{ 1 / p }  \, .

When ``p=0``, it returns the geometric mean.

This mean is also called generalized mean or Hölder mean, and must not be
confused with the Kolmogorov generalized mean, also called
quasi-arithmetic mean or generalized f-mean [3]_.

Parameters
----------
a : array_like
    Input array, masked array or object that can be converted to an array.
p : int or float
    Exponent.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If `dtype` is not specified, it defaults to the
    dtype of `a`, unless `a` has an integer `dtype` with a precision less
    than that of the default platform integer. In that case, the default
    platform integer is used.
weights : array_like, optional
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given `axis`) or of the same shape as `a`.
    Default is None, which gives each value a weight of 1.0.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
pmean : ndarray, see `dtype` parameter above.
    Output array containing the power mean values.

See Also
--------

:func:`numpy.average`
    Weighted average
:func:`gmean`
    Geometric mean
:func:`hmean`
    Harmonic mean


Notes
-----
The power mean is computed over a single dimension of the input
array, ``axis=0`` by default, or all values in the array if ``axis=None``.
float64 intermediate and return values are used for integer inputs.

The power mean is only defined if all observations are non-negative;
otherwise, the result is NaN.

.. versionadded:: 1.9

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] "Generalized Mean", *Wikipedia*,
       https://en.wikipedia.org/wiki/Generalized_mean
.. [2] Norris, N., "Convexity properties of generalized mean value
       functions", The Annals of Mathematical Statistics, vol. 8,
       pp. 118-120, 1937
.. [3] Bullen, P.S., Handbook of Means and Their Inequalities, 2003

Examples
--------
>>> from scipy.stats import pmean, hmean, gmean
>>> pmean([1, 4], 1.3)
2.639372938300652
>>> pmean([1, 2, 3, 4, 5, 6, 7], 1.3)
4.157111214492084
>>> pmean([1, 4, 7], -2, weights=[3, 1, 3])
1.4969684896631954

For p=-1, power mean is equal to harmonic mean:

>>> pmean([1, 4, 7], -1, weights=[3, 1, 3])
1.9029126213592233
>>> hmean([1, 4, 7], weights=[3, 1, 3])
1.9029126213592233

For p=0, power mean is defined as the geometric mean:

>>> pmean([1, 4, 7], 0, weights=[3, 1, 3])
2.80668351922014
>>> gmean([1, 4, 7], weights=[3, 1, 3])
2.80668351922014
================================================================================

pointbiserialr:
Firma: (x, y)

Docstring:
Calculate a point biserial correlation coefficient and its p-value.

The point biserial correlation is used to measure the relationship
between a binary variable, x, and a continuous variable, y. Like other
correlation coefficients, this one varies between -1 and +1 with 0
implying no correlation. Correlations of -1 or +1 imply a determinative
relationship.

This function may be computed using a shortcut formula but produces the
same result as `pearsonr`.

Parameters
----------
x : array_like of bools
    Input array.
y : array_like
    Input array.

Returns
-------
res: SignificanceResult
    An object containing attributes:

    statistic : float
        The R value.
    pvalue : float
        The two-sided p-value.

Notes
-----
`pointbiserialr` uses a t-test with ``n-1`` degrees of freedom.
It is equivalent to `pearsonr`.

The value of the point-biserial correlation can be calculated from:

.. math::

    r_{pb} = \frac{\overline{Y_1} - \overline{Y_0}}
                  {s_y}
             \sqrt{\frac{N_0 N_1}
                        {N (N - 1)}}

Where :math:`\overline{Y_{0}}` and :math:`\overline{Y_{1}}` are means
of the metric observations coded 0 and 1 respectively; :math:`N_{0}` and
:math:`N_{1}` are number of observations coded 0 and 1 respectively;
:math:`N` is the total number of observations and :math:`s_{y}` is the
standard deviation of all the metric observations.

A value of :math:`r_{pb}` that is significantly different from zero is
completely equivalent to a significant difference in means between the two
groups. Thus, an independent groups t Test with :math:`N-2` degrees of
freedom may be used to test whether :math:`r_{pb}` is nonzero. The
relation between the t-statistic for comparing two independent groups and
:math:`r_{pb}` is given by:

.. math::

    t = \sqrt{N - 2}\frac{r_{pb}}{\sqrt{1 - r^{2}_{pb}}}

References
----------
.. [1] J. Lev, "The Point Biserial Coefficient of Correlation", Ann. Math.
       Statist., Vol. 20, no.1, pp. 125-126, 1949.

.. [2] R.F. Tate, "Correlation Between a Discrete and a Continuous
       Variable. Point-Biserial Correlation.", Ann. Math. Statist., Vol. 25,
       np. 3, pp. 603-607, 1954.

.. [3] D. Kornbrot "Point Biserial Correlation", In Wiley StatsRef:
       Statistics Reference Online (eds N. Balakrishnan, et al.), 2014.
       :doi:`10.1002/9781118445112.stat06227`

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> a = np.array([0, 0, 0, 1, 1, 1, 1])
>>> b = np.arange(7)
>>> stats.pointbiserialr(a, b)
(0.8660254037844386, 0.011724811003954652)
>>> stats.pearsonr(a, b)
(0.86602540378443871, 0.011724811003954626)
>>> np.corrcoef(a, b)
array([[ 1.       ,  0.8660254],
       [ 0.8660254,  1.       ]])
================================================================================

poisson:
Firma: (*args, **kwds)

Docstring:
A Poisson discrete random variable.

As an instance of the `rv_discrete` class, `poisson` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(mu, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, mu, loc=0)
    Probability mass function.
logpmf(k, mu, loc=0)
    Log of the probability mass function.
cdf(k, mu, loc=0)
    Cumulative distribution function.
logcdf(k, mu, loc=0)
    Log of the cumulative distribution function.
sf(k, mu, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, mu, loc=0)
    Log of the survival function.
ppf(q, mu, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, mu, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(mu, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(mu, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(mu,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(mu, loc=0)
    Median of the distribution.
mean(mu, loc=0)
    Mean of the distribution.
var(mu, loc=0)
    Variance of the distribution.
std(mu, loc=0)
    Standard deviation of the distribution.
interval(confidence, mu, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `poisson` is:

.. math::

    f(k) = \exp(-\mu) \frac{\mu^k}{k!}

for :math:`k \ge 0`.

`poisson` takes :math:`\mu \geq 0` as shape parameter.
When :math:`\mu = 0`, the ``pmf`` method
returns ``1.0`` at quantile :math:`k = 0`.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``poisson.pmf(k, mu, loc)`` is identically
equivalent to ``poisson.pmf(k - loc, mu)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import poisson
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mu = 0.6
>>> mean, var, skew, kurt = poisson.stats(mu, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(poisson.ppf(0.01, mu),
...               poisson.ppf(0.99, mu))
>>> ax.plot(x, poisson.pmf(x, mu), 'bo', ms=8, label='poisson pmf')
>>> ax.vlines(x, 0, poisson.pmf(x, mu), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = poisson(mu)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = poisson.cdf(x, mu)
>>> np.allclose(x, poisson.ppf(prob, mu))
True

Generate random numbers:

>>> r = poisson.rvs(mu, size=1000)
================================================================================

poisson_binom:
Firma: (*args, **kwds)

Docstring:
A Poisson Binomial discrete random variable.

As an instance of the `rv_discrete` class, `poisson_binom` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(p, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, p, loc=0)
    Probability mass function.
logpmf(k, p, loc=0)
    Log of the probability mass function.
cdf(k, p, loc=0)
    Cumulative distribution function.
logcdf(k, p, loc=0)
    Log of the cumulative distribution function.
sf(k, p, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, p, loc=0)
    Log of the survival function.
ppf(q, p, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, p, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(p, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(p, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(p,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(p, loc=0)
    Median of the distribution.
mean(p, loc=0)
    Mean of the distribution.
var(p, loc=0)
    Variance of the distribution.
std(p, loc=0)
    Standard deviation of the distribution.
interval(confidence, p, loc=0)
    Confidence interval with equal areas around the median.

See Also
--------
binom

Notes
-----
The probability mass function for `poisson_binom` is:

.. math::

 f(k; p_1, p_2, ..., p_n) = \sum_{A \in F_k} \prod_{i \in A} p_i \prod_{j \in A^C} 1 - p_j

where :math:`k \in \{0, 1, \dots, n-1, n\}`, :math:`F_k` is the set of all
subsets of :math:`k` integers that can be selected :math:`\{0, 1, \dots, n-1, n\}`,
and :math:`A^C` is the complement of a set :math:`A`.

`poisson_binom` accepts a single array argument ``p`` for shape parameters
:math:`0 ≤ p_i ≤ 1`, where the last axis corresponds with the index :math:`i` and
any others are for batch dimensions. Broadcasting behaves according to the usual
rules except that the last axis of ``p`` is ignored. Instances of this class do
not support serialization/unserialization.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``poisson_binom.pmf(k, p, loc)`` is identically
equivalent to ``poisson_binom.pmf(k - loc, p)``.

References
----------
.. [1] "Poisson binomial distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Poisson_binomial_distribution
.. [2] Biscarri, William, Sihai Dave Zhao, and Robert J. Brunner. "A simple and
       fast method for computing the Poisson binomial distribution function".
       Computational Statistics & Data Analysis 122 (2018) 92-100.
       :doi:`10.1016/j.csda.2018.01.007`

Examples
--------
>>> import numpy as np
>>> from scipy.stats import poisson_binom
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> p = [0.1, 0.6, 0.7, 0.8]
>>> mean, var, skew, kurt = poisson_binom.stats(p, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(poisson_binom.ppf(0.01, p),
...               poisson_binom.ppf(0.99, p))
>>> ax.plot(x, poisson_binom.pmf(x, p), 'bo', ms=8, label='poisson_binom pmf')
>>> ax.vlines(x, 0, poisson_binom.pmf(x, p), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = poisson_binom(p)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = poisson_binom.cdf(x, p)
>>> np.allclose(x, poisson_binom.ppf(prob, p))
True

Generate random numbers:

>>> r = poisson_binom.rvs(p, size=1000)
================================================================================

poisson_means_test:
Firma: (k1, n1, k2, n2, *, diff=0, alternative='two-sided')

Docstring:
Performs the Poisson means test, AKA the "E-test".

This is a test of the null hypothesis that the difference between means of
two Poisson distributions is `diff`. The samples are provided as the
number of events `k1` and `k2` observed within measurement intervals
(e.g. of time, space, number of observations) of sizes `n1` and `n2`.

Parameters
----------
k1 : int
    Number of events observed from distribution 1.
n1: float
    Size of sample from distribution 1.
k2 : int
    Number of events observed from distribution 2.
n2 : float
    Size of sample from distribution 2.
diff : float, default=0
    The hypothesized difference in means between the distributions
    underlying the samples.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

      * 'two-sided': the difference between distribution means is not
        equal to `diff`
      * 'less': the difference between distribution means is less than
        `diff`
      * 'greater': the difference between distribution means is greater
        than `diff`

Returns
-------
statistic : float
    The test statistic (see [1]_ equation 3.3).
pvalue : float
    The probability of achieving such an extreme value of the test
    statistic under the null hypothesis.

Notes
-----

Let:

.. math:: X_1 \sim \mbox{Poisson}(\mathtt{n1}\lambda_1)

be a random variable independent of

.. math:: X_2  \sim \mbox{Poisson}(\mathtt{n2}\lambda_2)

and let ``k1`` and ``k2`` be the observed values of :math:`X_1`
and :math:`X_2`, respectively. Then `poisson_means_test` uses the number
of observed events ``k1`` and ``k2`` from samples of size ``n1`` and
``n2``, respectively, to test the null hypothesis that

.. math::
   H_0: \lambda_1 - \lambda_2 = \mathtt{diff}

A benefit of the E-test is that it has good power for small sample sizes,
which can reduce sampling costs [1]_. It has been evaluated and determined
to be more powerful than the comparable C-test, sometimes referred to as
the Poisson exact test.

References
----------
.. [1]  Krishnamoorthy, K., & Thomson, J. (2004). A more powerful test for
   comparing two Poisson means. Journal of Statistical Planning and
   Inference, 119(1), 23-35.

.. [2]  Przyborowski, J., & Wilenski, H. (1940). Homogeneity of results in
   testing samples from Poisson series: With an application to testing
   clover seed for dodder. Biometrika, 31(3/4), 313-323.

Examples
--------

Suppose that a gardener wishes to test the number of dodder (weed) seeds
in a sack of clover seeds that they buy from a seed company. It has
previously been established that the number of dodder seeds in clover
follows the Poisson distribution.

A 100 gram sample is drawn from the sack before being shipped to the
gardener. The sample is analyzed, and it is found to contain no dodder
seeds; that is, `k1` is 0. However, upon arrival, the gardener draws
another 100 gram sample from the sack. This time, three dodder seeds are
found in the sample; that is, `k2` is 3. The gardener would like to
know if the difference is significant and not due to chance. The
null hypothesis is that the difference between the two samples is merely
due to chance, or that :math:`\lambda_1 - \lambda_2 = \mathtt{diff}`
where :math:`\mathtt{diff} = 0`. The alternative hypothesis is that the
difference is not due to chance, or :math:`\lambda_1 - \lambda_2 \ne 0`.
The gardener selects a significance level of 5% to reject the null
hypothesis in favor of the alternative [2]_.

>>> import scipy.stats as stats
>>> res = stats.poisson_means_test(0, 100, 3, 100)
>>> res.statistic, res.pvalue
(-1.7320508075688772, 0.08837900929018157)

The p-value is .088, indicating a near 9% chance of observing a value of
the test statistic under the null hypothesis. This exceeds 5%, so the
gardener does not reject the null hypothesis as the difference cannot be
regarded as significant at this level.
================================================================================

power:
Firma: (test, rvs, n_observations, *, significance=0.01, vectorized=None, n_resamples=10000, batch=None, kwargs=None)

Docstring:
Simulate the power of a hypothesis test under an alternative hypothesis.

Parameters
----------
test : callable
    Hypothesis test for which the power is to be simulated.
    `test` must be a callable that accepts a sample (e.g. ``test(sample)``)
    or ``len(rvs)`` separate samples (e.g. ``test(samples1, sample2)`` if
    `rvs` contains two callables and `n_observations` contains two values)
    and returns the p-value of the test.
    If `vectorized` is set to ``True``, `test` must also accept a keyword
    argument `axis` and be vectorized to perform the test along the
    provided `axis` of the samples.
    Any callable from `scipy.stats` with an `axis` argument that returns an
    object with a `pvalue` attribute is also acceptable.
rvs : callable or tuple of callables
    A callable or sequence of callables that generate(s) random variates
    under the alternative hypothesis. Each element of `rvs` must accept
    keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and return an
    N-d array of that shape. If `rvs` is a sequence, the number of callables
    in `rvs` must match the number of elements of `n_observations`, i.e.
    ``len(rvs) == len(n_observations)``. If `rvs` is a single callable,
    `n_observations` is treated as a single element.
n_observations : tuple of ints or tuple of integer arrays
    If a sequence of ints, each is the sizes of a sample to be passed to `test`.
    If a sequence of integer arrays, the power is simulated for each
    set of corresponding sample sizes. See Examples.
significance : float or array_like of floats, default: 0.01
    The threshold for significance; i.e., the p-value below which the
    hypothesis test results will be considered as evidence against the null
    hypothesis. Equivalently, the acceptable rate of Type I error under
    the null hypothesis. If an array, the power is simulated for each
    significance threshold.
kwargs : dict, optional
    Keyword arguments to be passed to `rvs` and/or `test` callables.
    Introspection is used to determine which keyword arguments may be
    passed to each callable.
    The value corresponding with each keyword must be an array.
    Arrays must be broadcastable with one another and with each array in
    `n_observations`. The power is simulated for each set of corresponding
    sample sizes and arguments. See Examples.
vectorized : bool, optional
    If `vectorized` is set to ``False``, `test` will not be passed keyword
    argument `axis` and is expected to perform the test only for 1D samples.
    If ``True``, `test` will be passed keyword argument `axis` and is
    expected to perform the test along `axis` when passed N-D sample arrays.
    If ``None`` (default), `vectorized` will be set ``True`` if ``axis`` is
    a parameter of `test`. Use of a vectorized test typically reduces
    computation time.
n_resamples : int, default: 10000
    Number of samples drawn from each of the callables of `rvs`.
    Equivalently, the number tests performed under the alternative
    hypothesis to approximate the power.
batch : int, optional
    The number of samples to process in each call to `test`. Memory usage is
    proportional to the product of `batch` and the largest sample size. Default
    is ``None``, in which case `batch` equals `n_resamples`.

Returns
-------
res : PowerResult
    An object with attributes:

    power : float or ndarray
        The estimated power against the alternative.
    pvalues : ndarray
        The p-values observed under the alternative hypothesis.

Notes
-----
The power is simulated as follows:

- Draw many random samples (or sets of samples), each of the size(s)
  specified by `n_observations`, under the alternative specified by
  `rvs`.
- For each sample (or set of samples), compute the p-value according to
  `test`. These p-values are recorded in the ``pvalues`` attribute of
  the result object.
- Compute the proportion of p-values that are less than the `significance`
  level. This is the power recorded in the ``power`` attribute of the
  result object.

Suppose that `significance` is an array with shape ``shape1``, the elements
of `kwargs` and `n_observations` are mutually broadcastable to shape ``shape2``,
and `test` returns an array of p-values of shape ``shape3``. Then the result
object ``power`` attribute will be of shape ``shape1 + shape2 + shape3``, and
the ``pvalues`` attribute will be of shape ``shape2 + shape3 + (n_resamples,)``.

Examples
--------
Suppose we wish to simulate the power of the independent sample t-test
under the following conditions:

- The first sample has 10 observations drawn from a normal distribution
  with mean 0.
- The second sample has 12 observations drawn from a normal distribution
  with mean 1.0.
- The threshold on p-values for significance is 0.05.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng(2549598345528)
>>>
>>> test = stats.ttest_ind
>>> n_observations = (10, 12)
>>> rvs1 = rng.normal
>>> rvs2 = lambda size: rng.normal(loc=1, size=size)
>>> rvs = (rvs1, rvs2)
>>> res = stats.power(test, rvs, n_observations, significance=0.05)
>>> res.power
0.6116

With samples of size 10 and 12, respectively, the power of the t-test
with a significance threshold of 0.05 is approximately 60% under the chosen
alternative. We can investigate the effect of sample size on the power
by passing sample size arrays.

>>> import matplotlib.pyplot as plt
>>> nobs_x = np.arange(5, 21)
>>> nobs_y = nobs_x
>>> n_observations = (nobs_x, nobs_y)
>>> res = stats.power(test, rvs, n_observations, significance=0.05)
>>> ax = plt.subplot()
>>> ax.plot(nobs_x, res.power)
>>> ax.set_xlabel('Sample Size')
>>> ax.set_ylabel('Simulated Power')
>>> ax.set_title('Simulated Power of `ttest_ind` with Equal Sample Sizes')
>>> plt.show()

Alternatively, we can investigate the impact that effect size has on the power.
In this case, the effect size is the location of the distribution underlying
the second sample.

>>> n_observations = (10, 12)
>>> loc = np.linspace(0, 1, 20)
>>> rvs2 = lambda size, loc: rng.normal(loc=loc, size=size)
>>> rvs = (rvs1, rvs2)
>>> res = stats.power(test, rvs, n_observations, significance=0.05,
...                   kwargs={'loc': loc})
>>> ax = plt.subplot()
>>> ax.plot(loc, res.power)
>>> ax.set_xlabel('Effect Size')
>>> ax.set_ylabel('Simulated Power')
>>> ax.set_title('Simulated Power of `ttest_ind`, Varying Effect Size')
>>> plt.show()

We can also use `power` to estimate the Type I error rate (also referred to by the
ambiguous term "size") of a test and assess whether it matches the nominal level.
For example, the null hypothesis of `jarque_bera` is that the sample was drawn from
a distribution with the same skewness and kurtosis as the normal distribution. To
estimate the Type I error rate, we can consider the null hypothesis to be a true
*alternative* hypothesis and calculate the power.

>>> test = stats.jarque_bera
>>> n_observations = 10
>>> rvs = rng.normal
>>> significance = np.linspace(0.0001, 0.1, 1000)
>>> res = stats.power(test, rvs, n_observations, significance=significance)
>>> size = res.power

As shown below, the Type I error rate of the test is far below the nominal level
for such a small sample, as mentioned in its documentation.

>>> ax = plt.subplot()
>>> ax.plot(significance, size)
>>> ax.plot([0, 0.1], [0, 0.1], '--')
>>> ax.set_xlabel('nominal significance level')
>>> ax.set_ylabel('estimated test size (Type I error rate)')
>>> ax.set_title('Estimated test size vs nominal significance level')
>>> ax.set_aspect('equal', 'box')
>>> ax.legend(('`ttest_1samp`', 'ideal test'))
>>> plt.show()

As one might expect from such a conservative test, the power is quite low with
respect to some alternatives. For example, the power of the test under the
alternative that the sample was drawn from the Laplace distribution may not
be much greater than the Type I error rate.

>>> rvs = rng.laplace
>>> significance = np.linspace(0.0001, 0.1, 1000)
>>> res = stats.power(test, rvs, n_observations, significance=0.05)
>>> print(res.power)
0.0587

This is not a mistake in SciPy's implementation; it is simply due to the fact
that the null distribution of the test statistic is derived under the assumption
that the sample size is large (i.e. approaches infinity), and this asymptotic
approximation is not accurate for small samples. In such cases, resampling
and Monte Carlo methods (e.g. `permutation_test`, `goodness_of_fit`,
`monte_carlo_test`) may be more appropriate.
================================================================================

power_divergence:
Firma: (f_obs, f_exp=None, ddof=0, axis=0, lambda_=None)

Docstring:
Cressie-Read power divergence statistic and goodness of fit test.

This function tests the null hypothesis that the categorical data
has the given frequencies, using the Cressie-Read power divergence
statistic.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.

    .. deprecated:: 1.14.0
        Support for masked array input was deprecated in
        SciPy 1.14.0 and will be removed in version 1.16.0.

f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.

    .. deprecated:: 1.14.0
        Support for masked array input was deprecated in
        SciPy 1.14.0 and will be removed in version 1.16.0.

ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.
lambda_ : float or str, optional
    The power in the Cressie-Read power divergence statistic.  The default
    is 1.  For convenience, `lambda_` may be assigned one of the following
    strings, in which case the corresponding numerical value is used:

    * ``"pearson"`` (value 1)
        Pearson's chi-squared statistic. In this case, the function is
        equivalent to `chisquare`.
    * ``"log-likelihood"`` (value 0)
        Log-likelihood ratio. Also known as the G-test [3]_.
    * ``"freeman-tukey"`` (value -1/2)
        Freeman-Tukey statistic.
    * ``"mod-log-likelihood"`` (value -1)
        Modified log-likelihood ratio.
    * ``"neyman"`` (value -2)
        Neyman's statistic.
    * ``"cressie-read"`` (value 2/3)
        The power recommended in [5]_.

Returns
-------
res: Power_divergenceResult
    An object containing attributes:

    statistic : float or ndarray
        The Cressie-Read power divergence test statistic.  The value is
        a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.
    pvalue : float or ndarray
        The p-value of the test.  The value is a float if `ddof` and the
        return value `stat` are scalars.

See Also
--------
chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

Also, the sum of the observed and expected frequencies must be the same
for the test to be valid; `power_divergence` raises an error if the sums
do not agree within a relative tolerance of ``eps**0.5``, where ``eps``
is the precision of the input dtype.

When `lambda_` is less than zero, the formula for the statistic involves
dividing by `f_obs`, so a warning or error may be generated if any value
in `f_obs` is 0.

Similarly, a warning or error may be generated if any value in `f_exp` is
zero when `lambda_` >= 0.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8.
       https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", https://en.wikipedia.org/wiki/Chi-squared_test
.. [3] "G-test", https://en.wikipedia.org/wiki/G-test
.. [4] Sokal, R. R. and Rohlf, F. J. "Biometry: the principles and
       practice of statistics in biological research", New York: Freeman
       (1981)
.. [5] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------
(See `chisquare` for more examples.)

When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.  Here we
perform a G-test (i.e. use the log-likelihood ratio statistic):

>>> import numpy as np
>>> from scipy.stats import power_divergence
>>> power_divergence([16, 18, 16, 14, 12, 12], lambda_='log-likelihood')
(2.006573162632538, 0.84823476779463769)

The expected frequencies can be given with the `f_exp` argument:

>>> power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[16, 16, 16, 16, 16, 8],
...                  lambda_='log-likelihood')
(3.3281031458963746, 0.6495419288047497)

When `f_obs` is 2-D, by default the test is applied to each column.

>>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
>>> obs.shape
(6, 2)
>>> power_divergence(obs, lambda_="log-likelihood")
(array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

>>> power_divergence(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
>>> power_divergence(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

>>> power_divergence([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
test statistic with `ddof`.

>>> power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we must use ``axis=1``:

>>> power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[[16, 16, 16, 16, 16, 8],
...                         [8, 20, 20, 16, 12, 12]],
...                  axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))
================================================================================

powerlaw:
Firma: (*args, **kwds)

Docstring:
A power-function continuous random variable.

As an instance of the `rv_continuous` class, `powerlaw` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
pareto

Notes
-----
The probability density function for `powerlaw` is:

.. math::

    f(x, a) = a x^{a-1}

for :math:`0 \le x \le 1`, :math:`a > 0`.

`powerlaw` takes ``a`` as a shape parameter for :math:`a`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``powerlaw.pdf(x, a, loc, scale)`` is identically
equivalent to ``powerlaw.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

For example, the support of `powerlaw` can be adjusted from the default
interval ``[0, 1]`` to the interval ``[c, c+d]`` by setting ``loc=c`` and
``scale=d``. For a power-law distribution with infinite support, see
`pareto`.

`powerlaw` is a special case of `beta` with ``b=1``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import powerlaw
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 0.659
>>> mean, var, skew, kurt = powerlaw.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(powerlaw.ppf(0.01, a),
...                 powerlaw.ppf(0.99, a), 100)
>>> ax.plot(x, powerlaw.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='powerlaw pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = powerlaw(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = powerlaw.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], powerlaw.cdf(vals, a))
True

Generate random numbers:

>>> r = powerlaw.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

powerlognorm:
Firma: (*args, **kwds)

Docstring:
A power log-normal continuous random variable.

As an instance of the `rv_continuous` class, `powerlognorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, s, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, s, loc=0, scale=1)
    Probability density function.
logpdf(x, c, s, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, s, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, s, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, s, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, s, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, s, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, s, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, s, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, s, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, s, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c, s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, s, loc=0, scale=1)
    Median of the distribution.
mean(c, s, loc=0, scale=1)
    Mean of the distribution.
var(c, s, loc=0, scale=1)
    Variance of the distribution.
std(c, s, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, s, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `powerlognorm` is:

.. math::

    f(x, c, s) = \frac{c}{x s} \phi(\log(x)/s)
                 (\Phi(-\log(x)/s))^{c-1}

where :math:`\phi` is the normal pdf, and :math:`\Phi` is the normal cdf,
and :math:`x > 0`, :math:`s, c > 0`.

`powerlognorm` takes :math:`c` and :math:`s` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``powerlognorm.pdf(x, c, s, loc, scale)`` is identically
equivalent to ``powerlognorm.pdf(y, c, s) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import powerlognorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c, s = 2.14, 0.446
>>> mean, var, skew, kurt = powerlognorm.stats(c, s, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(powerlognorm.ppf(0.01, c, s),
...                 powerlognorm.ppf(0.99, c, s), 100)
>>> ax.plot(x, powerlognorm.pdf(x, c, s),
...        'r-', lw=5, alpha=0.6, label='powerlognorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = powerlognorm(c, s)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = powerlognorm.ppf([0.001, 0.5, 0.999], c, s)
>>> np.allclose([0.001, 0.5, 0.999], powerlognorm.cdf(vals, c, s))
True

Generate random numbers:

>>> r = powerlognorm.rvs(c, s, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

powernorm:
Firma: (*args, **kwds)

Docstring:
A power normal continuous random variable.

As an instance of the `rv_continuous` class, `powernorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `powernorm` is:

.. math::

    f(x, c) = c \phi(x) (\Phi(-x))^{c-1}

where :math:`\phi` is the normal pdf, :math:`\Phi` is the normal cdf,
:math:`x` is any real, and :math:`c > 0` [1]_.

`powernorm` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``powernorm.pdf(x, c, loc, scale)`` is identically
equivalent to ``powernorm.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] NIST Engineering Statistics Handbook, Section 1.3.6.6.13,
       https://www.itl.nist.gov/div898/handbook//eda/section3/eda366d.htm

Examples
--------
>>> import numpy as np
>>> from scipy.stats import powernorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 4.45
>>> mean, var, skew, kurt = powernorm.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(powernorm.ppf(0.01, c),
...                 powernorm.ppf(0.99, c), 100)
>>> ax.plot(x, powernorm.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='powernorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = powernorm(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = powernorm.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], powernorm.cdf(vals, c))
True

Generate random numbers:

>>> r = powernorm.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

ppcc_max:
Firma: (x, brack=(0.0, 1.0), dist='tukeylambda')

Docstring:
Calculate the shape parameter that maximizes the PPCC.

The probability plot correlation coefficient (PPCC) plot can be used
to determine the optimal shape parameter for a one-parameter family
of distributions. ``ppcc_max`` returns the shape parameter that would
maximize the probability plot correlation coefficient for the given
data to a one-parameter family of distributions.

Parameters
----------
x : array_like
    Input array.
brack : tuple, optional
    Triple (a,b,c) where (a<b<c). If bracket consists of two numbers (a, c)
    then they are assumed to be a starting interval for a downhill bracket
    search (see `scipy.optimize.brent`).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.

Returns
-------
shape_value : float
    The shape parameter at which the probability plot correlation
    coefficient reaches its max value.

See Also
--------
ppcc_plot, probplot, boxcox

Notes
-----
The brack keyword serves as a starting point which is useful in corner
cases. One can use a plot to obtain a rough visual estimate of the location
for the maximum to start the search near it.

References
----------
.. [1] J.J. Filliben, "The Probability Plot Correlation Coefficient Test
       for Normality", Technometrics, Vol. 17, pp. 111-117, 1975.
.. [2] Engineering Statistics Handbook, NIST/SEMATEC,
       https://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5:

>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> c = 2.5
>>> x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Generate the PPCC plot for this data with the Weibull distribution.

>>> fig, ax = plt.subplots(figsize=(8, 6))
>>> res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax)

We calculate the value where the shape should reach its maximum and a
red line is drawn there. The line should coincide with the highest
point in the PPCC graph.

>>> cmax = stats.ppcc_max(x, brack=(c/2, 2*c), dist='weibull_min')
>>> ax.axvline(cmax, color='r')
>>> plt.show()
================================================================================

ppcc_plot:
Firma: (x, a, b, dist='tukeylambda', plot=None, N=80)

Docstring:
Calculate and optionally plot probability plot correlation coefficient.

The probability plot correlation coefficient (PPCC) plot can be used to
determine the optimal shape parameter for a one-parameter family of
distributions.  It cannot be used for distributions without shape
parameters
(like the normal distribution) or with multiple shape parameters.

By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A
Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed
distributions via an approximately normal one, and is therefore
particularly useful in practice.

Parameters
----------
x : array_like
    Input array.
a, b : scalar
    Lower and upper bounds of the shape parameter to use.
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.
plot : object, optional
    If given, plots PPCC against the shape parameter.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `a` to `b`).

Returns
-------
svals : ndarray
    The shape values for which `ppcc` was calculated.
ppcc : ndarray
    The calculated probability plot correlation coefficient values.

See Also
--------
ppcc_max, probplot, boxcox_normplot, tukeylambda

References
----------
J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5, and plot the histogram of the data:

>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> c = 2.5
>>> x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Take a look at the histogram of the data.

>>> fig1, ax = plt.subplots(figsize=(9, 4))
>>> ax.hist(x, bins=50)
>>> ax.set_title('Histogram of x')
>>> plt.show()

Now we explore this data with a PPCC plot as well as the related
probability plot and Box-Cox normplot.  A red line is drawn where we
expect the PPCC value to be maximal (at the shape parameter ``c``
used above):

>>> fig2 = plt.figure(figsize=(12, 4))
>>> ax1 = fig2.add_subplot(1, 3, 1)
>>> ax2 = fig2.add_subplot(1, 3, 2)
>>> ax3 = fig2.add_subplot(1, 3, 3)
>>> res = stats.probplot(x, plot=ax1)
>>> res = stats.boxcox_normplot(x, -4, 4, plot=ax2)
>>> res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax3)
>>> ax3.axvline(c, color='r')
>>> plt.show()
================================================================================

probplot:
Firma: (x, sparams=(), dist='norm', fit=True, plot=None, rvalue=False)

Docstring:
Calculate quantiles for a probability plot, and optionally show the plot.

Generates a probability plot of sample data against the quantiles of a
specified theoretical distribution (the normal distribution by default).
`probplot` optionally calculates a best-fit line for the data and plots the
results using Matplotlib or a given plot function.

Parameters
----------
x : array_like
    Sample/response data from which `probplot` creates the plot.
sparams : tuple, optional
    Distribution-specific shape parameters (shape parameters plus location
    and scale).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name. The default is 'norm' for a
    normal probability plot.  Objects that look enough like a
    stats.distributions instance (i.e. they have a ``ppf`` method) are also
    accepted.
fit : bool, optional
    Fit a least-squares regression (best-fit) line to the sample data if
    True (default).
plot : object, optional
    If given, plots the quantiles.
    If given and `fit` is True, also plots the least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
rvalue : bool, optional
    If `plot` is provided and `fit` is True, setting `rvalue` to True
    includes the coefficient of determination on the plot.
    Default is False.

Returns
-------
(osm, osr) : tuple of ndarrays
    Tuple of theoretical quantiles (osm, or order statistic medians) and
    ordered responses (osr).  `osr` is simply sorted input `x`.
    For details on how `osm` is calculated see the Notes section.
(slope, intercept, r) : tuple of floats, optional
    Tuple  containing the result of the least-squares fit, if that is
    performed by `probplot`. `r` is the square root of the coefficient of
    determination.  If ``fit=False`` and ``plot=None``, this tuple is not
    returned.

Notes
-----
Even if `plot` is given, the figure is not shown or saved by `probplot`;
``plt.show()`` or ``plt.savefig('figname.png')`` should be used after
calling `probplot`.

`probplot` generates a probability plot, which should not be confused with
a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this
type, see ``statsmodels.api.ProbPlot``.

The formula used for the theoretical quantiles (horizontal axis of the
probability plot) is Filliben's estimate::

    quantiles = dist.ppf(val), for

            0.5**(1/n),                  for i = n
      val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1
            1 - 0.5**(1/n),              for i = 1

where ``i`` indicates the i-th ordered value and ``n`` is the total number
of values.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> nsample = 100
>>> rng = np.random.default_rng()

A t distribution with small degrees of freedom:

>>> ax1 = plt.subplot(221)
>>> x = stats.t.rvs(3, size=nsample, random_state=rng)
>>> res = stats.probplot(x, plot=plt)

A t distribution with larger degrees of freedom:

>>> ax2 = plt.subplot(222)
>>> x = stats.t.rvs(25, size=nsample, random_state=rng)
>>> res = stats.probplot(x, plot=plt)

A mixture of two normal distributions with broadcasting:

>>> ax3 = plt.subplot(223)
>>> x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
...                    size=(nsample//2,2), random_state=rng).ravel()
>>> res = stats.probplot(x, plot=plt)

A standard normal distribution:

>>> ax4 = plt.subplot(224)
>>> x = stats.norm.rvs(loc=0, scale=1, size=nsample, random_state=rng)
>>> res = stats.probplot(x, plot=plt)

Produce a new figure with a loggamma distribution, using the ``dist`` and
``sparams`` keywords:

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> x = stats.loggamma.rvs(c=2.5, size=500, random_state=rng)
>>> res = stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)
>>> ax.set_title("Probplot for loggamma dist with shape parameter 2.5")

Show the results with Matplotlib:

>>> plt.show()
================================================================================

quantile_test:
Firma: (x, *, q=0, p=0.5, alternative='two-sided')

Docstring:
Perform a quantile test and compute a confidence interval of the quantile.

This function tests the null hypothesis that `q` is the value of the
quantile associated with probability `p` of the population underlying
sample `x`. For example, with default parameters, it tests that the
median of the population underlying `x` is zero. The function returns an
object including the test statistic, a p-value, and a method for computing
the confidence interval around the quantile.

Parameters
----------
x : array_like
    A one-dimensional sample.
q : float, default: 0
    The hypothesized value of the quantile.
p : float, default: 0.5
    The probability associated with the quantile; i.e. the proportion of
    the population less than `q` is `p`. Must be strictly between 0 and
    1.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the quantile associated with the probability `p`
      is not `q`.
    * 'less': the quantile associated with the probability `p` is less
      than `q`.
    * 'greater': the quantile associated with the probability `p` is
      greater than `q`.

Returns
-------
result : QuantileTestResult
    An object with the following attributes:

    statistic : float
        One of two test statistics that may be used in the quantile test.
        The first test statistic, ``T1``, is the proportion of samples in
        `x` that are less than or equal to the hypothesized quantile
        `q`. The second test statistic, ``T2``, is the proportion of
        samples in `x` that are strictly less than the hypothesized
        quantile `q`.

        When ``alternative = 'greater'``, ``T1`` is used to calculate the
        p-value and ``statistic`` is set to ``T1``.

        When ``alternative = 'less'``, ``T2`` is used to calculate the
        p-value and ``statistic`` is set to ``T2``.

        When ``alternative = 'two-sided'``, both ``T1`` and ``T2`` are
        considered, and the one that leads to the smallest p-value is used.

    statistic_type : int
        Either `1` or `2` depending on which of ``T1`` or ``T2`` was
        used to calculate the p-value.

    pvalue : float
        The p-value associated with the given alternative.

    The object also has the following method:

    confidence_interval(confidence_level=0.95)
        Computes a confidence interval around the the
        population quantile associated with the probability `p`. The
        confidence interval is returned in a ``namedtuple`` with
        fields `low` and `high`.  Values are `nan` when there are
        not enough observations to compute the confidence interval at
        the desired confidence.

Notes
-----
This test and its method for computing confidence intervals are
non-parametric. They are valid if and only if the observations are i.i.d.

The implementation of the test follows Conover [1]_. Two test statistics
are considered.

``T1``: The number of observations in `x` less than or equal to `q`.

    ``T1 = (x <= q).sum()``

``T2``: The number of observations in `x` strictly less than `q`.

    ``T2 = (x < q).sum()``

The use of two test statistics is necessary to handle the possibility that
`x` was generated from a discrete or mixed distribution.

The null hypothesis for the test is:

    H0: The :math:`p^{\mathrm{th}}` population quantile is `q`.

and the null distribution for each test statistic is
:math:`\mathrm{binom}\left(n, p\right)`. When ``alternative='less'``,
the alternative hypothesis is:

    H1: The :math:`p^{\mathrm{th}}` population quantile is less than `q`.

and the p-value is the probability that the binomial random variable

.. math::
    Y \sim \mathrm{binom}\left(n, p\right)

is greater than or equal to the observed value ``T2``.

When ``alternative='greater'``, the alternative hypothesis is:

    H1: The :math:`p^{\mathrm{th}}` population quantile is greater than `q`

and the p-value is the probability that the binomial random variable Y
is less than or equal to the observed value ``T1``.

When ``alternative='two-sided'``, the alternative hypothesis is

    H1: `q` is not the :math:`p^{\mathrm{th}}` population quantile.

and the p-value is twice the smaller of the p-values for the ``'less'``
and ``'greater'`` cases. Both of these p-values can exceed 0.5 for the same
data, so the value is clipped into the interval :math:`[0, 1]`.

The approach for confidence intervals is attributed to Thompson [2]_ and
later proven to be applicable to any set of i.i.d. samples [3]_. The
computation is based on the observation that the probability of a quantile
:math:`q` to be larger than any observations :math:`x_m (1\leq m \leq N)`
can be computed as

.. math::

    \mathbb{P}(x_m \leq q) = 1 - \sum_{k=0}^{m-1} \binom{N}{k}
    q^k(1-q)^{N-k}

By default, confidence intervals are computed for a 95% confidence level.
A common interpretation of a 95% confidence intervals is that if i.i.d.
samples are drawn repeatedly from the same population and confidence
intervals are formed each time, the confidence interval will contain the
true value of the specified quantile in approximately 95% of trials.

A similar function is available in the QuantileNPCI R package [4]_. The
foundation is the same, but it computes the confidence interval bounds by
doing interpolations between the sample values, whereas this function uses
only sample values as bounds. Thus, ``quantile_test.confidence_interval``
returns more conservative intervals (i.e., larger).

The same computation of confidence intervals for quantiles is included in
the confintr package [5]_.

Two-sided confidence intervals are not guaranteed to be optimal; i.e.,
there may exist a tighter interval that may contain the quantile of
interest with probability larger than the confidence level.
Without further assumption on the samples (e.g., the nature of the
underlying distribution), the one-sided intervals are optimally tight.

References
----------
.. [1] W. J. Conover. Practical Nonparametric Statistics, 3rd Ed. 1999.
.. [2] W. R. Thompson, "On Confidence Ranges for the Median and Other
   Expectation Distributions for Populations of Unknown Distribution
   Form," The Annals of Mathematical Statistics, vol. 7, no. 3,
   pp. 122-128, 1936, Accessed: Sep. 18, 2019. [Online]. Available:
   https://www.jstor.org/stable/2957563.
.. [3] H. A. David and H. N. Nagaraja, "Order Statistics in Nonparametric
   Inference" in Order Statistics, John Wiley & Sons, Ltd, 2005, pp.
   159-170. Available:
   https://onlinelibrary.wiley.com/doi/10.1002/0471722162.ch7.
.. [4] N. Hutson, A. Hutson, L. Yan, "QuantileNPCI: Nonparametric
   Confidence Intervals for Quantiles," R package,
   https://cran.r-project.org/package=QuantileNPCI
.. [5] M. Mayer, "confintr: Confidence Intervals," R package,
   https://cran.r-project.org/package=confintr


Examples
--------

Suppose we wish to test the null hypothesis that the median of a population
is equal to 0.5. We choose a confidence level of 99%; that is, we will
reject the null hypothesis in favor of the alternative if the p-value is
less than 0.01.

When testing random variates from the standard uniform distribution, which
has a median of 0.5, we expect the data to be consistent with the null
hypothesis most of the time.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng(6981396440634228121)
>>> rvs = stats.uniform.rvs(size=100, random_state=rng)
>>> stats.quantile_test(rvs, q=0.5, p=0.5)
QuantileTestResult(statistic=45, statistic_type=1, pvalue=0.36820161732669576)

As expected, the p-value is not below our threshold of 0.01, so
we cannot reject the null hypothesis.

When testing data from the standard *normal* distribution, which has a
median of 0, we would expect the null hypothesis to be rejected.

>>> rvs = stats.norm.rvs(size=100, random_state=rng)
>>> stats.quantile_test(rvs, q=0.5, p=0.5)
QuantileTestResult(statistic=67, statistic_type=2, pvalue=0.0008737198369123724)

Indeed, the p-value is lower than our threshold of 0.01, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the median
of the population is *not* equal to 0.5.

However, suppose we were to test the null hypothesis against the
one-sided alternative that the median of the population is *greater* than
0.5. Since the median of the standard normal is less than 0.5, we would not
expect the null hypothesis to be rejected.

>>> stats.quantile_test(rvs, q=0.5, p=0.5, alternative='greater')
QuantileTestResult(statistic=67, statistic_type=1, pvalue=0.9997956114162866)

Unsurprisingly, with a p-value greater than our threshold, we would not
reject the null hypothesis in favor of the chosen alternative.

The quantile test can be used for any quantile, not only the median. For
example, we can test whether the third quartile of the distribution
underlying the sample is greater than 0.6.

>>> rvs = stats.uniform.rvs(size=100, random_state=rng)
>>> stats.quantile_test(rvs, q=0.6, p=0.75, alternative='greater')
QuantileTestResult(statistic=64, statistic_type=1, pvalue=0.00940696592998271)

The p-value is lower than the threshold. We reject the null hypothesis in
favor of the alternative: the third quartile of the distribution underlying
our sample is greater than 0.6.

`quantile_test` can also compute confidence intervals for any quantile.

>>> rvs = stats.norm.rvs(size=100, random_state=rng)
>>> res = stats.quantile_test(rvs, q=0.6, p=0.75)
>>> ci = res.confidence_interval(confidence_level=0.95)
>>> ci
ConfidenceInterval(low=0.284491604437432, high=0.8912531024914844)

When testing a one-sided alternative, the confidence interval contains
all observations such that if passed as `q`, the p-value of the
test would be greater than 0.05, and therefore the null hypothesis
would not be rejected. For example:

>>> rvs.sort()
>>> q, p, alpha = 0.6, 0.75, 0.95
>>> res = stats.quantile_test(rvs, q=q, p=p, alternative='less')
>>> ci = res.confidence_interval(confidence_level=alpha)
>>> for x in rvs[rvs <= ci.high]:
...     res = stats.quantile_test(rvs, q=x, p=p, alternative='less')
...     assert res.pvalue > 1-alpha
>>> for x in rvs[rvs > ci.high]:
...     res = stats.quantile_test(rvs, q=x, p=p, alternative='less')
...     assert res.pvalue < 1-alpha

Also, if a 95% confidence interval is repeatedly generated for random
samples, the confidence interval will contain the true quantile value in
approximately 95% of replications.

>>> dist = stats.rayleigh() # our "unknown" distribution
>>> p = 0.2
>>> true_stat = dist.ppf(p) # the true value of the statistic
>>> n_trials = 1000
>>> quantile_ci_contains_true_stat = 0
>>> for i in range(n_trials):
...     data = dist.rvs(size=100, random_state=rng)
...     res = stats.quantile_test(data, p=p)
...     ci = res.confidence_interval(0.95)
...     if ci[0] < true_stat < ci[1]:
...         quantile_ci_contains_true_stat += 1
>>> quantile_ci_contains_true_stat >= 950
True

This works with any distribution and any quantile, as long as the samples
are i.i.d.
================================================================================

randint:
Firma: (*args, **kwds)

Docstring:
A uniform discrete random variable.

As an instance of the `rv_discrete` class, `randint` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(low, high, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, low, high, loc=0)
    Probability mass function.
logpmf(k, low, high, loc=0)
    Log of the probability mass function.
cdf(k, low, high, loc=0)
    Cumulative distribution function.
logcdf(k, low, high, loc=0)
    Log of the cumulative distribution function.
sf(k, low, high, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, low, high, loc=0)
    Log of the survival function.
ppf(q, low, high, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, low, high, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(low, high, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(low, high, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(low, high), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(low, high, loc=0)
    Median of the distribution.
mean(low, high, loc=0)
    Mean of the distribution.
var(low, high, loc=0)
    Variance of the distribution.
std(low, high, loc=0)
    Standard deviation of the distribution.
interval(confidence, low, high, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
The probability mass function for `randint` is:

.. math::

    f(k) = \frac{1}{\texttt{high} - \texttt{low}}

for :math:`k \in \{\texttt{low}, \dots, \texttt{high} - 1\}`.

`randint` takes :math:`\texttt{low}` and :math:`\texttt{high}` as shape
parameters.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``randint.pmf(k, low, high, loc)`` is identically
equivalent to ``randint.pmf(k - loc, low, high)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import randint
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> low, high = 7, 31
>>> mean, var, skew, kurt = randint.stats(low, high, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(low - 5, high + 5)
>>> ax.plot(x, randint.pmf(x, low, high), 'bo', ms=8, label='randint pmf')
>>> ax.vlines(x, 0, randint.pmf(x, low, high), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function) to
fix the shape and location. This returns a "frozen" RV object holding the
given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = randint(low, high)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-',
...           lw=1, label='frozen pmf')
>>> ax.legend(loc='lower center')
>>> plt.show()

Check the relationship between the cumulative distribution function
(``cdf``) and its inverse, the percent point function (``ppf``):

>>> q = np.arange(low, high)
>>> p = randint.cdf(q, low, high)
>>> np.allclose(q, randint.ppf(p, low, high))
True

Generate random numbers:

>>> r = randint.rvs(low, high, size=1000)
================================================================================

random_correlation:
Firma: (eigs, seed=None, tol=1e-13, diag_tol=1e-07)

Docstring:
A random correlation matrix.

Return a random correlation matrix, given a vector of eigenvalues.

The `eigs` keyword specifies the eigenvalues of the correlation matrix,
and implies the dimension.

Methods
-------
rvs(eigs=None, random_state=None)
    Draw random correlation matrices, all with eigenvalues eigs.

Parameters
----------
eigs : 1d ndarray
    Eigenvalues of correlation matrix
seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional
    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance
    then that instance is used.
tol : float, optional
    Tolerance for input parameter checks
diag_tol : float, optional
    Tolerance for deviation of the diagonal of the resulting
    matrix. Default: 1e-7

Raises
------
RuntimeError
    Floating point error prevented generating a valid correlation
    matrix.

Returns
-------
rvs : ndarray or scalar
    Random size N-dimensional matrices, dimension (size, dim, dim),
    each having eigenvalues eigs.

Notes
-----

Generates a random correlation matrix following a numerically stable
algorithm spelled out by Davies & Higham. This algorithm uses a single O(N)
similarity transformation to construct a symmetric positive semi-definite
matrix, and applies a series of Givens rotations to scale it to have ones
on the diagonal.

References
----------

.. [1] Davies, Philip I; Higham, Nicholas J; "Numerically stable generation
       of correlation matrices and their factors", BIT 2000, Vol. 40,
       No. 4, pp. 640 651

Examples
--------
>>> import numpy as np
>>> from scipy.stats import random_correlation
>>> rng = np.random.default_rng()
>>> x = random_correlation.rvs((.5, .8, 1.2, 1.5), random_state=rng)
>>> x
array([[ 1.        , -0.02423399,  0.03130519,  0.4946965 ],
       [-0.02423399,  1.        ,  0.20334736,  0.04039817],
       [ 0.03130519,  0.20334736,  1.        ,  0.02694275],
       [ 0.4946965 ,  0.04039817,  0.02694275,  1.        ]])
>>> import scipy.linalg
>>> e, v = scipy.linalg.eigh(x)
>>> e
array([ 0.5,  0.8,  1.2,  1.5])
================================================================================

random_table:
Firma: (row, col, *, seed=None)

Docstring:
Contingency tables from independent samples with fixed marginal sums.

This is the distribution of random tables with given row and column vector
sums. This distribution represents the set of random tables under the null
hypothesis that rows and columns are independent. It is used in hypothesis
tests of independence.

Because of assumed independence, the expected frequency of each table
element can be computed from the row and column sums, so that the
distribution is completely determined by these two vectors.

Methods
-------
logpmf(x)
    Log-probability of table `x` to occur in the distribution.
pmf(x)
    Probability of table `x` to occur in the distribution.
mean(row, col)
    Mean table.
rvs(row, col, size=None, method=None, random_state=None)
    Draw random tables with given row and column vector sums.

Parameters
----------
row : array_like
    Sum of table entries in each row.
col : array_like
    Sum of table entries in each column.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
The row and column vectors must be one-dimensional, not empty,
and each sum up to the same value. They cannot contain negative
or noninteger entries.

Random elements from the distribution are generated either with Boyett's
[1]_ or Patefield's algorithm [2]_. Boyett's algorithm has
O(N) time and space complexity, where N is the total sum of entries in the
table. Patefield's algorithm has O(K x log(N)) time complexity, where K is
the number of cells in the table and requires only a small constant work
space. By default, the `rvs` method selects the fastest algorithm based on
the input, but you can specify the algorithm with the keyword `method`.
Allowed values are "boyett" and "patefield".

.. versionadded:: 1.10.0

Examples
--------
>>> from scipy.stats import random_table

>>> row = [1, 5]
>>> col = [2, 3, 1]
>>> random_table.mean(row, col)
array([[0.33333333, 0.5       , 0.16666667],
       [1.66666667, 2.5       , 0.83333333]])

Alternatively, the object may be called (as a function) to fix the row
and column vector sums, returning a "frozen" distribution.

>>> dist = random_table(row, col)
>>> dist.rvs(random_state=123)
array([[1, 0, 0],
       [1, 3, 1]])

References
----------
.. [1] J. Boyett, AS 144 Appl. Statist. 28 (1979) 329-332
.. [2] W.M. Patefield, AS 159 Appl. Statist. 30 (1981) 91-97
================================================================================

rankdata:
Firma: (a, method='average', *, axis=None, nan_policy='propagate')

Docstring:
Assign ranks to data, dealing with ties appropriately.

By default (``axis=None``), the data array is first flattened, and a flat
array of ranks is returned. Separately reshape the rank array to the
shape of the data array if desired (see Examples).

Ranks begin at 1.  The `method` argument controls how ranks are assigned
to equal values.  See [1]_ for further discussion of ranking methods.

Parameters
----------
a : array_like
    The array of values to be ranked.
method : {'average', 'min', 'max', 'dense', 'ordinal'}, optional
    The method used to assign ranks to tied elements.
    The following methods are available (default is 'average'):

      * 'average': The average of the ranks that would have been assigned to
        all the tied values is assigned to each value.
      * 'min': The minimum of the ranks that would have been assigned to all
        the tied values is assigned to each value.  (This is also
        referred to as "competition" ranking.)
      * 'max': The maximum of the ranks that would have been assigned to all
        the tied values is assigned to each value.
      * 'dense': Like 'min', but the rank of the next highest element is
        assigned the rank immediately after those assigned to the tied
        elements.
      * 'ordinal': All values are given a distinct rank, corresponding to
        the order that the values occur in `a`.
axis : {None, int}, optional
    Axis along which to perform the ranking. If ``None``, the data array
    is first flattened.
nan_policy : {'propagate', 'omit', 'raise'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': propagates nans through the rank calculation
      * 'omit': performs the calculations ignoring nan values
      * 'raise': raises an error

    .. note::

        When `nan_policy` is 'propagate', the output is an array of *all*
        nans because ranks relative to nans in the input are undefined.
        When `nan_policy` is 'omit', nans in `a` are ignored when ranking
        the other values, and the corresponding locations of the output
        are nan.

    .. versionadded:: 1.10

Returns
-------
ranks : ndarray
     An array of size equal to the size of `a`, containing rank
     scores.

References
----------
.. [1] "Ranking", https://en.wikipedia.org/wiki/Ranking

Examples
--------
>>> import numpy as np
>>> from scipy.stats import rankdata
>>> rankdata([0, 2, 3, 2])
array([ 1. ,  2.5,  4. ,  2.5])
>>> rankdata([0, 2, 3, 2], method='min')
array([ 1,  2,  4,  2])
>>> rankdata([0, 2, 3, 2], method='max')
array([ 1,  3,  4,  3])
>>> rankdata([0, 2, 3, 2], method='dense')
array([ 1,  2,  3,  2])
>>> rankdata([0, 2, 3, 2], method='ordinal')
array([ 1,  2,  4,  3])
>>> rankdata([[0, 2], [3, 2]]).reshape(2,2)
array([[1. , 2.5],
      [4. , 2.5]])
>>> rankdata([[0, 2, 2], [3, 2, 5]], axis=1)
array([[1. , 2.5, 2.5],
       [2. , 1. , 3. ]])
>>> rankdata([0, 2, 3, np.nan, -2, np.nan], nan_policy="propagate")
array([nan, nan, nan, nan, nan, nan])
>>> rankdata([0, 2, 3, np.nan, -2, np.nan], nan_policy="omit")
array([ 2.,  3.,  4., nan,  1., nan])
================================================================================

ranksums:
Firma: (x, y, alternative='two-sided', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Compute the Wilcoxon rank-sum statistic for two samples.

The Wilcoxon rank-sum test tests the null hypothesis that two sets
of measurements are drawn from the same distribution.  The alternative
hypothesis is that values in one sample are more likely to be
larger than the values in the other sample.

This test should be used to compare two samples from continuous
distributions.  It does not handle ties between measurements
in x and y.  For tie-handling and an optional continuity correction
see `scipy.stats.mannwhitneyu`.

Parameters
----------
x,y : array_like
    The data from the two samples.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:
    
    * 'two-sided': one of the distributions (underlying `x` or `y`) is
      stochastically greater than the other.
    * 'less': the distribution underlying `x` is stochastically less
      than the distribution underlying `y`.
    * 'greater': the distribution underlying `x` is stochastically greater
      than the distribution underlying `y`.
    
    .. versionadded:: 1.7.0
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic under the large-sample approximation that the
    rank sum statistic is normally distributed.
pvalue : float
    The p-value of the test.

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test

Examples
--------
We can test the hypothesis that two independent unequal-sized samples are
drawn from the same distribution with computing the Wilcoxon rank-sum
statistic.

>>> import numpy as np
>>> from scipy.stats import ranksums
>>> rng = np.random.default_rng()
>>> sample1 = rng.uniform(-1, 1, 200)
>>> sample2 = rng.uniform(-0.5, 1.5, 300) # a shifted distribution
>>> ranksums(sample1, sample2)
RanksumsResult(statistic=-7.887059,
               pvalue=3.09390448e-15) # may vary
>>> ranksums(sample1, sample2, alternative='less')
RanksumsResult(statistic=-7.750585297581713,
               pvalue=4.573497606342543e-15) # may vary
>>> ranksums(sample1, sample2, alternative='greater')
RanksumsResult(statistic=-7.750585297581713,
               pvalue=0.9999999999999954) # may vary

The p-value of less than ``0.05`` indicates that this test rejects the
hypothesis at the 5% significance level.
================================================================================

rayleigh:
Firma: (*args, **kwds)

Docstring:
A Rayleigh continuous random variable.

As an instance of the `rv_continuous` class, `rayleigh` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `rayleigh` is:

.. math::

    f(x) = x \exp(-x^2/2)

for :math:`x \ge 0`.

`rayleigh` is a special case of `chi` with ``df=2``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``rayleigh.pdf(x, loc, scale)`` is identically
equivalent to ``rayleigh.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import rayleigh
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = rayleigh.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(rayleigh.ppf(0.01),
...                 rayleigh.ppf(0.99), 100)
>>> ax.plot(x, rayleigh.pdf(x),
...        'r-', lw=5, alpha=0.6, label='rayleigh pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = rayleigh()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = rayleigh.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], rayleigh.cdf(vals))
True

Generate random numbers:

>>> r = rayleigh.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

rdist:
Firma: (*args, **kwds)

Docstring:
An R-distributed (symmetric beta) continuous random variable.

As an instance of the `rv_continuous` class, `rdist` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `rdist` is:

.. math::

    f(x, c) = \frac{(1-x^2)^{c/2-1}}{B(1/2, c/2)}

for :math:`-1 \le x \le 1`, :math:`c > 0`. `rdist` is also called the
symmetric beta distribution: if B has a `beta` distribution with
parameters (c/2, c/2), then X = 2*B - 1 follows a R-distribution with
parameter c.

`rdist` takes ``c`` as a shape parameter for :math:`c`.

This distribution includes the following distribution kernels as
special cases::

    c = 2:  uniform
    c = 3:  `semicircular`
    c = 4:  Epanechnikov (parabolic)
    c = 6:  quartic (biweight)
    c = 8:  triweight

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``rdist.pdf(x, c, loc, scale)`` is identically
equivalent to ``rdist.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import rdist
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 1.6
>>> mean, var, skew, kurt = rdist.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(rdist.ppf(0.01, c),
...                 rdist.ppf(0.99, c), 100)
>>> ax.plot(x, rdist.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='rdist pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = rdist(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = rdist.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], rdist.cdf(vals, c))
True

Generate random numbers:

>>> r = rdist.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

recipinvgauss:
Firma: (*args, **kwds)

Docstring:
A reciprocal inverse Gaussian continuous random variable.

As an instance of the `rv_continuous` class, `recipinvgauss` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(mu, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, mu, loc=0, scale=1)
    Probability density function.
logpdf(x, mu, loc=0, scale=1)
    Log of the probability density function.
cdf(x, mu, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, mu, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, mu, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, mu, loc=0, scale=1)
    Log of the survival function.
ppf(q, mu, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, mu, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, mu, loc=0, scale=1)
    Non-central moment of the specified order.
stats(mu, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(mu, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(mu,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(mu, loc=0, scale=1)
    Median of the distribution.
mean(mu, loc=0, scale=1)
    Mean of the distribution.
var(mu, loc=0, scale=1)
    Variance of the distribution.
std(mu, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, mu, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `recipinvgauss` is:

.. math::

    f(x, \mu) = \frac{1}{\sqrt{2\pi x}}
                \exp\left(\frac{-(1-\mu x)^2}{2\mu^2x}\right)

for :math:`x \ge 0`.

`recipinvgauss` takes ``mu`` as a shape parameter for :math:`\mu`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``recipinvgauss.pdf(x, mu, loc, scale)`` is identically
equivalent to ``recipinvgauss.pdf(y, mu) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import recipinvgauss
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mu = 0.63
>>> mean, var, skew, kurt = recipinvgauss.stats(mu, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(recipinvgauss.ppf(0.01, mu),
...                 recipinvgauss.ppf(0.99, mu), 100)
>>> ax.plot(x, recipinvgauss.pdf(x, mu),
...        'r-', lw=5, alpha=0.6, label='recipinvgauss pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = recipinvgauss(mu)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = recipinvgauss.ppf([0.001, 0.5, 0.999], mu)
>>> np.allclose([0.001, 0.5, 0.999], recipinvgauss.cdf(vals, mu))
True

Generate random numbers:

>>> r = recipinvgauss.rvs(mu, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

reciprocal:
Firma: (*args, **kwds)

Docstring:
A loguniform or reciprocal continuous random variable.

As an instance of the `rv_continuous` class, `reciprocal` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for this class is:

.. math::

    f(x, a, b) = \frac{1}{x \log(b/a)}

for :math:`a \le x \le b`, :math:`b > a > 0`. This class takes
:math:`a` and :math:`b` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``reciprocal.pdf(x, a, b, loc, scale)`` is identically
equivalent to ``reciprocal.pdf(y, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import reciprocal
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 0.01, 1.25
>>> mean, var, skew, kurt = reciprocal.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(reciprocal.ppf(0.01, a, b),
...                 reciprocal.ppf(0.99, a, b), 100)
>>> ax.plot(x, reciprocal.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='reciprocal pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = reciprocal(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = reciprocal.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], reciprocal.cdf(vals, a, b))
True

Generate random numbers:

>>> r = reciprocal.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


This doesn't show the equal probability of ``0.01``, ``0.1`` and
``1``. This is best when the x-axis is log-scaled:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)
>>> ax.hist(np.log10(r))
>>> ax.set_ylabel("Frequency")
>>> ax.set_xlabel("Value of random variable")
>>> ax.xaxis.set_major_locator(plt.FixedLocator([-2, -1, 0]))
>>> ticks = ["$10^{{ {} }}$".format(i) for i in [-2, -1, 0]]
>>> ax.set_xticklabels(ticks)  # doctest: +SKIP
>>> plt.show()

This random variable will be log-uniform regardless of the base chosen for
``a`` and ``b``. Let's specify with base ``2`` instead:

>>> rvs = reciprocal(2**-2, 2**0).rvs(size=1000)

Values of ``1/4``, ``1/2`` and ``1`` are equally likely with this random
variable.  Here's the histogram:

>>> fig, ax = plt.subplots(1, 1)
>>> ax.hist(np.log2(rvs))
>>> ax.set_ylabel("Frequency")
>>> ax.set_xlabel("Value of random variable")
>>> ax.xaxis.set_major_locator(plt.FixedLocator([-2, -1, 0]))
>>> ticks = ["$2^{{ {} }}$".format(i) for i in [-2, -1, 0]]
>>> ax.set_xticklabels(ticks)  # doctest: +SKIP
>>> plt.show()
================================================================================

rel_breitwigner:
Firma: (*args, **kwds)

Docstring:
A relativistic Breit-Wigner random variable.

As an instance of the `rv_continuous` class, `rel_breitwigner` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(rho, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, rho, loc=0, scale=1)
    Probability density function.
logpdf(x, rho, loc=0, scale=1)
    Log of the probability density function.
cdf(x, rho, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, rho, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, rho, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, rho, loc=0, scale=1)
    Log of the survival function.
ppf(q, rho, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, rho, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, rho, loc=0, scale=1)
    Non-central moment of the specified order.
stats(rho, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(rho, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(rho,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(rho, loc=0, scale=1)
    Median of the distribution.
mean(rho, loc=0, scale=1)
    Mean of the distribution.
var(rho, loc=0, scale=1)
    Variance of the distribution.
std(rho, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, rho, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
cauchy: Cauchy distribution, also known as the Breit-Wigner distribution.

Notes
-----

The probability density function for `rel_breitwigner` is

.. math::

    f(x, \rho) = \frac{k}{(x^2 - \rho^2)^2 + \rho^2}

where

.. math::
    k = \frac{2\sqrt{2}\rho^2\sqrt{\rho^2 + 1}}
        {\pi\sqrt{\rho^2 + \rho\sqrt{\rho^2 + 1}}}

The relativistic Breit-Wigner distribution is used in high energy physics
to model resonances [1]_. It gives the uncertainty in the invariant mass,
:math:`M` [2]_, of a resonance with characteristic mass :math:`M_0` and
decay-width :math:`\Gamma`, where :math:`M`, :math:`M_0` and :math:`\Gamma`
are expressed in natural units. In SciPy's parametrization, the shape
parameter :math:`\rho` is equal to :math:`M_0/\Gamma` and takes values in
:math:`(0, \infty)`.

Equivalently, the relativistic Breit-Wigner distribution is said to give
the uncertainty in the center-of-mass energy :math:`E_{\text{cm}}`. In
natural units, the speed of light :math:`c` is equal to 1 and the invariant
mass :math:`M` is equal to the rest energy :math:`Mc^2`. In the
center-of-mass frame, the rest energy is equal to the total energy [3]_.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``rel_breitwigner.pdf(x, rho, loc, scale)`` is identically
equivalent to ``rel_breitwigner.pdf(y, rho) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

:math:`\rho = M/\Gamma` and :math:`\Gamma` is the scale parameter. For
example, if one seeks to model the :math:`Z^0` boson with :math:`M_0
\approx 91.1876 \text{ GeV}` and :math:`\Gamma \approx 2.4952\text{ GeV}`
[4]_ one can set ``rho=91.1876/2.4952`` and ``scale=2.4952``.

To ensure a physically meaningful result when using the `fit` method, one
should set ``floc=0`` to fix the location parameter to 0.

References
----------
.. [1] Relativistic Breit-Wigner distribution, Wikipedia,
       https://en.wikipedia.org/wiki/Relativistic_Breit-Wigner_distribution
.. [2] Invariant mass, Wikipedia,
       https://en.wikipedia.org/wiki/Invariant_mass
.. [3] Center-of-momentum frame, Wikipedia,
       https://en.wikipedia.org/wiki/Center-of-momentum_frame
.. [4] M. Tanabashi et al. (Particle Data Group) Phys. Rev. D 98, 030001 -
       Published 17 August 2018

Examples
--------
>>> import numpy as np
>>> from scipy.stats import rel_breitwigner
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> rho = 36.5
>>> mean, var, skew, kurt = rel_breitwigner.stats(rho, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(rel_breitwigner.ppf(0.01, rho),
...                 rel_breitwigner.ppf(0.99, rho), 100)
>>> ax.plot(x, rel_breitwigner.pdf(x, rho),
...        'r-', lw=5, alpha=0.6, label='rel_breitwigner pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = rel_breitwigner(rho)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = rel_breitwigner.ppf([0.001, 0.5, 0.999], rho)
>>> np.allclose([0.001, 0.5, 0.999], rel_breitwigner.cdf(vals, rho))
True

Generate random numbers:

>>> r = rel_breitwigner.rvs(rho, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

relfreq:
Firma: (a, numbins=10, defaultreallimits=None, weights=None)

Docstring:
Return a relative frequency histogram, using the histogram function.

A relative frequency  histogram is a mapping of the number of
observations in each of the bins relative to the total of observations.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
frequency : ndarray
    Binned values of relative frequency.
lowerlimit : float
    Lower real limit.
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> a = np.array([2, 4, 1, 2, 3, 2])
>>> res = stats.relfreq(a, numbins=4)
>>> res.frequency
array([ 0.16666667, 0.5       , 0.16666667,  0.16666667])
>>> np.sum(res.frequency)  # relative frequencies should add up to 1
1.0

Create a normal distribution with 1000 random values

>>> samples = stats.norm.rvs(size=1000, random_state=rng)

Calculate relative frequencies

>>> res = stats.relfreq(samples, numbins=25)

Calculate space of values for x

>>> x = res.lowerlimit + np.linspace(0, res.binsize*res.frequency.size,
...                                  res.frequency.size)

Plot relative frequency histogram

>>> fig = plt.figure(figsize=(5, 4))
>>> ax = fig.add_subplot(1, 1, 1)
>>> ax.bar(x, res.frequency, width=res.binsize)
>>> ax.set_title('Relative frequency histogram')
>>> ax.set_xlim([x.min(), x.max()])

>>> plt.show()
================================================================================

rice:
Firma: (*args, **kwds)

Docstring:
A Rice continuous random variable.

As an instance of the `rv_continuous` class, `rice` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, b, loc=0, scale=1)
    Probability density function.
logpdf(x, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(b,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(b, loc=0, scale=1)
    Median of the distribution.
mean(b, loc=0, scale=1)
    Mean of the distribution.
var(b, loc=0, scale=1)
    Variance of the distribution.
std(b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `rice` is:

.. math::

    f(x, b) = x \exp(- \frac{x^2 + b^2}{2}) I_0(x b)

for :math:`x >= 0`, :math:`b > 0`. :math:`I_0` is the modified Bessel
function of order zero (`scipy.special.i0`).

`rice` takes ``b`` as a shape parameter for :math:`b`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``rice.pdf(x, b, loc, scale)`` is identically
equivalent to ``rice.pdf(y, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The Rice distribution describes the length, :math:`r`, of a 2-D vector with
components :math:`(U+u, V+v)`, where :math:`U, V` are constant, :math:`u,
v` are independent Gaussian random variables with standard deviation
:math:`s`.  Let :math:`R = \sqrt{U^2 + V^2}`. Then the pdf of :math:`r` is
``rice.pdf(x, R/s, scale=s)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import rice
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> b = 0.775
>>> mean, var, skew, kurt = rice.stats(b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(rice.ppf(0.01, b),
...                 rice.ppf(0.99, b), 100)
>>> ax.plot(x, rice.pdf(x, b),
...        'r-', lw=5, alpha=0.6, label='rice pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = rice(b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = rice.ppf([0.001, 0.5, 0.999], b)
>>> np.allclose([0.001, 0.5, 0.999], rice.cdf(vals, b))
True

Generate random numbers:

>>> r = rice.rvs(b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

rv_continuous:
Firma: (momtype=1, a=None, b=None, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, seed=None)

Docstring:
A generic continuous random variable class meant for subclassing.

`rv_continuous` is a base class to construct specific distribution classes
and instances for continuous random variables. It cannot be used
directly as a distribution.

Parameters
----------
momtype : int, optional
    The type of generic moment calculation to use: 0 for pdf, 1 (default)
    for ppf.
a : float, optional
    Lower bound of the support of the distribution, default is minus
    infinity.
b : float, optional
    Upper bound of the support of the distribution, default is plus
    infinity.
xtol : float, optional
    The tolerance for fixed point calculation for generic ppf.
badvalue : float, optional
    The value in a result arrays that indicates a value that for which
    some argument restriction is violated, default is np.nan.
name : str, optional
    The name of the instance. This string is used to construct the default
    example for distributions.
longname : str, optional
    This string is used as part of the first line of the docstring returned
    when a subclass has no docstring of its own. Note: `longname` exists
    for backwards compatibility, do not use for new subclasses.
shapes : str, optional
    The shape of the distribution. For example ``"m, n"`` for a
    distribution that takes two integers as the two shape arguments for all
    its methods. If not provided, shape parameters will be inferred from
    the signature of the private methods, ``_pdf`` and ``_cdf`` of the
    instance.
seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional
    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

Methods
-------
rvs
pdf
logpdf
cdf
logcdf
sf
logsf
ppf
isf
moment
stats
entropy
expect
median
mean
std
var
interval
__call__
fit
fit_loc_scale
nnlf
support

Notes
-----
Public methods of an instance of a distribution class (e.g., ``pdf``,
``cdf``) check their arguments and pass valid arguments to private,
computational methods (``_pdf``, ``_cdf``). For ``pdf(x)``, ``x`` is valid
if it is within the support of the distribution.
Whether a shape parameter is valid is decided by an ``_argcheck`` method
(which defaults to checking that its arguments are strictly positive.)

**Subclassing**

New random variables can be defined by subclassing the `rv_continuous` class
and re-defining at least the ``_pdf`` or the ``_cdf`` method (normalized
to location 0 and scale 1).

If positive argument checking is not correct for your RV
then you will also need to re-define the ``_argcheck`` method.

For most of the scipy.stats distributions, the support interval doesn't
depend on the shape parameters. ``x`` being in the support interval is
equivalent to ``self.a <= x <= self.b``.  If either of the endpoints of
the support do depend on the shape parameters, then
i) the distribution must implement the ``_get_support`` method; and
ii) those dependent endpoints must be omitted from the distribution's
call to the ``rv_continuous`` initializer.

Correct, but potentially slow defaults exist for the remaining
methods but for speed and/or accuracy you can over-ride::

  _logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf

The default method ``_rvs`` relies on the inverse of the cdf, ``_ppf``,
applied to a uniform random variate. In order to generate random variates
efficiently, either the default ``_ppf`` needs to be overwritten (e.g.
if the inverse cdf can expressed in an explicit form) or a sampling
method needs to be implemented in a custom ``_rvs`` method.

If possible, you should override ``_isf``, ``_sf`` or ``_logsf``.
The main reason would be to improve numerical accuracy: for example,
the survival function ``_sf`` is computed as ``1 - _cdf`` which can
result in loss of precision if ``_cdf(x)`` is close to one.

**Methods that can be overwritten by subclasses**
::

  _rvs
  _pdf
  _cdf
  _sf
  _ppf
  _isf
  _stats
  _munp
  _entropy
  _argcheck
  _get_support

There are additional (internal and private) generic methods that can
be useful for cross-checking and for debugging, but might work in all
cases when directly called.

A note on ``shapes``: subclasses need not specify them explicitly. In this
case, `shapes` will be automatically deduced from the signatures of the
overridden methods (`pdf`, `cdf` etc).
If, for some reason, you prefer to avoid relying on introspection, you can
specify ``shapes`` explicitly as an argument to the instance constructor.


**Frozen Distributions**

Normally, you must provide shape parameters (and, optionally, location and
scale parameters to each call of a method of a distribution.

Alternatively, the object may be called (as a function) to fix the shape,
location, and scale parameters returning a "frozen" continuous RV object:

rv = generic(<shape(s)>, loc=0, scale=1)
    `rv_frozen` object with the same methods but holding the given shape,
    location, and scale fixed

**Statistics**

Statistics are computed using numerical integration by default.
For speed you can redefine this using ``_stats``:

 - take shape parameters and return mu, mu2, g1, g2
 - If you can't compute one of these, return it as None
 - Can also be defined with a keyword argument ``moments``, which is a
   string composed of "m", "v", "s", and/or "k".
   Only the components appearing in string should be computed and
   returned in the order "m", "v", "s", or "k"  with missing values
   returned as None.

Alternatively, you can override ``_munp``, which takes ``n`` and shape
parameters and returns the n-th non-central moment of the distribution.

**Deepcopying / Pickling**

If a distribution or frozen distribution is deepcopied (pickled/unpickled,
etc.), any underlying random number generator is deepcopied with it. An
implication is that if a distribution relies on the singleton RandomState
before copying, it will rely on a copy of that random state after copying,
and ``np.random.seed`` will no longer control the state.

Examples
--------
To create a new Gaussian distribution, we would do the following:

>>> from scipy.stats import rv_continuous
>>> class gaussian_gen(rv_continuous):
...     "Gaussian distribution"
...     def _pdf(self, x):
...         return np.exp(-x**2 / 2.) / np.sqrt(2.0 * np.pi)
>>> gaussian = gaussian_gen(name='gaussian')

``scipy.stats`` distributions are *instances*, so here we subclass
`rv_continuous` and create an instance. With this, we now have
a fully functional distribution with all relevant methods automagically
generated by the framework.

Note that above we defined a standard normal distribution, with zero mean
and unit variance. Shifting and scaling of the distribution can be done
by using ``loc`` and ``scale`` parameters: ``gaussian.pdf(x, loc, scale)``
essentially computes ``y = (x - loc) / scale`` and
``gaussian._pdf(y) / scale``.
================================================================================

rv_discrete:
Firma: (a=0, b=inf, name=None, badvalue=None, moment_tol=1e-08, values=None, inc=1, longname=None, shapes=None, seed=None)

Docstring:
A generic discrete random variable class meant for subclassing.

`rv_discrete` is a base class to construct specific distribution classes
and instances for discrete random variables. It can also be used
to construct an arbitrary distribution defined by a list of support
points and corresponding probabilities.

Parameters
----------
a : float, optional
    Lower bound of the support of the distribution, default: 0
b : float, optional
    Upper bound of the support of the distribution, default: plus infinity
moment_tol : float, optional
    The tolerance for the generic calculation of moments.
values : tuple of two array_like, optional
    ``(xk, pk)`` where ``xk`` are integers and ``pk`` are the non-zero
    probabilities between 0 and 1 with ``sum(pk) = 1``. ``xk``
    and ``pk`` must have the same shape, and ``xk`` must be unique.
inc : integer, optional
    Increment for the support of the distribution.
    Default is 1. (other values have not been tested)
badvalue : float, optional
    The value in a result arrays that indicates a value that for which
    some argument restriction is violated, default is np.nan.
name : str, optional
    The name of the instance. This string is used to construct the default
    example for distributions.
longname : str, optional
    This string is used as part of the first line of the docstring returned
    when a subclass has no docstring of its own. Note: `longname` exists
    for backwards compatibility, do not use for new subclasses.
shapes : str, optional
    The shape of the distribution. For example "m, n" for a distribution
    that takes two integers as the two shape arguments for all its methods
    If not provided, shape parameters will be inferred from
    the signatures of the private methods, ``_pmf`` and ``_cdf`` of
    the instance.
seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional
    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

Methods
-------
rvs
pmf
logpmf
cdf
logcdf
sf
logsf
ppf
isf
moment
stats
entropy
expect
median
mean
std
var
interval
__call__
support

Notes
-----
This class is similar to `rv_continuous`. Whether a shape parameter is
valid is decided by an ``_argcheck`` method (which defaults to checking
that its arguments are strictly positive.)
The main differences are as follows.

- The support of the distribution is a set of integers.
- Instead of the probability density function, ``pdf`` (and the
  corresponding private ``_pdf``), this class defines the
  *probability mass function*, `pmf` (and the corresponding
  private ``_pmf``.)
- There is no ``scale`` parameter.
- The default implementations of methods (e.g. ``_cdf``) are not designed
  for distributions with support that is unbounded below (i.e.
  ``a=-np.inf``), so they must be overridden.

To create a new discrete distribution, we would do the following:

>>> from scipy.stats import rv_discrete
>>> class poisson_gen(rv_discrete):
...     "Poisson distribution"
...     def _pmf(self, k, mu):
...         return exp(-mu) * mu**k / factorial(k)

and create an instance::

>>> poisson = poisson_gen(name="poisson")

Note that above we defined the Poisson distribution in the standard form.
Shifting the distribution can be done by providing the ``loc`` parameter
to the methods of the instance. For example, ``poisson.pmf(x, mu, loc)``
delegates the work to ``poisson._pmf(x-loc, mu)``.

**Discrete distributions from a list of probabilities**

Alternatively, you can construct an arbitrary discrete rv defined
on a finite set of values ``xk`` with ``Prob{X=xk} = pk`` by using the
``values`` keyword argument to the `rv_discrete` constructor.

**Deepcopying / Pickling**

If a distribution or frozen distribution is deepcopied (pickled/unpickled,
etc.), any underlying random number generator is deepcopied with it. An
implication is that if a distribution relies on the singleton RandomState
before copying, it will rely on a copy of that random state after copying,
and ``np.random.seed`` will no longer control the state.

Examples
--------
Custom made discrete distribution:

>>> import numpy as np
>>> from scipy import stats
>>> xk = np.arange(7)
>>> pk = (0.1, 0.2, 0.3, 0.1, 0.1, 0.0, 0.2)
>>> custm = stats.rv_discrete(name='custm', values=(xk, pk))
>>>
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)
>>> ax.plot(xk, custm.pmf(xk), 'ro', ms=12, mec='r')
>>> ax.vlines(xk, 0, custm.pmf(xk), colors='r', lw=4)
>>> plt.show()

Random number generation:

>>> R = custm.rvs(size=100)
================================================================================

rv_histogram:
Firma: (histogram, *args, density=None, **kwargs)

Docstring:
Generates a distribution given by a histogram.
This is useful to generate a template distribution from a binned
datasample.

As a subclass of the `rv_continuous` class, `rv_histogram` inherits from it
a collection of generic methods (see `rv_continuous` for the full list),
and implements them based on the properties of the provided binned
datasample.

Parameters
----------
histogram : tuple of array_like
    Tuple containing two array_like objects.
    The first containing the content of n bins,
    the second containing the (n+1) bin boundaries.
    In particular, the return value of `numpy.histogram` is accepted.

density : bool, optional
    If False, assumes the histogram is proportional to counts per bin;
    otherwise, assumes it is proportional to a density.
    For constant bin widths, these are equivalent, but the distinction
    is important when bin widths vary (see Notes).
    If None (default), sets ``density=True`` for backwards compatibility,
    but warns if the bin widths are variable. Set `density` explicitly
    to silence the warning.

    .. versionadded:: 1.10.0

Notes
-----
When a histogram has unequal bin widths, there is a distinction between
histograms that are proportional to counts per bin and histograms that are
proportional to probability density over a bin. If `numpy.histogram` is
called with its default ``density=False``, the resulting histogram is the
number of counts per bin, so ``density=False`` should be passed to
`rv_histogram`. If `numpy.histogram` is called with ``density=True``, the
resulting histogram is in terms of probability density, so ``density=True``
should be passed to `rv_histogram`. To avoid warnings, always pass
``density`` explicitly when the input histogram has unequal bin widths.

There are no additional shape parameters except for the loc and scale.
The pdf is defined as a stepwise function from the provided histogram.
The cdf is a linear interpolation of the pdf.

.. versionadded:: 0.19.0

Examples
--------

Create a scipy.stats distribution from a numpy histogram

>>> import scipy.stats
>>> import numpy as np
>>> data = scipy.stats.norm.rvs(size=100000, loc=0, scale=1.5,
...                             random_state=123)
>>> hist = np.histogram(data, bins=100)
>>> hist_dist = scipy.stats.rv_histogram(hist, density=False)

Behaves like an ordinary scipy rv_continuous distribution

>>> hist_dist.pdf(1.0)
0.20538577847618705
>>> hist_dist.cdf(2.0)
0.90818568543056499

PDF is zero above (below) the highest (lowest) bin of the histogram,
defined by the max (min) of the original dataset

>>> hist_dist.pdf(np.max(data))
0.0
>>> hist_dist.cdf(np.max(data))
1.0
>>> hist_dist.pdf(np.min(data))
7.7591907244498314e-05
>>> hist_dist.cdf(np.min(data))
0.0

PDF and CDF follow the histogram

>>> import matplotlib.pyplot as plt
>>> X = np.linspace(-5.0, 5.0, 100)
>>> fig, ax = plt.subplots()
>>> ax.set_title("PDF from Template")
>>> ax.hist(data, density=True, bins=100)
>>> ax.plot(X, hist_dist.pdf(X), label='PDF')
>>> ax.plot(X, hist_dist.cdf(X), label='CDF')
>>> ax.legend()
>>> fig.show()
================================================================================

scoreatpercentile:
Firma: (a, per, limit=(), interpolation_method='fraction', axis=None)

Docstring:
Calculate the score at a given percentile of the input sequence.

For example, the score at ``per=50`` is the median. If the desired quantile
lies between two data points, we interpolate between them, according to
the value of `interpolation`. If the parameter `limit` is provided, it
should be a tuple (lower, upper) of two values.

Parameters
----------
a : array_like
    A 1-D array of values from which to extract score.
per : array_like
    Percentile(s) at which to extract score.  Values should be in range
    [0,100].
limit : tuple, optional
    Tuple of two scalars, the lower and upper limits within which to
    compute the percentile. Values of `a` outside
    this (closed) interval will be ignored.
interpolation_method : {'fraction', 'lower', 'higher'}, optional
    Specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`
    The following options are available (default is 'fraction'):

      * 'fraction': ``i + (j - i) * fraction`` where ``fraction`` is the
        fractional part of the index surrounded by ``i`` and ``j``
      * 'lower': ``i``
      * 'higher': ``j``

axis : int, optional
    Axis along which the percentiles are computed. Default is None. If
    None, compute over the whole array `a`.

Returns
-------
score : float or ndarray
    Score at percentile(s).

See Also
--------
percentileofscore, numpy.percentile

Notes
-----
This function will become obsolete in the future.
For NumPy 1.9 and higher, `numpy.percentile` provides all the functionality
that `scoreatpercentile` provides.  And it's significantly faster.
Therefore it's recommended to use `numpy.percentile` for users that have
numpy >= 1.9.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> a = np.arange(100)
>>> stats.scoreatpercentile(a, 50)
49.5
================================================================================

sem:
Firma: (a, axis=0, ddof=1, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute standard error of the mean.

Calculate the standard error of the mean (or standard error of
measurement) of the values in the input array.

Parameters
----------
a : array_like
    An array containing the values for which the standard error is
    returned. Must contain at least two observations.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
ddof : int, optional
    Delta degrees-of-freedom. How many degrees of freedom to adjust
    for bias in limited samples relative to the population estimate
    of variance. Defaults to 1.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
s : ndarray or float
    The standard error of the mean in the sample(s), along the input axis.

Notes
-----
The default value for `ddof` is different to the default (0) used by other
ddof containing routines, such as np.std and np.nanstd.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
Find standard error along the first axis:

>>> import numpy as np
>>> from scipy import stats
>>> a = np.arange(20).reshape(5,4)
>>> stats.sem(a)
array([ 2.8284,  2.8284,  2.8284,  2.8284])

Find standard error across the whole array, using n degrees of freedom:

>>> stats.sem(a, axis=None, ddof=0)
1.2893796958227628
================================================================================

semicircular:
Firma: (*args, **kwds)

Docstring:
A semicircular continuous random variable.

As an instance of the `rv_continuous` class, `semicircular` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
rdist

Notes
-----
The probability density function for `semicircular` is:

.. math::

    f(x) = \frac{2}{\pi} \sqrt{1-x^2}

for :math:`-1 \le x \le 1`.

The distribution is a special case of `rdist` with ``c = 3``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``semicircular.pdf(x, loc, scale)`` is identically
equivalent to ``semicircular.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] "Wigner semicircle distribution",
       https://en.wikipedia.org/wiki/Wigner_semicircle_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import semicircular
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = semicircular.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(semicircular.ppf(0.01),
...                 semicircular.ppf(0.99), 100)
>>> ax.plot(x, semicircular.pdf(x),
...        'r-', lw=5, alpha=0.6, label='semicircular pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = semicircular()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = semicircular.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], semicircular.cdf(vals))
True

Generate random numbers:

>>> r = semicircular.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

shapiro:
Firma: (x, *, axis=None, nan_policy='propagate', keepdims=False)

Docstring:
Perform the Shapiro-Wilk test for normality.

The Shapiro-Wilk test tests the null hypothesis that the
data was drawn from a normal distribution.

Parameters
----------
x : array_like
    Array of sample data. Must contain at least three observations.
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The test statistic.
p-value : float
    The p-value for the hypothesis test.

See Also
--------

:func:`anderson`
    The Anderson-Darling test for normality
:func:`kstest`
    The Kolmogorov-Smirnov test for goodness of fit.
:ref:`hypothesis_shapiro`
    Extended example


Notes
-----
The algorithm used is described in [4]_ but censoring parameters as
described are not implemented. For N > 5000 the W test statistic is
accurate, but the p-value may not be.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
       :doi:`10.18434/M32189`
.. [2] Shapiro, S. S. & Wilk, M.B, "An analysis of variance test for
       normality (complete samples)", Biometrika, 1965, Vol. 52,
       pp. 591-611, :doi:`10.2307/2333709`
.. [3] Razali, N. M. & Wah, Y. B., "Power comparisons of Shapiro-Wilk,
       Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests", Journal
       of Statistical Modeling and Analytics, 2011, Vol. 2, pp. 21-33.
.. [4] Royston P., "Remark AS R94: A Remark on Algorithm AS 181: The
       W-test for Normality", 1995, Applied Statistics, Vol. 44,
       :doi:`10.2307/2986146`

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = stats.norm.rvs(loc=5, scale=3, size=100, random_state=rng)
>>> shapiro_test = stats.shapiro(x)
>>> shapiro_test
ShapiroResult(statistic=0.9813305735588074, pvalue=0.16855233907699585)
>>> shapiro_test.statistic
0.9813305735588074
>>> shapiro_test.pvalue
0.16855233907699585

For a more detailed example, see :ref:`hypothesis_shapiro`.
================================================================================

siegelslopes:
Firma: (y, x=None, method='hierarchical')

Docstring:
Computes the Siegel estimator for a set of points (x, y).

`siegelslopes` implements a method for robust linear regression
using repeated medians (see [1]_) to fit a line to the points (x, y).
The method is robust to outliers with an asymptotic breakdown point
of 50%.

Parameters
----------
y : array_like
    Dependent variable.
x : array_like or None, optional
    Independent variable. If None, use ``arange(len(y))`` instead.
method : {'hierarchical', 'separate'}
    If 'hierarchical', estimate the intercept using the estimated
    slope ``slope`` (default option).
    If 'separate', estimate the intercept independent of the estimated
    slope. See Notes for details.

Returns
-------
result : ``SiegelslopesResult`` instance
    The return value is an object with the following attributes:

    slope : float
        Estimate of the slope of the regression line.
    intercept : float
        Estimate of the intercept of the regression line.

See Also
--------
theilslopes : a similar technique without repeated medians

Notes
-----
With ``n = len(y)``, compute ``m_j`` as the median of
the slopes from the point ``(x[j], y[j])`` to all other `n-1` points.
``slope`` is then the median of all slopes ``m_j``.
Two ways are given to estimate the intercept in [1]_ which can be chosen
via the parameter ``method``.
The hierarchical approach uses the estimated slope ``slope``
and computes ``intercept`` as the median of ``y - slope*x``.
The other approach estimates the intercept separately as follows: for
each point ``(x[j], y[j])``, compute the intercepts of all the `n-1`
lines through the remaining points and take the median ``i_j``.
``intercept`` is the median of the ``i_j``.

The implementation computes `n` times the median of a vector of size `n`
which can be slow for large vectors. There are more efficient algorithms
(see [2]_) which are not implemented here.

For compatibility with older versions of SciPy, the return value acts
like a ``namedtuple`` of length 2, with fields ``slope`` and
``intercept``, so one can continue to write::

    slope, intercept = siegelslopes(y, x)

References
----------
.. [1] A. Siegel, "Robust Regression Using Repeated Medians",
       Biometrika, Vol. 69, pp. 242-244, 1982.

.. [2] A. Stein and M. Werman, "Finding the repeated median regression
       line", Proceedings of the Third Annual ACM-SIAM Symposium on
       Discrete Algorithms, pp. 409-413, 1992.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

>>> x = np.linspace(-5, 5, num=150)
>>> y = x + np.random.normal(size=x.size)
>>> y[11:15] += 10  # add outliers
>>> y[-5:] -= 7

Compute the slope and intercept.  For comparison, also compute the
least-squares fit with `linregress`:

>>> res = stats.siegelslopes(y, x)
>>> lsq_res = stats.linregress(x, y)

Plot the results. The Siegel regression line is shown in red. The green
line shows the least-squares fit for comparison.

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(x, y, 'b.')
>>> ax.plot(x, res[1] + res[0] * x, 'r-')
>>> ax.plot(x, lsq_res[1] + lsq_res[0] * x, 'g-')
>>> plt.show()
================================================================================

sigmaclip:
Firma: (a, low=4.0, high=4.0)

Docstring:
Perform iterative sigma-clipping of array elements.

Starting from the full sample, all elements outside the critical range are
removed, i.e. all elements of the input array `c` that satisfy either of
the following conditions::

    c < mean(c) - std(c)*low
    c > mean(c) + std(c)*high

The iteration continues with the updated sample until no
elements are outside the (updated) range.

Parameters
----------
a : array_like
    Data array, will be raveled if not 1-D.
low : float, optional
    Lower bound factor of sigma clipping. Default is 4.
high : float, optional
    Upper bound factor of sigma clipping. Default is 4.

Returns
-------
clipped : ndarray
    Input array with clipped elements removed.
lower : float
    Lower threshold value use for clipping.
upper : float
    Upper threshold value use for clipping.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import sigmaclip
>>> a = np.concatenate((np.linspace(9.5, 10.5, 31),
...                     np.linspace(0, 20, 5)))
>>> fact = 1.5
>>> c, low, upp = sigmaclip(a, fact, fact)
>>> c
array([  9.96666667,  10.        ,  10.03333333,  10.        ])
>>> c.var(), c.std()
(0.00055555555555555165, 0.023570226039551501)
>>> low, c.mean() - fact*c.std(), c.min()
(9.9646446609406727, 9.9646446609406727, 9.9666666666666668)
>>> upp, c.mean() + fact*c.std(), c.max()
(10.035355339059327, 10.035355339059327, 10.033333333333333)

>>> a = np.concatenate((np.linspace(9.5, 10.5, 11),
...                     np.linspace(-100, -50, 3)))
>>> c, low, upp = sigmaclip(a, 1.8, 1.8)
>>> (c == np.linspace(9.5, 10.5, 11)).all()
True
================================================================================

skellam:
Firma: (*args, **kwds)

Docstring:
A  Skellam discrete random variable.

As an instance of the `rv_discrete` class, `skellam` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(mu1, mu2, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, mu1, mu2, loc=0)
    Probability mass function.
logpmf(k, mu1, mu2, loc=0)
    Log of the probability mass function.
cdf(k, mu1, mu2, loc=0)
    Cumulative distribution function.
logcdf(k, mu1, mu2, loc=0)
    Log of the cumulative distribution function.
sf(k, mu1, mu2, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, mu1, mu2, loc=0)
    Log of the survival function.
ppf(q, mu1, mu2, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, mu1, mu2, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(mu1, mu2, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(mu1, mu2, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(mu1, mu2), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(mu1, mu2, loc=0)
    Median of the distribution.
mean(mu1, mu2, loc=0)
    Mean of the distribution.
var(mu1, mu2, loc=0)
    Variance of the distribution.
std(mu1, mu2, loc=0)
    Standard deviation of the distribution.
interval(confidence, mu1, mu2, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----
Probability distribution of the difference of two correlated or
uncorrelated Poisson random variables.

Let :math:`k_1` and :math:`k_2` be two Poisson-distributed r.v. with
expected values :math:`\lambda_1` and :math:`\lambda_2`. Then,
:math:`k_1 - k_2` follows a Skellam distribution with parameters
:math:`\mu_1 = \lambda_1 - \rho \sqrt{\lambda_1 \lambda_2}` and
:math:`\mu_2 = \lambda_2 - \rho \sqrt{\lambda_1 \lambda_2}`, where
:math:`\rho` is the correlation coefficient between :math:`k_1` and
:math:`k_2`. If the two Poisson-distributed r.v. are independent then
:math:`\rho = 0`.

Parameters :math:`\mu_1` and :math:`\mu_2` must be strictly positive.

For details see: https://en.wikipedia.org/wiki/Skellam_distribution

`skellam` takes :math:`\mu_1` and :math:`\mu_2` as shape parameters.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``skellam.pmf(k, mu1, mu2, loc)`` is identically
equivalent to ``skellam.pmf(k - loc, mu1, mu2)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import skellam
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> mu1, mu2 = 15, 8
>>> mean, var, skew, kurt = skellam.stats(mu1, mu2, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(skellam.ppf(0.01, mu1, mu2),
...               skellam.ppf(0.99, mu1, mu2))
>>> ax.plot(x, skellam.pmf(x, mu1, mu2), 'bo', ms=8, label='skellam pmf')
>>> ax.vlines(x, 0, skellam.pmf(x, mu1, mu2), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = skellam(mu1, mu2)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = skellam.cdf(x, mu1, mu2)
>>> np.allclose(x, skellam.ppf(prob, mu1, mu2))
True

Generate random numbers:

>>> r = skellam.rvs(mu1, mu2, size=1000)
================================================================================

skew:
Firma: (a, axis=0, bias=True, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the sample skewness of a data set.

For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function `skewtest` can be used to determine if the skewness value
is close enough to zero, statistically speaking.

Parameters
----------
a : ndarray
    Input array.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
skewness : ndarray
    The skewness of values along an axis, returning NaN where all values
    are equal.

Notes
-----
The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.

.. math::

    g_1=\frac{m_3}{m_2^{3/2}}

where

.. math::

    m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i

is the biased sample :math:`i\texttt{th}` central moment, and
:math:`\bar{x}` is
the sample mean.  If ``bias`` is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.

.. math::

    G_1=\frac{k_3}{k_2^{3/2}}=
        \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.
   Section 2.2.24.1

Examples
--------
>>> from scipy.stats import skew
>>> skew([1, 2, 3, 4, 5])
0.0
>>> skew([2, 8, 0, 4, 1, 9, 9, 0])
0.2650554122698573
================================================================================

skewcauchy:
Firma: (*args, **kwds)

Docstring:
A skewed Cauchy random variable.

As an instance of the `rv_continuous` class, `skewcauchy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
cauchy : Cauchy distribution

Notes
-----

The probability density function for `skewcauchy` is:

.. math::

    f(x) = \frac{1}{\pi \left(\frac{x^2}{\left(a\, \text{sign}(x) + 1
                                               \right)^2} + 1 \right)}

for a real number :math:`x` and skewness parameter :math:`-1 < a < 1`.

When :math:`a=0`, the distribution reduces to the usual Cauchy
distribution.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``skewcauchy.pdf(x, a, loc, scale)`` is identically
equivalent to ``skewcauchy.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] "Skewed generalized *t* distribution", Wikipedia
   https://en.wikipedia.org/wiki/Skewed_generalized_t_distribution#Skewed_Cauchy_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import skewcauchy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 0.5
>>> mean, var, skew, kurt = skewcauchy.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(skewcauchy.ppf(0.01, a),
...                 skewcauchy.ppf(0.99, a), 100)
>>> ax.plot(x, skewcauchy.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='skewcauchy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = skewcauchy(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = skewcauchy.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], skewcauchy.cdf(vals, a))
True

Generate random numbers:

>>> r = skewcauchy.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

skewnorm:
Firma: (*args, **kwds)

Docstring:
A skew-normal random variable.

As an instance of the `rv_continuous` class, `skewnorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, loc=0, scale=1)
    Probability density function.
logpdf(x, a, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0, scale=1)
    Median of the distribution.
mean(a, loc=0, scale=1)
    Mean of the distribution.
var(a, loc=0, scale=1)
    Variance of the distribution.
std(a, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The pdf is::

    skewnorm.pdf(x, a) = 2 * norm.pdf(x) * norm.cdf(a*x)

`skewnorm` takes a real number :math:`a` as a skewness parameter
When ``a = 0`` the distribution is identical to a normal distribution
(`norm`). `rvs` implements the method of [1]_.

This distribution uses routines from the Boost Math C++ library for
the computation of ``cdf``, ``ppf`` and ``isf`` methods. [2]_

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``skewnorm.pdf(x, a, loc, scale)`` is identically
equivalent to ``skewnorm.pdf(y, a) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] A. Azzalini and A. Capitanio (1999). Statistical applications of
    the multivariate skew-normal distribution. J. Roy. Statist. Soc.,
    B 61, 579-602. :arxiv:`0911.2093`
.. [2] The Boost Developers. "Boost C++ Libraries". https://www.boost.org/.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import skewnorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 4
>>> mean, var, skew, kurt = skewnorm.stats(a, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(skewnorm.ppf(0.01, a),
...                 skewnorm.ppf(0.99, a), 100)
>>> ax.plot(x, skewnorm.pdf(x, a),
...        'r-', lw=5, alpha=0.6, label='skewnorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = skewnorm(a)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = skewnorm.ppf([0.001, 0.5, 0.999], a)
>>> np.allclose([0.001, 0.5, 0.999], skewnorm.cdf(vals, a))
True

Generate random numbers:

>>> r = skewnorm.rvs(a, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

skewtest:
Firma: (a, axis=0, nan_policy='propagate', alternative='two-sided', *, keepdims=False)

Docstring:
Test whether the skew is different from the normal distribution.

This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.

Parameters
----------
a : array
    The data to be tested. Must contain at least eight observations.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:
    
    * 'two-sided': the skewness of the distribution underlying the sample
      is different from that of the normal distribution (i.e. 0)
    * 'less': the skewness of the distribution underlying the sample
      is less than that of the normal distribution
    * 'greater': the skewness of the distribution underlying the sample
      is greater than that of the normal distribution
    
    .. versionadded:: 1.7.0
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The p-value for the hypothesis test.

See Also
--------

:ref:`hypothesis_skewtest`
    Extended example


Notes
-----
The sample size must be at least 8.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] R. B. D'Agostino, A. J. Belanger and R. B. D'Agostino Jr.,
        "A suggestion for using powerful and informative tests of
        normality", American Statistician 44, pp. 316-321, 1990.

Examples
--------
>>> from scipy.stats import skewtest
>>> skewtest([1, 2, 3, 4, 5, 6, 7, 8])
SkewtestResult(statistic=1.0108048609177787, pvalue=0.3121098361421897)
>>> skewtest([2, 8, 0, 4, 1, 9, 9, 0])
SkewtestResult(statistic=0.44626385374196975, pvalue=0.6554066631275459)
>>> skewtest([1, 2, 3, 4, 5, 6, 7, 8000])
SkewtestResult(statistic=3.571773510360407, pvalue=0.0003545719905823133)
>>> skewtest([100, 100, 100, 100, 100, 100, 100, 101])
SkewtestResult(statistic=3.5717766638478072, pvalue=0.000354567720281634)
>>> skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative='less')
SkewtestResult(statistic=1.0108048609177787, pvalue=0.8439450819289052)
>>> skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative='greater')
SkewtestResult(statistic=1.0108048609177787, pvalue=0.15605491807109484)

For a more detailed example, see :ref:`hypothesis_skewtest`.
================================================================================

sobol_indices:
Firma: (*, func, n, dists=None, method='saltelli_2010', rng=None)

Docstring:
Global sensitivity indices of Sobol'.

Parameters
----------
func : callable or dict(str, array_like)
    If `func` is a callable, function to compute the Sobol' indices from.
    Its signature must be::

        func(x: ArrayLike) -> ArrayLike

    with ``x`` of shape ``(d, n)`` and output of shape ``(s, n)`` where:

    - ``d`` is the input dimensionality of `func`
      (number of input variables),
    - ``s`` is the output dimensionality of `func`
      (number of output variables), and
    - ``n`` is the number of samples (see `n` below).

    Function evaluation values must be finite.

    If `func` is a dictionary, contains the function evaluations from three
    different arrays. Keys must be: ``f_A``, ``f_B`` and ``f_AB``.
    ``f_A`` and ``f_B`` should have a shape ``(s, n)`` and ``f_AB``
    should have a shape ``(d, s, n)``.
    This is an advanced feature and misuse can lead to wrong analysis.
n : int
    Number of samples used to generate the matrices ``A`` and ``B``.
    Must be a power of 2. The total number of points at which `func` is
    evaluated will be ``n*(d+2)``.
dists : list(distributions), optional
    List of each parameter's distribution. The distribution of parameters
    depends on the application and should be carefully chosen.
    Parameters are assumed to be independently distributed, meaning there
    is no constraint nor relationship between their values.

    Distributions must be an instance of a class with a ``ppf``
    method.

    Must be specified if `func` is a callable, and ignored otherwise.
method : Callable or str, default: 'saltelli_2010'
    Method used to compute the first and total Sobol' indices.

    If a callable, its signature must be::

        func(f_A: np.ndarray, f_B: np.ndarray, f_AB: np.ndarray)
        -> Tuple[np.ndarray, np.ndarray]

    with ``f_A, f_B`` of shape ``(s, n)`` and ``f_AB`` of shape
    ``(d, s, n)``.
    These arrays contain the function evaluations from three different sets
    of samples.
    The output is a tuple of the first and total indices with
    shape ``(s, d)``.
    This is an advanced feature and misuse can lead to wrong analysis.
rng : `numpy.random.Generator`, optional
    Pseudorandom number generator state. When `rng` is None, a new
    `numpy.random.Generator` is created using entropy from the
    operating system. Types other than `numpy.random.Generator` are
    passed to `numpy.random.default_rng` to instantiate a ``Generator``.

    .. versionchanged:: 1.15.0

        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_
        transition from use of `numpy.random.RandomState` to
        `numpy.random.Generator`, this keyword was changed from `random_state` to
        `rng`. For an interim period, both keywords will continue to work, although
        only one may be specified at a time. After the interim period, function
        calls using the `random_state` keyword will emit warnings. Following a
        deprecation period, the `random_state` keyword will be removed.

Returns
-------
res : SobolResult
    An object with attributes:

    first_order : ndarray of shape (s, d)
        First order Sobol' indices.
    total_order : ndarray of shape (s, d)
        Total order Sobol' indices.

    And method:

    bootstrap(confidence_level: float, n_resamples: int)
    -> BootstrapSobolResult

        A method providing confidence intervals on the indices.
        See `scipy.stats.bootstrap` for more details.

        The bootstrapping is done on both first and total order indices,
        and they are available in `BootstrapSobolResult` as attributes
        ``first_order`` and ``total_order``.

Notes
-----
The Sobol' method [1]_, [2]_ is a variance-based Sensitivity Analysis which
obtains the contribution of each parameter to the variance of the
quantities of interest (QoIs; i.e., the outputs of `func`).
Respective contributions can be used to rank the parameters and
also gauge the complexity of the model by computing the
model's effective (or mean) dimension.

.. note::

    Parameters are assumed to be independently distributed. Each
    parameter can still follow any distribution. In fact, the distribution
    is very important and should match the real distribution of the
    parameters.

It uses a functional decomposition of the variance of the function to
explore

.. math::

    \mathbb{V}(Y) = \sum_{i}^{d} \mathbb{V}_i (Y) + \sum_{i<j}^{d}
    \mathbb{V}_{ij}(Y) + ... + \mathbb{V}_{1,2,...,d}(Y),

introducing conditional variances:

.. math::

    \mathbb{V}_i(Y) = \mathbb{\mathbb{V}}[\mathbb{E}(Y|x_i)]
    \qquad
    \mathbb{V}_{ij}(Y) = \mathbb{\mathbb{V}}[\mathbb{E}(Y|x_i x_j)]
    - \mathbb{V}_i(Y) - \mathbb{V}_j(Y),

Sobol' indices are expressed as

.. math::

    S_i = \frac{\mathbb{V}_i(Y)}{\mathbb{V}[Y]}
    \qquad
    S_{ij} =\frac{\mathbb{V}_{ij}(Y)}{\mathbb{V}[Y]}.

:math:`S_{i}` corresponds to the first-order term which apprises the
contribution of the i-th parameter, while :math:`S_{ij}` corresponds to the
second-order term which informs about the contribution of interactions
between the i-th and the j-th parameters. These equations can be
generalized to compute higher order terms; however, they are expensive to
compute and their interpretation is complex.
This is why only first order indices are provided.

Total order indices represent the global contribution of the parameters
to the variance of the QoI and are defined as:

.. math::

    S_{T_i} = S_i + \sum_j S_{ij} + \sum_{j,k} S_{ijk} + ...
    = 1 - \frac{\mathbb{V}[\mathbb{E}(Y|x_{\sim i})]}{\mathbb{V}[Y]}.

First order indices sum to at most 1, while total order indices sum to at
least 1. If there are no interactions, then first and total order indices
are equal, and both first and total order indices sum to 1.

.. warning::

    Negative Sobol' values are due to numerical errors. Increasing the
    number of points `n` should help.

    The number of sample required to have a good analysis increases with
    the dimensionality of the problem. e.g. for a 3 dimension problem,
    consider at minima ``n >= 2**12``. The more complex the model is,
    the more samples will be needed.

    Even for a purely additive model, the indices may not sum to 1 due
    to numerical noise.

References
----------
.. [1] Sobol, I. M.. "Sensitivity analysis for nonlinear mathematical
   models." Mathematical Modeling and Computational Experiment, 1:407-414,
   1993.
.. [2] Sobol, I. M. (2001). "Global sensitivity indices for nonlinear
   mathematical models and their Monte Carlo estimates." Mathematics
   and Computers in Simulation, 55(1-3):271-280,
   :doi:`10.1016/S0378-4754(00)00270-6`, 2001.
.. [3] Saltelli, A. "Making best use of model evaluations to
   compute sensitivity indices."  Computer Physics Communications,
   145(2):280-297, :doi:`10.1016/S0010-4655(02)00280-1`, 2002.
.. [4] Saltelli, A., M. Ratto, T. Andres, F. Campolongo, J. Cariboni,
   D. Gatelli, M. Saisana, and S. Tarantola. "Global Sensitivity Analysis.
   The Primer." 2007.
.. [5] Saltelli, A., P. Annoni, I. Azzini, F. Campolongo, M. Ratto, and
   S. Tarantola. "Variance based sensitivity analysis of model
   output. Design and estimator for the total sensitivity index."
   Computer Physics Communications, 181(2):259-270,
   :doi:`10.1016/j.cpc.2009.09.018`, 2010.
.. [6] Ishigami, T. and T. Homma. "An importance quantification technique
   in uncertainty analysis for computer models." IEEE,
   :doi:`10.1109/ISUMA.1990.151285`, 1990.

Examples
--------
The following is an example with the Ishigami function [6]_

.. math::

    Y(\mathbf{x}) = \sin x_1 + 7 \sin^2 x_2 + 0.1 x_3^4 \sin x_1,

with :math:`\mathbf{x} \in [-\pi, \pi]^3`. This function exhibits strong
non-linearity and non-monotonicity.

Remember, Sobol' indices assumes that samples are independently
distributed. In this case we use a uniform distribution on each marginals.

>>> import numpy as np
>>> from scipy.stats import sobol_indices, uniform
>>> rng = np.random.default_rng()
>>> def f_ishigami(x):
...     f_eval = (
...         np.sin(x[0])
...         + 7 * np.sin(x[1])**2
...         + 0.1 * (x[2]**4) * np.sin(x[0])
...     )
...     return f_eval
>>> indices = sobol_indices(
...     func=f_ishigami, n=1024,
...     dists=[
...         uniform(loc=-np.pi, scale=2*np.pi),
...         uniform(loc=-np.pi, scale=2*np.pi),
...         uniform(loc=-np.pi, scale=2*np.pi)
...     ],
...     rng=rng
... )
>>> indices.first_order
array([0.31637954, 0.43781162, 0.00318825])
>>> indices.total_order
array([0.56122127, 0.44287857, 0.24229595])

Confidence interval can be obtained using bootstrapping.

>>> boot = indices.bootstrap()

Then, this information can be easily visualized.

>>> import matplotlib.pyplot as plt
>>> fig, axs = plt.subplots(1, 2, figsize=(9, 4))
>>> _ = axs[0].errorbar(
...     [1, 2, 3], indices.first_order, fmt='o',
...     yerr=[
...         indices.first_order - boot.first_order.confidence_interval.low,
...         boot.first_order.confidence_interval.high - indices.first_order
...     ],
... )
>>> axs[0].set_ylabel("First order Sobol' indices")
>>> axs[0].set_xlabel('Input parameters')
>>> axs[0].set_xticks([1, 2, 3])
>>> _ = axs[1].errorbar(
...     [1, 2, 3], indices.total_order, fmt='o',
...     yerr=[
...         indices.total_order - boot.total_order.confidence_interval.low,
...         boot.total_order.confidence_interval.high - indices.total_order
...     ],
... )
>>> axs[1].set_ylabel("Total order Sobol' indices")
>>> axs[1].set_xlabel('Input parameters')
>>> axs[1].set_xticks([1, 2, 3])
>>> plt.tight_layout()
>>> plt.show()

.. note::

    By default, `scipy.stats.uniform` has support ``[0, 1]``.
    Using the parameters ``loc`` and ``scale``, one obtains the uniform
    distribution on ``[loc, loc + scale]``.

This result is particularly interesting because the first order index
:math:`S_{x_3} = 0` whereas its total order is :math:`S_{T_{x_3}} = 0.244`.
This means that higher order interactions with :math:`x_3` are responsible
for the difference. Almost 25% of the observed variance
on the QoI is due to the correlations between :math:`x_3` and :math:`x_1`,
although :math:`x_3` by itself has no impact on the QoI.

The following gives a visual explanation of Sobol' indices on this
function. Let's generate 1024 samples in :math:`[-\pi, \pi]^3` and
calculate the value of the output.

>>> from scipy.stats import qmc
>>> n_dim = 3
>>> p_labels = ['$x_1$', '$x_2$', '$x_3$']
>>> sample = qmc.Sobol(d=n_dim, seed=rng).random(1024)
>>> sample = qmc.scale(
...     sample=sample,
...     l_bounds=[-np.pi, -np.pi, -np.pi],
...     u_bounds=[np.pi, np.pi, np.pi]
... )
>>> output = f_ishigami(sample.T)

Now we can do scatter plots of the output with respect to each parameter.
This gives a visual way to understand how each parameter impacts the
output of the function.

>>> fig, ax = plt.subplots(1, n_dim, figsize=(12, 4))
>>> for i in range(n_dim):
...     xi = sample[:, i]
...     ax[i].scatter(xi, output, marker='+')
...     ax[i].set_xlabel(p_labels[i])
>>> ax[0].set_ylabel('Y')
>>> plt.tight_layout()
>>> plt.show()

Now Sobol' goes a step further:
by conditioning the output value by given values of the parameter
(black lines), the conditional output mean is computed. It corresponds to
the term :math:`\mathbb{E}(Y|x_i)`. Taking the variance of this term gives
the numerator of the Sobol' indices.

>>> mini = np.min(output)
>>> maxi = np.max(output)
>>> n_bins = 10
>>> bins = np.linspace(-np.pi, np.pi, num=n_bins, endpoint=False)
>>> dx = bins[1] - bins[0]
>>> fig, ax = plt.subplots(1, n_dim, figsize=(12, 4))
>>> for i in range(n_dim):
...     xi = sample[:, i]
...     ax[i].scatter(xi, output, marker='+')
...     ax[i].set_xlabel(p_labels[i])
...     for bin_ in bins:
...         idx = np.where((bin_ <= xi) & (xi <= bin_ + dx))
...         xi_ = xi[idx]
...         y_ = output[idx]
...         ave_y_ = np.mean(y_)
...         ax[i].plot([bin_ + dx/2] * 2, [mini, maxi], c='k')
...         ax[i].scatter(bin_ + dx/2, ave_y_, c='r')
>>> ax[0].set_ylabel('Y')
>>> plt.tight_layout()
>>> plt.show()

Looking at :math:`x_3`, the variance
of the mean is zero leading to :math:`S_{x_3} = 0`. But we can further
observe that the variance of the output is not constant along the parameter
values of :math:`x_3`. This heteroscedasticity is explained by higher order
interactions. Moreover, an heteroscedasticity is also noticeable on
:math:`x_1` leading to an interaction between :math:`x_3` and :math:`x_1`.
On :math:`x_2`, the variance seems to be constant and thus null interaction
with this parameter can be supposed.

This case is fairly simple to analyse visually---although it is only a
qualitative analysis. Nevertheless, when the number of input parameters
increases such analysis becomes unrealistic as it would be difficult to
conclude on high-order terms. Hence the benefit of using Sobol' indices.
================================================================================

somersd:
Firma: (x, y=None, alternative='two-sided')

Docstring:
Calculates Somers' D, an asymmetric measure of ordinal association.

Like Kendall's :math:`\tau`, Somers' :math:`D` is a measure of the
correspondence between two rankings. Both statistics consider the
difference between the number of concordant and discordant pairs in two
rankings :math:`X` and :math:`Y`, and both are normalized such that values
close  to 1 indicate strong agreement and values close to -1 indicate
strong disagreement. They differ in how they are normalized. To show the
relationship, Somers' :math:`D` can be defined in terms of Kendall's
:math:`\tau_a`:

.. math::
    D(Y|X) = \frac{\tau_a(X, Y)}{\tau_a(X, X)}

Suppose the first ranking :math:`X` has :math:`r` distinct ranks and the
second ranking :math:`Y` has :math:`s` distinct ranks. These two lists of
:math:`n` rankings can also be viewed as an :math:`r \times s` contingency
table in which element :math:`i, j` is the number of rank pairs with rank
:math:`i` in ranking :math:`X` and rank :math:`j` in ranking :math:`Y`.
Accordingly, `somersd` also allows the input data to be supplied as a
single, 2D contingency table instead of as two separate, 1D rankings.

Note that the definition of Somers' :math:`D` is asymmetric: in general,
:math:`D(Y|X) \neq D(X|Y)`. ``somersd(x, y)`` calculates Somers'
:math:`D(Y|X)`: the "row" variable :math:`X` is treated as an independent
variable, and the "column" variable :math:`Y` is dependent. For Somers'
:math:`D(X|Y)`, swap the input lists or transpose the input table.

Parameters
----------
x : array_like
    1D array of rankings, treated as the (row) independent variable.
    Alternatively, a 2D contingency table.
y : array_like, optional
    If `x` is a 1D array of rankings, `y` is a 1D array of rankings of the
    same length, treated as the (column) dependent variable.
    If `x` is 2D, `y` is ignored.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:
    * 'two-sided': the rank correlation is nonzero
    * 'less': the rank correlation is negative (less than zero)
    * 'greater':  the rank correlation is positive (greater than zero)

Returns
-------
res : SomersDResult
    A `SomersDResult` object with the following fields:

        statistic : float
           The Somers' :math:`D` statistic.
        pvalue : float
           The p-value for a hypothesis test whose null
           hypothesis is an absence of association, :math:`D=0`.
           See notes for more information.
        table : 2D array
           The contingency table formed from rankings `x` and `y` (or the
           provided contingency table, if `x` is a 2D array)

See Also
--------
kendalltau : Calculates Kendall's tau, another correlation measure.
weightedtau : Computes a weighted version of Kendall's tau.
spearmanr : Calculates a Spearman rank-order correlation coefficient.
pearsonr : Calculates a Pearson correlation coefficient.

Notes
-----
This function follows the contingency table approach of [2]_ and
[3]_. *p*-values are computed based on an asymptotic approximation of
the test statistic distribution under the null hypothesis :math:`D=0`.

Theoretically, hypothesis tests based on Kendall's :math:`tau` and Somers'
:math:`D` should be identical.
However, the *p*-values returned by `kendalltau` are based
on the null hypothesis of *independence* between :math:`X` and :math:`Y`
(i.e. the population from which pairs in :math:`X` and :math:`Y` are
sampled contains equal numbers of all possible pairs), which is more
specific than the null hypothesis :math:`D=0` used here. If the null
hypothesis of independence is desired, it is acceptable to use the
*p*-value returned by `kendalltau` with the statistic returned by
`somersd` and vice versa. For more information, see [2]_.

Contingency tables are formatted according to the convention used by
SAS and R: the first ranking supplied (``x``) is the "row" variable, and
the second ranking supplied (``y``) is the "column" variable. This is
opposite the convention of Somers' original paper [1]_.

References
----------
.. [1] Robert H. Somers, "A New Asymmetric Measure of Association for
       Ordinal Variables", *American Sociological Review*, Vol. 27, No. 6,
       pp. 799--811, 1962.

.. [2] Morton B. Brown and Jacqueline K. Benedetti, "Sampling Behavior of
       Tests for Correlation in Two-Way Contingency Tables", *Journal of
       the American Statistical Association* Vol. 72, No. 358, pp.
       309--315, 1977.

.. [3] SAS Institute, Inc., "The FREQ Procedure (Book Excerpt)",
       *SAS/STAT 9.2 User's Guide, Second Edition*, SAS Publishing, 2009.

.. [4] Laerd Statistics, "Somers' d using SPSS Statistics", *SPSS
       Statistics Tutorials and Statistical Guides*,
       https://statistics.laerd.com/spss-tutorials/somers-d-using-spss-statistics.php,
       Accessed July 31, 2020.

Examples
--------
We calculate Somers' D for the example given in [4]_, in which a hotel
chain owner seeks to determine the association between hotel room
cleanliness and customer satisfaction. The independent variable, hotel
room cleanliness, is ranked on an ordinal scale: "below average (1)",
"average (2)", or "above average (3)". The dependent variable, customer
satisfaction, is ranked on a second scale: "very dissatisfied (1)",
"moderately dissatisfied (2)", "neither dissatisfied nor satisfied (3)",
"moderately satisfied (4)", or "very satisfied (5)". 189 customers
respond to the survey, and the results are cast into a contingency table
with the hotel room cleanliness as the "row" variable and customer
satisfaction as the "column" variable.

+-----+-----+-----+-----+-----+-----+
|     | (1) | (2) | (3) | (4) | (5) |
+=====+=====+=====+=====+=====+=====+
| (1) | 27  | 25  | 14  | 7   | 0   |
+-----+-----+-----+-----+-----+-----+
| (2) | 7   | 14  | 18  | 35  | 12  |
+-----+-----+-----+-----+-----+-----+
| (3) | 1   | 3   | 2   | 7   | 17  |
+-----+-----+-----+-----+-----+-----+

For example, 27 customers assigned their room a cleanliness ranking of
"below average (1)" and a corresponding satisfaction of "very
dissatisfied (1)". We perform the analysis as follows.

>>> from scipy.stats import somersd
>>> table = [[27, 25, 14, 7, 0], [7, 14, 18, 35, 12], [1, 3, 2, 7, 17]]
>>> res = somersd(table)
>>> res.statistic
0.6032766111513396
>>> res.pvalue
1.0007091191074533e-27

The value of the Somers' D statistic is approximately 0.6, indicating
a positive correlation between room cleanliness and customer satisfaction
in the sample.
The *p*-value is very small, indicating a very small probability of
observing such an extreme value of the statistic under the null
hypothesis that the statistic of the entire population (from which
our sample of 189 customers is drawn) is zero. This supports the
alternative hypothesis that the true value of Somers' D for the population
is nonzero.
================================================================================

spearmanr:
Firma: (a, b=None, axis=0, nan_policy='propagate', alternative='two-sided')

Docstring:
Calculate a Spearman correlation coefficient with associated p-value.

The Spearman rank-order correlation coefficient is a nonparametric measure
of the monotonicity of the relationship between two datasets.
Like other correlation coefficients,
this one varies between -1 and +1 with 0 implying no correlation.
Correlations of -1 or +1 imply an exact monotonic relationship. Positive
correlations imply that as x increases, so does y. Negative correlations
imply that as x increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Spearman correlation at least as extreme
as the one computed from these datasets. Although calculation of the
p-value does not make strong assumptions about the distributions underlying
the samples, it is only accurate for very large samples (>500
observations). For smaller sample sizes, consider a permutation test (see
Examples section below).

Parameters
----------
a, b : 1D or 2D array_like, b is optional
    One or two 1-D or 2-D arrays containing multiple variables and
    observations. When these are 1-D, each represents a vector of
    observations of a single variable. For the behavior in the 2-D case,
    see under ``axis``, below.
    Both arrays need to have the same length in the ``axis`` dimension.
axis : int or None, optional
    If axis=0 (default), then each column represents a variable, with
    observations in the rows. If axis=1, the relationship is transposed:
    each row represents a variable, while the columns contain observations.
    If axis=None, then both arrays will be raveled.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the correlation is nonzero
    * 'less': the correlation is negative (less than zero)
    * 'greater':  the correlation is positive (greater than zero)

    .. versionadded:: 1.7.0

Returns
-------
res : SignificanceResult
    An object containing attributes:

    statistic : float or ndarray (2-D square)
        Spearman correlation matrix or correlation coefficient (if only 2
        variables are given as parameters). Correlation matrix is square
        with length equal to total number of variables (columns or rows) in
        ``a`` and ``b`` combined.
    pvalue : float
        The p-value for a hypothesis test whose null hypothesis
        is that two samples have no ordinal correlation. See
        `alternative` above for alternative hypotheses. `pvalue` has the
        same shape as `statistic`.

Raises
------
ValueError
    If `axis` is not 0, 1 or None, or if the number of dimensions of `a`
    is greater than 2, or if `b` is None and the number of dimensions of
    `a` is less than 2.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if an input is a constant array.  The correlation coefficient
    is not defined in this case, so ``np.nan`` is returned.

See Also
--------
:ref:`hypothesis_spearmanr` : Extended example

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.
   Section  14.7
.. [2] Kendall, M. G. and Stuart, A. (1973).
   The Advanced Theory of Statistics, Volume 2: Inference and Relationship.
   Griffin. 1973.
   Section 31.18

Examples
--------

>>> import numpy as np
>>> from scipy import stats
>>> res = stats.spearmanr([1, 2, 3, 4, 5], [5, 6, 7, 8, 7])
>>> res.statistic
0.8207826816681233
>>> res.pvalue
0.08858700531354381

>>> rng = np.random.default_rng()
>>> x2n = rng.standard_normal((100, 2))
>>> y2n = rng.standard_normal((100, 2))
>>> res = stats.spearmanr(x2n)
>>> res.statistic, res.pvalue
(-0.07960396039603959, 0.4311168705769747)

>>> res = stats.spearmanr(x2n[:, 0], x2n[:, 1])
>>> res.statistic, res.pvalue
(-0.07960396039603959, 0.4311168705769747)

>>> res = stats.spearmanr(x2n, y2n)
>>> res.statistic
array([[ 1. , -0.07960396, -0.08314431, 0.09662166],
       [-0.07960396, 1. , -0.14448245, 0.16738074],
       [-0.08314431, -0.14448245, 1. , 0.03234323],
       [ 0.09662166, 0.16738074, 0.03234323, 1. ]])
>>> res.pvalue
array([[0. , 0.43111687, 0.41084066, 0.33891628],
       [0.43111687, 0. , 0.15151618, 0.09600687],
       [0.41084066, 0.15151618, 0. , 0.74938561],
       [0.33891628, 0.09600687, 0.74938561, 0. ]])

>>> res = stats.spearmanr(x2n.T, y2n.T, axis=1)
>>> res.statistic
array([[ 1. , -0.07960396, -0.08314431, 0.09662166],
       [-0.07960396, 1. , -0.14448245, 0.16738074],
       [-0.08314431, -0.14448245, 1. , 0.03234323],
       [ 0.09662166, 0.16738074, 0.03234323, 1. ]])

>>> res = stats.spearmanr(x2n, y2n, axis=None)
>>> res.statistic, res.pvalue
(0.044981624540613524, 0.5270803651336189)

>>> res = stats.spearmanr(x2n.ravel(), y2n.ravel())
>>> res.statistic, res.pvalue
(0.044981624540613524, 0.5270803651336189)

>>> rng = np.random.default_rng()
>>> xint = rng.integers(10, size=(100, 2))
>>> res = stats.spearmanr(xint)
>>> res.statistic, res.pvalue
(0.09800224850707953, 0.3320271757932076)

For small samples, consider performing a permutation test instead of
relying on the asymptotic p-value. Note that to calculate the null
distribution of the statistic (for all possibly pairings between
observations in sample ``x`` and ``y``), only one of the two inputs needs
to be permuted.

>>> x = [1.76405235, 0.40015721, 0.97873798,
... 2.2408932, 1.86755799, -0.97727788]
>>> y = [2.71414076, 0.2488, 0.87551913,
... 2.6514917, 2.01160156, 0.47699563]

>>> def statistic(x): # permute only `x`
...     return stats.spearmanr(x, y).statistic
>>> res_exact = stats.permutation_test((x,), statistic,
...     permutation_type='pairings')
>>> res_asymptotic = stats.spearmanr(x, y)
>>> res_exact.pvalue, res_asymptotic.pvalue # asymptotic pvalue is too low
(0.10277777777777777, 0.07239650145772594)

For a more detailed example, see :ref:`hypothesis_spearmanr`.
================================================================================

special_ortho_group:
Firma: (dim=None, seed=None)

Docstring:
A Special Orthogonal matrix (SO(N)) random variable.

Return a random rotation matrix, drawn from the Haar distribution
(the only uniform distribution on SO(N)) with a determinant of +1.

The `dim` keyword specifies the dimension N.

Methods
-------
rvs(dim=None, size=1, random_state=None)
    Draw random samples from SO(N).

Parameters
----------
dim : scalar
    Dimension of matrices
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
This class is wrapping the random_rot code from the MDP Toolkit,
https://github.com/mdp-toolkit/mdp-toolkit

Return a random rotation matrix, drawn from the Haar distribution
(the only uniform distribution on SO(N)).
The algorithm is described in the paper
Stewart, G.W., "The efficient generation of random orthogonal
matrices with an application to condition estimators", SIAM Journal
on Numerical Analysis, 17(3), pp. 403-409, 1980.
For more information see
https://en.wikipedia.org/wiki/Orthogonal_matrix#Randomization

See also the similar `ortho_group`. For a random rotation in three
dimensions, see `scipy.spatial.transform.Rotation.random`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import special_ortho_group
>>> x = special_ortho_group.rvs(3)

>>> np.dot(x, x.T)
array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],
       [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],
       [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])

>>> import scipy.linalg
>>> scipy.linalg.det(x)
1.0

This generates one random matrix from SO(3). It is orthogonal and
has a determinant of 1.

Alternatively, the object may be called (as a function) to fix the `dim`
parameter, returning a "frozen" special_ortho_group random variable:

>>> rv = special_ortho_group(5)
>>> # Frozen object with the same methods but holding the
>>> # dimension parameter fixed.

See Also
--------
ortho_group, scipy.spatial.transform.Rotation.random
================================================================================

studentized_range:
Firma: (*args, **kwds)

Docstring:
A studentized range continuous random variable.

As an instance of the `rv_continuous` class, `studentized_range` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(k, df, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, k, df, loc=0, scale=1)
    Probability density function.
logpdf(x, k, df, loc=0, scale=1)
    Log of the probability density function.
cdf(x, k, df, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, k, df, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, k, df, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, k, df, loc=0, scale=1)
    Log of the survival function.
ppf(q, k, df, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, k, df, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, k, df, loc=0, scale=1)
    Non-central moment of the specified order.
stats(k, df, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(k, df, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(k, df), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(k, df, loc=0, scale=1)
    Median of the distribution.
mean(k, df, loc=0, scale=1)
    Mean of the distribution.
var(k, df, loc=0, scale=1)
    Variance of the distribution.
std(k, df, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, k, df, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
t: Student's t distribution

Notes
-----
The probability density function for `studentized_range` is:

.. math::

     f(x; k, \nu) = \frac{k(k-1)\nu^{\nu/2}}{\Gamma(\nu/2)
                    2^{\nu/2-1}} \int_{0}^{\infty} \int_{-\infty}^{\infty}
                    s^{\nu} e^{-\nu s^2/2} \phi(z) \phi(sx + z)
                    [\Phi(sx + z) - \Phi(z)]^{k-2} \,dz \,ds

for :math:`x ≥ 0`, :math:`k > 1`, and :math:`\nu > 0`.

`studentized_range` takes ``k`` for :math:`k` and ``df`` for :math:`\nu`
as shape parameters.

When :math:`\nu` exceeds 100,000, an asymptotic approximation (infinite
degrees of freedom) is used to compute the cumulative distribution
function [4]_ and probability distribution function.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``studentized_range.pdf(x, k, df, loc, scale)`` is identically
equivalent to ``studentized_range.pdf(y, k, df) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------

.. [1] "Studentized range distribution",
       https://en.wikipedia.org/wiki/Studentized_range_distribution
.. [2] Batista, Ben Dêivide, et al. "Externally Studentized Normal Midrange
       Distribution." Ciência e Agrotecnologia, vol. 41, no. 4, 2017, pp.
       378-389., doi:10.1590/1413-70542017414047716.
.. [3] Harter, H. Leon. "Tables of Range and Studentized Range." The Annals
       of Mathematical Statistics, vol. 31, no. 4, 1960, pp. 1122-1147.
       JSTOR, www.jstor.org/stable/2237810. Accessed 18 Feb. 2021.
.. [4] Lund, R. E., and J. R. Lund. "Algorithm AS 190: Probabilities and
       Upper Quantiles for the Studentized Range." Journal of the Royal
       Statistical Society. Series C (Applied Statistics), vol. 32, no. 2,
       1983, pp. 204-210. JSTOR, www.jstor.org/stable/2347300. Accessed 18
       Feb. 2021.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import studentized_range
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Display the probability density function (``pdf``):

>>> k, df = 3, 10
>>> x = np.linspace(studentized_range.ppf(0.01, k, df),
...                 studentized_range.ppf(0.99, k, df), 100)
>>> ax.plot(x, studentized_range.pdf(x, k, df),
...         'r-', lw=5, alpha=0.6, label='studentized_range pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = studentized_range(k, df)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = studentized_range.ppf([0.001, 0.5, 0.999], k, df)
>>> np.allclose([0.001, 0.5, 0.999], studentized_range.cdf(vals, k, df))
True

Rather than using (``studentized_range.rvs``) to generate random variates,
which is very slow for this distribution, we can approximate the inverse
CDF using an interpolator, and then perform inverse transform sampling
with this approximate inverse CDF.

This distribution has an infinite but thin right tail, so we focus our
attention on the leftmost 99.9 percent.

>>> a, b = studentized_range.ppf([0, .999], k, df)
>>> a, b
0, 7.41058083802274

>>> from scipy.interpolate import interp1d
>>> rng = np.random.default_rng()
>>> xs = np.linspace(a, b, 50)
>>> cdf = studentized_range.cdf(xs, k, df)
# Create an interpolant of the inverse CDF
>>> ppf = interp1d(cdf, xs, fill_value='extrapolate')
# Perform inverse transform sampling using the interpolant
>>> r = ppf(rng.uniform(size=1000))

And compare the histogram:

>>> ax.hist(r, density=True, histtype='stepfilled', alpha=0.2)
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

t:
Firma: (*args, **kwds)

Docstring:
A Student's t continuous random variable.

For the noncentral t distribution, see `nct`.

As an instance of the `rv_continuous` class, `t` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(df, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, df, loc=0, scale=1)
    Probability density function.
logpdf(x, df, loc=0, scale=1)
    Log of the probability density function.
cdf(x, df, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, df, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, df, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, df, loc=0, scale=1)
    Log of the survival function.
ppf(q, df, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, df, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, df, loc=0, scale=1)
    Non-central moment of the specified order.
stats(df, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(df, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(df,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(df, loc=0, scale=1)
    Median of the distribution.
mean(df, loc=0, scale=1)
    Mean of the distribution.
var(df, loc=0, scale=1)
    Variance of the distribution.
std(df, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, df, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
nct

Notes
-----
The probability density function for `t` is:

.. math::

    f(x, \nu) = \frac{\Gamma((\nu+1)/2)}
                    {\sqrt{\pi \nu} \Gamma(\nu/2)}
                (1+x^2/\nu)^{-(\nu+1)/2}

where :math:`x` is a real number and the degrees of freedom parameter
:math:`\nu` (denoted ``df`` in the implementation) satisfies
:math:`\nu > 0`. :math:`\Gamma` is the gamma function
(`scipy.special.gamma`).

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``t.pdf(x, df, loc, scale)`` is identically
equivalent to ``t.pdf(y, df) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import t
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> df = 2.74
>>> mean, var, skew, kurt = t.stats(df, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(t.ppf(0.01, df),
...                 t.ppf(0.99, df), 100)
>>> ax.plot(x, t.pdf(x, df),
...        'r-', lw=5, alpha=0.6, label='t pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = t(df)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = t.ppf([0.001, 0.5, 0.999], df)
>>> np.allclose([0.001, 0.5, 0.999], t.cdf(vals, df))
True

Generate random numbers:

>>> r = t.rvs(df, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

test:
Firma: (label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, tests=None, parallel=None)

Docstring:
Run tests for this namespace

``scipy.test()`` runs tests for all of SciPy, with the default settings.
When used from a submodule (e.g., ``scipy.cluster.test()``, only the tests
for that namespace are run.

Parameters
----------
label : {'fast', 'full'}, optional
    Whether to run only the fast tests, or also those marked as slow.
    Default is 'fast'.
verbose : int, optional
    Test output verbosity. Default is 1.
extra_argv : list, optional
    Arguments to pass through to Pytest.
doctests : bool, optional
    Whether to run doctests or not. Default is False.
coverage : bool, optional
    Whether to run tests with code coverage measurements enabled.
    Default is False.
tests : list of str, optional
    List of module names to run tests for. By default, uses the module
    from which the ``test`` function is called.
parallel : int, optional
    Run tests in parallel with pytest-xdist, if number given is larger than
    1. Default is 1.
================================================================================

theilslopes:
Firma: (y, x=None, alpha=0.95, method='separate')

Docstring:
Computes the Theil-Sen estimator for a set of points (x, y).

`theilslopes` implements a method for robust linear regression.  It
computes the slope as the median of all slopes between paired values.

Parameters
----------
y : array_like
    Dependent variable.
x : array_like or None, optional
    Independent variable. If None, use ``arange(len(y))`` instead.
alpha : float, optional
    Confidence degree between 0 and 1. Default is 95% confidence.
    Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
    interpreted as "find the 90% confidence interval".
method : {'joint', 'separate'}, optional
    Method to be used for computing estimate for intercept.
    Following methods are supported,

        * 'joint': Uses np.median(y - slope * x) as intercept.
        * 'separate': Uses np.median(y) - slope * np.median(x)
                      as intercept.

    The default is 'separate'.

    .. versionadded:: 1.8.0

Returns
-------
result : ``TheilslopesResult`` instance
    The return value is an object with the following attributes:

    slope : float
        Theil slope.
    intercept : float
        Intercept of the Theil line.
    low_slope : float
        Lower bound of the confidence interval on `slope`.
    high_slope : float
        Upper bound of the confidence interval on `slope`.

See Also
--------
siegelslopes : a similar technique using repeated medians

Notes
-----
The implementation of `theilslopes` follows [1]_. The intercept is
not defined in [1]_, and here it is defined as ``median(y) -
slope*median(x)``, which is given in [3]_. Other definitions of
the intercept exist in the literature such as  ``median(y - slope*x)``
in [4]_. The approach to compute the intercept can be determined by the
parameter ``method``. A confidence interval for the intercept is not
given as this question is not addressed in [1]_.

For compatibility with older versions of SciPy, the return value acts
like a ``namedtuple`` of length 4, with fields ``slope``, ``intercept``,
``low_slope``, and ``high_slope``, so one can continue to write::

    slope, intercept, low_slope, high_slope = theilslopes(y, x)

References
----------
.. [1] P.K. Sen, "Estimates of the regression coefficient based on
       Kendall's tau", J. Am. Stat. Assoc., Vol. 63, pp. 1379-1389, 1968.
.. [2] H. Theil, "A rank-invariant method of linear and polynomial
       regression analysis I, II and III",  Nederl. Akad. Wetensch., Proc.
       53:, pp. 386-392, pp. 521-525, pp. 1397-1412, 1950.
.. [3] W.L. Conover, "Practical nonparametric statistics", 2nd ed.,
       John Wiley and Sons, New York, pp. 493.
.. [4] https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

>>> x = np.linspace(-5, 5, num=150)
>>> y = x + np.random.normal(size=x.size)
>>> y[11:15] += 10  # add outliers
>>> y[-5:] -= 7

Compute the slope, intercept and 90% confidence interval.  For comparison,
also compute the least-squares fit with `linregress`:

>>> res = stats.theilslopes(y, x, 0.90, method='separate')
>>> lsq_res = stats.linregress(x, y)

Plot the results. The Theil-Sen regression line is shown in red, with the
dashed red lines illustrating the confidence interval of the slope (note
that the dashed red lines are not the confidence interval of the regression
as the confidence interval of the intercept is not included). The green
line shows the least-squares fit for comparison.

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(x, y, 'b.')
>>> ax.plot(x, res[1] + res[0] * x, 'r-')
>>> ax.plot(x, res[1] + res[2] * x, 'r--')
>>> ax.plot(x, res[1] + res[3] * x, 'r--')
>>> ax.plot(x, lsq_res[1] + lsq_res[0] * x, 'g-')
>>> plt.show()
================================================================================

tiecorrect:
Firma: (rankvals)

Docstring:
Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.

Parameters
----------
rankvals : array_like
    A 1-D sequence of ranks.  Typically this will be the array
    returned by `~scipy.stats.rankdata`.

Returns
-------
factor : float
    Correction factor for U or H.

See Also
--------
rankdata : Assign ranks to the data
mannwhitneyu : Mann-Whitney rank test
kruskal : Kruskal-Wallis H test

References
----------
.. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral
       Sciences.  New York: McGraw-Hill.

Examples
--------
>>> from scipy.stats import tiecorrect, rankdata
>>> tiecorrect([1, 2.5, 2.5, 4])
0.9
>>> ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])
>>> ranks
array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])
>>> tiecorrect(ranks)
0.9833333333333333
================================================================================

tmax:
Firma: (a, upperlimit=None, axis=0, inclusive=True, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the trimmed maximum.

This function computes the maximum value of an array along a given axis,
while ignoring values larger than a specified upper limit.

Parameters
----------
a : array_like
    Array of values.
upperlimit : None or float, optional
    Values in the input array greater than the given limit will be ignored.
    When upperlimit is None, then all values are used. The default value
    is None.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the upper limit
    are included.  The default value is True.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tmax : float, int or ndarray
    Trimmed maximum.

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tmax(x)
19

>>> stats.tmax(x, 13)
13

>>> stats.tmax(x, 13, inclusive=False)
12
================================================================================

tmean:
Firma: (a, limits=None, inclusive=(True, True), axis=None, *, nan_policy='propagate', keepdims=False)

Docstring:
Compute the trimmed mean.

This function finds the arithmetic mean of given values, ignoring values
outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored.  When limits is None (default), then all
    values are used.  Either of the limit values in the tuple can also be
    None representing a half-open interval.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, default: None
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tmean : ndarray
    Trimmed mean.

See Also
--------

:func:`trim_mean`
    Returns mean after trimming a proportion from both tails.


Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tmean(x)
9.5
>>> stats.tmean(x, (3,17))
10.0
================================================================================

tmin:
Firma: (a, lowerlimit=None, axis=0, inclusive=True, nan_policy='propagate', *, keepdims=False)

Docstring:
Compute the trimmed minimum.

This function finds the minimum value of an array `a` along the
specified axis, but only considering values greater than a specified
lower limit.

Parameters
----------
a : array_like
    Array of values.
lowerlimit : None or float, optional
    Values in the input array less than the given limit will be ignored.
    When lowerlimit is None, then all values are used. The default value
    is None.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the lower limit
    are included.  The default value is True.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tmin : float, int or ndarray
    Trimmed minimum.

Notes
-----

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tmin(x)
0

>>> stats.tmin(x, 13)
13

>>> stats.tmin(x, 13, inclusive=False)
14
================================================================================

trapezoid:
Firma: (*args, **kwds)

Docstring:
A trapezoidal continuous random variable.

As an instance of the `rv_continuous` class, `trapezoid` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, d, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, d, loc=0, scale=1)
    Probability density function.
logpdf(x, c, d, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, d, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, d, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, d, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, d, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, d, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, d, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, d, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, d, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, d, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c, d), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, d, loc=0, scale=1)
    Median of the distribution.
mean(c, d, loc=0, scale=1)
    Mean of the distribution.
var(c, d, loc=0, scale=1)
    Variance of the distribution.
std(c, d, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, d, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The trapezoidal distribution can be represented with an up-sloping line
from ``loc`` to ``(loc + c*scale)``, then constant to ``(loc + d*scale)``
and then downsloping from ``(loc + d*scale)`` to ``(loc+scale)``.  This
defines the trapezoid base from ``loc`` to ``(loc+scale)`` and the flat
top from ``c`` to ``d`` proportional to the position along the base
with ``0 <= c <= d <= 1``.  When ``c=d``, this is equivalent to `triang`
with the same values for `loc`, `scale` and `c`.
The method of [1]_ is used for computing moments.

`trapezoid` takes :math:`c` and :math:`d` as shape parameters.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``trapezoid.pdf(x, c, d, loc, scale)`` is identically
equivalent to ``trapezoid.pdf(y, c, d) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The standard form is in the range [0, 1] with c the mode.
The location parameter shifts the start to `loc`.
The scale parameter changes the width from 1 to `scale`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import trapezoid
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c, d = 0.2, 0.8
>>> mean, var, skew, kurt = trapezoid.stats(c, d, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(trapezoid.ppf(0.01, c, d),
...                 trapezoid.ppf(0.99, c, d), 100)
>>> ax.plot(x, trapezoid.pdf(x, c, d),
...        'r-', lw=5, alpha=0.6, label='trapezoid pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = trapezoid(c, d)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = trapezoid.ppf([0.001, 0.5, 0.999], c, d)
>>> np.allclose([0.001, 0.5, 0.999], trapezoid.cdf(vals, c, d))
True

Generate random numbers:

>>> r = trapezoid.rvs(c, d, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


References
----------
.. [1] Kacker, R.N. and Lawrence, J.F. (2007). Trapezoidal and triangular
   distributions for Type B evaluation of standard uncertainty.
   Metrologia 44, 117-127. :doi:`10.1088/0026-1394/44/2/003`
================================================================================

trapz:
Firma: (*args, **kwds)

Docstring:
.. deprecated:: 1.14.0
    `trapz` is deprecated and will be removed in SciPy 1.16.
    Plese use `trapezoid` instead!
================================================================================

triang:
Firma: (*args, **kwds)

Docstring:
A triangular continuous random variable.

As an instance of the `rv_continuous` class, `triang` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The triangular distribution can be represented with an up-sloping line from
``loc`` to ``(loc + c*scale)`` and then downsloping for ``(loc + c*scale)``
to ``(loc + scale)``.

`triang` takes ``c`` as a shape parameter for :math:`0 \le c \le 1`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``triang.pdf(x, c, loc, scale)`` is identically
equivalent to ``triang.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

The standard form is in the range [0, 1] with c the mode.
The location parameter shifts the start to `loc`.
The scale parameter changes the width from 1 to `scale`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import triang
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.158
>>> mean, var, skew, kurt = triang.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(triang.ppf(0.01, c),
...                 triang.ppf(0.99, c), 100)
>>> ax.plot(x, triang.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='triang pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = triang(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = triang.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], triang.cdf(vals, c))
True

Generate random numbers:

>>> r = triang.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

trim1:
Firma: (a, proportiontocut, tail='right', axis=0)

Docstring:
Slice off a proportion from ONE end of the passed array distribution.

If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost'
10% of scores. The lowest or highest values are trimmed (depending on
the tail).
Slice off less if proportion results in a non-integer slice index
(i.e. conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array.
proportiontocut : float
    Fraction to cut off of 'left' or 'right' of distribution.
tail : {'left', 'right'}, optional
    Defaults to 'right'.
axis : int or None, optional
    Axis along which to trim data. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
trim1 : ndarray
    Trimmed version of array `a`. The order of the trimmed content is
    undefined.

Examples
--------
Create an array of 10 values and trim 20% of its lowest values:

>>> import numpy as np
>>> from scipy import stats
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> stats.trim1(a, 0.2, 'left')
array([2, 4, 3, 5, 6, 7, 8, 9])

Note that the elements of the input array are trimmed by value, but the
output array is not necessarily sorted.

The proportion to trim is rounded down to the nearest integer. For
instance, trimming 25% of the values from an array of 10 values will
return an array of 8 values:

>>> b = np.arange(10)
>>> stats.trim1(b, 1/4).shape
(8,)

Multidimensional arrays can be trimmed along any axis or across the entire
array:

>>> c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]
>>> d = np.array([a, b, c])
>>> stats.trim1(d, 0.8, axis=0).shape
(1, 10)
>>> stats.trim1(d, 0.8, axis=1).shape
(3, 2)
>>> stats.trim1(d, 0.8, axis=None).shape
(6,)
================================================================================

trim_mean:
Firma: (a, proportiontocut, axis=0)

Docstring:
Return mean of array after trimming a specified fraction of extreme values

Removes the specified proportion of elements from *each* end of the
sorted array, then computes the mean of the remaining elements.

Parameters
----------
a : array_like
    Input array.
proportiontocut : float
    Fraction of the most positive and most negative elements to remove.
    When the specified proportion does not result in an integer number of
    elements, the number of elements to trim is rounded down.
axis : int or None, default: 0
    Axis along which the trimmed means are computed.
    If None, compute over the raveled array.

Returns
-------
trim_mean : ndarray
    Mean of trimmed array.

See Also
--------
trimboth : Remove a proportion of elements from each end of an array.
tmean : Compute the mean after trimming values outside specified limits.

Notes
-----
For 1-D array `a`, `trim_mean` is approximately equivalent to the following
calculation::

    import numpy as np
    a = np.sort(a)
    m = int(proportiontocut * len(a))
    np.mean(a[m: len(a) - m])

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = [1, 2, 3, 5]
>>> stats.trim_mean(x, 0.25)
2.5

When the specified proportion does not result in an integer number of
elements, the number of elements to trim is rounded down.

>>> stats.trim_mean(x, 0.24999) == np.mean(x)
True

Use `axis` to specify the axis along which the calculation is performed.

>>> x2 = [[1, 2, 3, 5],
...       [10, 20, 30, 50]]
>>> stats.trim_mean(x2, 0.25)
array([ 5.5, 11. , 16.5, 27.5])
>>> stats.trim_mean(x2, 0.25, axis=1)
array([ 2.5, 25. ])
================================================================================

trimboth:
Firma: (a, proportiontocut, axis=0)

Docstring:
Slice off a proportion of items from both ends of an array.

Slice off the passed proportion of items from both ends of the passed
array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**
rightmost 10% of scores). The trimmed values are the lowest and
highest ones.
Slice off less if proportion results in a non-integer slice index (i.e.
conservatively slices off `proportiontocut`).

Parameters
----------
a : array_like
    Data to trim.
proportiontocut : float
    Proportion (in range 0-1) of total data set to trim of each end.
axis : int or None, optional
    Axis along which to trim data. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
out : ndarray
    Trimmed version of array `a`. The order of the trimmed content
    is undefined.

See Also
--------
trim_mean

Examples
--------
Create an array of 10 values and trim 10% of those values from each end:

>>> import numpy as np
>>> from scipy import stats
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> stats.trimboth(a, 0.1)
array([1, 3, 2, 4, 5, 6, 7, 8])

Note that the elements of the input array are trimmed by value, but the
output array is not necessarily sorted.

The proportion to trim is rounded down to the nearest integer. For
instance, trimming 25% of the values from each end of an array of 10
values will return an array of 6 values:

>>> b = np.arange(10)
>>> stats.trimboth(b, 1/4).shape
(6,)

Multidimensional arrays can be trimmed along any axis or across the entire
array:

>>> c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]
>>> d = np.array([a, b, c])
>>> stats.trimboth(d, 0.4, axis=0).shape
(1, 10)
>>> stats.trimboth(d, 0.4, axis=1).shape
(3, 2)
>>> stats.trimboth(d, 0.4, axis=None).shape
(6,)
================================================================================

truncate:
Firma: (X, lb=-inf, ub=inf)

Docstring:
Truncate the support of a random variable.

Given a random variable `X`, `truncate` returns a random variable with
support truncated to the interval between `lb` and `ub`. The underlying
probability density function is normalized accordingly.

Parameters
----------
X : `ContinuousDistribution`
    The random variable to be truncated.
lb, ub : float array-like
    The lower and upper truncation points, respectively. Must be
    broadcastable with one another and the shape of `X`.

Returns
-------
X : `ContinuousDistribution`
    The truncated random variable.

References
----------
.. [1] "Truncated Distribution". *Wikipedia*.
       https://en.wikipedia.org/wiki/Truncated_distribution

Examples
--------
Compare against `scipy.stats.truncnorm`, which truncates a standard normal,
*then* shifts and scales it.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> loc, scale, lb, ub = 1, 2, -2, 2
>>> X = stats.truncnorm(lb, ub, loc, scale)
>>> Y = scale * stats.truncate(stats.Normal(), lb, ub) + loc
>>> x = np.linspace(-3, 5, 300)
>>> plt.plot(x, X.pdf(x), '-', label='X')
>>> plt.plot(x, Y.pdf(x), '--', label='Y')
>>> plt.xlabel('x')
>>> plt.ylabel('PDF')
>>> plt.title('Truncated, then Shifted/Scaled Normal')
>>> plt.legend()
>>> plt.show()

However, suppose we wish to shift and scale a normal random variable,
then truncate its support to given values. This is straightforward with
`truncate`.

>>> Z = stats.truncate(scale * stats.Normal() + loc, lb, ub)
>>> Z.plot()
>>> plt.show()

Furthermore, `truncate` can be applied to any random variable:

>>> Rayleigh = stats.make_distribution(stats.rayleigh)
>>> W = stats.truncate(Rayleigh(), lb=0, ub=3)
>>> W.plot()
>>> plt.show()
================================================================================

truncexpon:
Firma: (*args, **kwds)

Docstring:
A truncated exponential continuous random variable.

As an instance of the `rv_continuous` class, `truncexpon` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, b, loc=0, scale=1)
    Probability density function.
logpdf(x, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(b,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(b, loc=0, scale=1)
    Median of the distribution.
mean(b, loc=0, scale=1)
    Mean of the distribution.
var(b, loc=0, scale=1)
    Variance of the distribution.
std(b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `truncexpon` is:

.. math::

    f(x, b) = \frac{\exp(-x)}{1 - \exp(-b)}

for :math:`0 <= x <= b`.

`truncexpon` takes ``b`` as a shape parameter for :math:`b`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``truncexpon.pdf(x, b, loc, scale)`` is identically
equivalent to ``truncexpon.pdf(y, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import truncexpon
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> b = 4.69
>>> mean, var, skew, kurt = truncexpon.stats(b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(truncexpon.ppf(0.01, b),
...                 truncexpon.ppf(0.99, b), 100)
>>> ax.plot(x, truncexpon.pdf(x, b),
...        'r-', lw=5, alpha=0.6, label='truncexpon pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = truncexpon(b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = truncexpon.ppf([0.001, 0.5, 0.999], b)
>>> np.allclose([0.001, 0.5, 0.999], truncexpon.cdf(vals, b))
True

Generate random numbers:

>>> r = truncexpon.rvs(b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

truncnorm:
Firma: (*args, **kwds)

Docstring:
A truncated normal continuous random variable.

As an instance of the `rv_continuous` class, `truncnorm` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, b, loc=0, scale=1)
    Median of the distribution.
mean(a, b, loc=0, scale=1)
    Mean of the distribution.
var(a, b, loc=0, scale=1)
    Variance of the distribution.
std(a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
This distribution is the normal distribution centered on ``loc`` (default
0), with standard deviation ``scale`` (default 1), and truncated at ``a``
and ``b`` *standard deviations* from ``loc``. For arbitrary ``loc`` and
``scale``, ``a`` and ``b`` are *not* the abscissae at which the shifted
and scaled distribution is truncated.

.. note::
    If ``a_trunc`` and ``b_trunc`` are the abscissae at which we wish
    to truncate the distribution (as opposed to the number of standard
    deviations from ``loc``), then we can calculate the distribution
    parameters ``a`` and ``b`` as follows::

        a, b = (a_trunc - loc) / scale, (b_trunc - loc) / scale

    This is a common point of confusion. For additional clarification,
    please see the example below.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import truncnorm
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, b = 0.1, 2
>>> mean, var, skew, kurt = truncnorm.stats(a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(truncnorm.ppf(0.01, a, b),
...                 truncnorm.ppf(0.99, a, b), 100)
>>> ax.plot(x, truncnorm.pdf(x, a, b),
...        'r-', lw=5, alpha=0.6, label='truncnorm pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = truncnorm(a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = truncnorm.ppf([0.001, 0.5, 0.999], a, b)
>>> np.allclose([0.001, 0.5, 0.999], truncnorm.cdf(vals, a, b))
True

Generate random numbers:

>>> r = truncnorm.rvs(a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()


In the examples above, ``loc=0`` and ``scale=1``, so the plot is truncated
at ``a`` on the left and ``b`` on the right. However, suppose we were to
produce the same histogram with ``loc = 1`` and ``scale=0.5``.

>>> loc, scale = 1, 0.5
>>> rv = truncnorm(a, b, loc=loc, scale=scale)
>>> x = np.linspace(truncnorm.ppf(0.01, a, b),
...                 truncnorm.ppf(0.99, a, b), 100)
>>> r = rv.rvs(size=1000)

>>> fig, ax = plt.subplots(1, 1)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')
>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim(a, b)
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Note that the distribution is no longer appears to be truncated at
abscissae ``a`` and ``b``. That is because the *standard* normal
distribution is first truncated at ``a`` and ``b``, *then* the resulting
distribution is scaled by ``scale`` and shifted by ``loc``. If we instead
want the shifted and scaled distribution to be truncated at ``a`` and
``b``, we need to transform these values before passing them as the
distribution parameters.

>>> a_transformed, b_transformed = (a - loc) / scale, (b - loc) / scale
>>> rv = truncnorm(a_transformed, b_transformed, loc=loc, scale=scale)
>>> x = np.linspace(truncnorm.ppf(0.01, a, b),
...                 truncnorm.ppf(0.99, a, b), 100)
>>> r = rv.rvs(size=10000)

>>> fig, ax = plt.subplots(1, 1)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')
>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim(a-0.1, b+0.1)
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

truncpareto:
Firma: (*args, **kwds)

Docstring:
An upper truncated Pareto continuous random variable.

As an instance of the `rv_continuous` class, `truncpareto` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(b, c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, b, c, loc=0, scale=1)
    Probability density function.
logpdf(x, b, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, b, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, b, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, b, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, b, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, b, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, b, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, b, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(b, c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(b, c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(b, c), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(b, c, loc=0, scale=1)
    Median of the distribution.
mean(b, c, loc=0, scale=1)
    Mean of the distribution.
var(b, c, loc=0, scale=1)
    Variance of the distribution.
std(b, c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, b, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
pareto : Pareto distribution

Notes
-----
The probability density function for `truncpareto` is:

.. math::

    f(x, b, c) = \frac{b}{1 - c^{-b}} \frac{1}{x^{b+1}}

for :math:`b > 0`, :math:`c > 1` and :math:`1 \le x \le c`.

`truncpareto` takes `b` and `c` as shape parameters for :math:`b` and
:math:`c`.

Notice that the upper truncation value :math:`c` is defined in
standardized form so that random values of an unscaled, unshifted variable
are within the range ``[1, c]``.
If ``u_r`` is the upper bound to a scaled and/or shifted variable,
then ``c = (u_r - loc) / scale``. In other words, the support of the
distribution becomes ``(scale + loc) <= x <= (c*scale + loc)`` when
`scale` and/or `loc` are provided.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``truncpareto.pdf(x, b, c, loc, scale)`` is identically
equivalent to ``truncpareto.pdf(y, b, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
.. [1] Burroughs, S. M., and Tebbens S. F.
    "Upper-truncated power laws in natural systems."
    Pure and Applied Geophysics 158.4 (2001): 741-757.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import truncpareto
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> b, c = 2, 5
>>> mean, var, skew, kurt = truncpareto.stats(b, c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(truncpareto.ppf(0.01, b, c),
...                 truncpareto.ppf(0.99, b, c), 100)
>>> ax.plot(x, truncpareto.pdf(x, b, c),
...        'r-', lw=5, alpha=0.6, label='truncpareto pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = truncpareto(b, c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = truncpareto.ppf([0.001, 0.5, 0.999], b, c)
>>> np.allclose([0.001, 0.5, 0.999], truncpareto.cdf(vals, b, c))
True

Generate random numbers:

>>> r = truncpareto.rvs(b, c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

truncweibull_min:
Firma: (*args, **kwds)

Docstring:
A doubly truncated Weibull minimum continuous random variable.

As an instance of the `rv_continuous` class, `truncweibull_min` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, a, b, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, a, b, loc=0, scale=1)
    Probability density function.
logpdf(x, c, a, b, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, a, b, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, a, b, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, a, b, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, a, b, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, a, b, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, a, b, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, a, b, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, a, b, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, a, b, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c, a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, a, b, loc=0, scale=1)
    Median of the distribution.
mean(c, a, b, loc=0, scale=1)
    Mean of the distribution.
var(c, a, b, loc=0, scale=1)
    Variance of the distribution.
std(c, a, b, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, a, b, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
weibull_min, truncexpon

Notes
-----
The probability density function for `truncweibull_min` is:

.. math::

    f(x, a, b, c) = \frac{c x^{c-1} \exp(-x^c)}{\exp(-a^c) - \exp(-b^c)}

for :math:`a < x <= b`, :math:`0 \le a < b` and :math:`c > 0`.

`truncweibull_min` takes :math:`a`, :math:`b`, and :math:`c` as shape
parameters.

Notice that the truncation values, :math:`a` and :math:`b`, are defined in
standardized form:

.. math::

    a = (u_l - loc)/scale
    b = (u_r - loc)/scale

where :math:`u_l` and :math:`u_r` are the specific left and right
truncation values, respectively. In other words, the support of the
distribution becomes :math:`(a*scale + loc) < x <= (b*scale + loc)` when
:math:`loc` and/or :math:`scale` are provided.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``truncweibull_min.pdf(x, c, a, b, loc, scale)`` is identically
equivalent to ``truncweibull_min.pdf(y, c, a, b) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------

.. [1] Rinne, H. "The Weibull Distribution: A Handbook". CRC Press (2009).

Examples
--------
>>> import numpy as np
>>> from scipy.stats import truncweibull_min
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c, a, b = 2.5, 0.25, 1.75
>>> mean, var, skew, kurt = truncweibull_min.stats(c, a, b, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(truncweibull_min.ppf(0.01, c, a, b),
...                 truncweibull_min.ppf(0.99, c, a, b), 100)
>>> ax.plot(x, truncweibull_min.pdf(x, c, a, b),
...        'r-', lw=5, alpha=0.6, label='truncweibull_min pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = truncweibull_min(c, a, b)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = truncweibull_min.ppf([0.001, 0.5, 0.999], c, a, b)
>>> np.allclose([0.001, 0.5, 0.999], truncweibull_min.cdf(vals, c, a, b))
True

Generate random numbers:

>>> r = truncweibull_min.rvs(c, a, b, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

tsem:
Firma: (a, limits=None, inclusive=(True, True), axis=0, ddof=1, *, nan_policy='propagate', keepdims=False)

Docstring:
Compute the trimmed standard error of the mean.

This function finds the standard error of the mean for given
values, ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tsem : float
    Trimmed standard error of the mean.

Notes
-----
`tsem` uses unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tsem(x)
1.3228756555322954
>>> stats.tsem(x, (3,17))
1.1547005383792515
================================================================================

tstd:
Firma: (a, limits=None, inclusive=(True, True), axis=0, ddof=1, *, nan_policy='propagate', keepdims=False)

Docstring:
Compute the trimmed sample standard deviation.

This function finds the sample standard deviation of given values,
ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tstd : float
    Trimmed sample standard deviation.

Notes
-----
`tstd` computes the unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tstd(x)
5.9160797830996161
>>> stats.tstd(x, (3,17))
4.4721359549995796
================================================================================

ttest_1samp:
Firma: (a, popmean, axis=0, nan_policy='propagate', alternative='two-sided', *, keepdims=False)

Docstring:
Calculate the T-test for the mean of ONE group of scores.

This is a test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    Sample observations.
popmean : float or array_like
    Expected value in null hypothesis. If array_like, then its length along
    `axis` must equal 1, and it must otherwise be broadcastable with `a`.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):
    
    * 'two-sided': the mean of the underlying distribution of the sample
      is different than the given population mean (`popmean`)
    * 'less': the mean of the underlying distribution of the sample is
      less than the given population mean (`popmean`)
    * 'greater': the mean of the underlying distribution of the sample is
      greater than the given population mean (`popmean`)
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
result : `~scipy.stats._result_classes.TtestResult`
    An object with the following attributes:
    
    statistic : float or array
        The t-statistic.
    pvalue : float or array
        The p-value associated with the given alternative.
    df : float or array
        The number of degrees of freedom used in calculation of the
        t-statistic; this is one less than the size of the sample
        (``a.shape[axis]``).
    
        .. versionadded:: 1.10.0
    
    The object also has the following method:
    
    confidence_interval(confidence_level=0.95)
        Computes a confidence interval around the population
        mean for the given confidence level.
        The confidence interval is returned in a ``namedtuple`` with
        fields `low` and `high`.
    
        .. versionadded:: 1.10.0

Notes
-----
The statistic is calculated as ``(np.mean(a) - popmean)/se``, where
``se`` is the standard error. Therefore, the statistic will be positive
when the sample mean is greater than the population mean and negative when
the sample mean is less than the population mean.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
Suppose we wish to test the null hypothesis that the mean of a population
is equal to 0.5. We choose a confidence level of 99%; that is, we will
reject the null hypothesis in favor of the alternative if the p-value is
less than 0.01.

When testing random variates from the standard uniform distribution, which
has a mean of 0.5, we expect the data to be consistent with the null
hypothesis most of the time.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> rvs = stats.uniform.rvs(size=50, random_state=rng)
>>> stats.ttest_1samp(rvs, popmean=0.5)
TtestResult(statistic=2.456308468440, pvalue=0.017628209047638, df=49)

As expected, the p-value of 0.017 is not below our threshold of 0.01, so
we cannot reject the null hypothesis.

When testing data from the standard *normal* distribution, which has a mean
of 0, we would expect the null hypothesis to be rejected.

>>> rvs = stats.norm.rvs(size=50, random_state=rng)
>>> stats.ttest_1samp(rvs, popmean=0.5)
TtestResult(statistic=-7.433605518875, pvalue=1.416760157221e-09, df=49)

Indeed, the p-value is lower than our threshold of 0.01, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the mean
of the population is *not* equal to 0.5.

However, suppose we were to test the null hypothesis against the
one-sided alternative that the mean of the population is *greater* than
0.5. Since the mean of the standard normal is less than 0.5, we would not
expect the null hypothesis to be rejected.

>>> stats.ttest_1samp(rvs, popmean=0.5, alternative='greater')
TtestResult(statistic=-7.433605518875, pvalue=0.99999999929, df=49)

Unsurprisingly, with a p-value greater than our threshold, we would not
reject the null hypothesis.

Note that when working with a confidence level of 99%, a true null
hypothesis will be rejected approximately 1% of the time.

>>> rvs = stats.uniform.rvs(size=(100, 50), random_state=rng)
>>> res = stats.ttest_1samp(rvs, popmean=0.5, axis=1)
>>> np.sum(res.pvalue < 0.01)
1

Indeed, even though all 100 samples above were drawn from the standard
uniform distribution, which *does* have a population mean of 0.5, we would
mistakenly reject the null hypothesis for one of them.

`ttest_1samp` can also compute a confidence interval around the population
mean.

>>> rvs = stats.norm.rvs(size=50, random_state=rng)
>>> res = stats.ttest_1samp(rvs, popmean=0)
>>> ci = res.confidence_interval(confidence_level=0.95)
>>> ci
ConfidenceInterval(low=-0.3193887540880017, high=0.2898583388980972)

The bounds of the 95% confidence interval are the
minimum and maximum values of the parameter `popmean` for which the
p-value of the test would be 0.05.

>>> res = stats.ttest_1samp(rvs, popmean=ci.low)
>>> np.testing.assert_allclose(res.pvalue, 0.05)
>>> res = stats.ttest_1samp(rvs, popmean=ci.high)
>>> np.testing.assert_allclose(res.pvalue, 0.05)

Under certain assumptions about the population from which a sample
is drawn, the confidence interval with confidence level 95% is expected
to contain the true population mean in 95% of sample replications.

>>> rvs = stats.norm.rvs(size=(50, 1000), loc=1, random_state=rng)
>>> res = stats.ttest_1samp(rvs, popmean=0)
>>> ci = res.confidence_interval()
>>> contains_pop_mean = (ci.low < 1) & (ci.high > 1)
>>> contains_pop_mean.sum()
953
================================================================================

ttest_ind:
Firma: (a, b, *, axis=0, equal_var=True, nan_policy='propagate', permutations=None, random_state=None, alternative='two-sided', trim=0, method=None, keepdims=False)

Docstring:
Calculate the T-test for the means of *two independent* samples of scores.

This is a test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances by default.

.. deprecated:: 1.17.0
    Use of argument(s) ``{'trim', 'nan_policy', 'equal_var', 'axis', 'alternative', 'method', 'keepdims'}`` by position is deprecated; beginning in 
    SciPy 1.17.0, these will be keyword-only. Argument(s) ``{'permutations', 'random_state'}`` are deprecated, whether passed by position or keyword; they will be removed in SciPy 1.17.0. Use ``method`` to perform a permutation test.

Parameters
----------
a, b : array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.
    
    .. versionadded:: 0.11.0
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
permutations : non-negative int, np.inf, or None (default), optional
    If 0 or None (default), use the t-distribution to calculate p-values.
    Otherwise, `permutations` is  the number of random permutations that
    will be used to estimate p-values using a permutation test. If
    `permutations` equals or exceeds the number of distinct partitions of
    the pooled data, an exact test is performed instead (i.e. each
    distinct partition is used exactly once). See Notes for details.
    
    .. deprecated:: 1.17.0
        `permutations` is deprecated and will be removed in SciPy 1.7.0.
        Use the `n_resamples` argument of `PermutationMethod`, instead,
        and pass the instance as the `method` argument.
random_state : {None, int, `numpy.random.Generator`,
        `numpy.random.RandomState`}, optional
    
    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.
    
    Pseudorandom number generator state used to generate permutations
    (used only when `permutations` is not None).
    
    .. deprecated:: 1.17.0
        `random_state` is deprecated and will be removed in SciPy 1.7.0.
        Use the `rng` argument of `PermutationMethod`, instead,
        and pass the instance as the `method` argument.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):
    
    * 'two-sided': the means of the distributions underlying the samples
      are unequal.
    * 'less': the mean of the distribution underlying the first sample
      is less than the mean of the distribution underlying the second
      sample.
    * 'greater': the mean of the distribution underlying the first
      sample is greater than the mean of the distribution underlying
      the second sample.
trim : float, optional
    If nonzero, performs a trimmed (Yuen's) t-test.
    Defines the fraction of elements to be trimmed from each end of the
    input samples. If 0 (default), no elements will be trimmed from either
    side. The number of trimmed elements from each tail is the floor of the
    trim times the number of elements. Valid range is [0, .5).
method : ResamplingMethod, optional
    Defines the method used to compute the p-value. If `method` is an
    instance of `PermutationMethod`/`MonteCarloMethod`, the p-value is
    computed using
    `scipy.stats.permutation_test`/`scipy.stats.monte_carlo_test` with the
    provided configuration options and other appropriate settings.
    Otherwise, the p-value is computed by comparing the test statistic
    against a theoretical t-distribution.
    
    .. versionadded:: 1.15.0
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
result : `~scipy.stats._result_classes.TtestResult`
    An object with the following attributes:
    
    statistic : float or ndarray
        The t-statistic.
    pvalue : float or ndarray
        The p-value associated with the given alternative.
    df : float or ndarray
        The number of degrees of freedom used in calculation of the
        t-statistic. This is always NaN for a permutation t-test.
    
        .. versionadded:: 1.11.0
    
    The object also has the following method:
    
    confidence_interval(confidence_level=0.95)
        Computes a confidence interval around the difference in
        population means for the given confidence level.
        The confidence interval is returned in a ``namedtuple`` with
        fields ``low`` and ``high``.
        When a permutation t-test is performed, the confidence interval
        is not computed, and fields ``low`` and ``high`` contain NaN.
    
        .. versionadded:: 1.11.0

Notes
-----
Suppose we observe two independent samples, e.g. flower petal lengths, and
we are considering whether the two samples were drawn from the same
population (e.g. the same species of flower or two species with similar
petal characteristics) or two different populations.

The t-test quantifies the difference between the arithmetic means
of the two samples. The p-value quantifies the probability of observing
as or more extreme values assuming the null hypothesis, that the
samples are drawn from populations with the same population means, is true.
A p-value larger than a chosen threshold (e.g. 5% or 1%) indicates that
our observation is not so unlikely to have occurred by chance. Therefore,
we do not reject the null hypothesis of equal population means.
If the p-value is smaller than our threshold, then we have evidence
against the null hypothesis of equal population means.

By default, the p-value is determined by comparing the t-statistic of the
observed data against a theoretical t-distribution.

(In the following, note that the argument `permutations` itself is
deprecated, but a nearly identical test may be performed by creating
an instance of `scipy.stats.PermutationMethod` with ``n_resamples=permutuations``
and passing it as the `method` argument.)
When ``1 < permutations < binom(n, k)``, where

* ``k`` is the number of observations in `a`,
* ``n`` is the total number of observations in `a` and `b`, and
* ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),

the data are pooled (concatenated), randomly assigned to either group `a`
or `b`, and the t-statistic is calculated. This process is performed
repeatedly (`permutation` times), generating a distribution of the
t-statistic under the null hypothesis, and the t-statistic of the observed
data is compared to this distribution to determine the p-value.
Specifically, the p-value reported is the "achieved significance level"
(ASL) as defined in 4.4 of [3]_. Note that there are other ways of
estimating p-values using randomized permutation tests; for other
options, see the more general `permutation_test`.

When ``permutations >= binom(n, k)``, an exact test is performed: the data
are partitioned between the groups in each distinct way exactly once.

The permutation test can be computationally expensive and not necessarily
more accurate than the analytical test, but it does not make strong
assumptions about the shape of the underlying distribution.

Use of trimming is commonly referred to as the trimmed t-test. At times
called Yuen's t-test, this is an extension of Welch's t-test, with the
difference being the use of winsorized means in calculation of the variance
and the trimmed sample size in calculation of the statistic. Trimming is
recommended if the underlying distribution is long-tailed or contaminated
with outliers [4]_.

The statistic is calculated as ``(np.mean(a) - np.mean(b))/se``, where
``se`` is the standard error. Therefore, the statistic will be positive
when the sample mean of `a` is greater than the sample mean of `b` and
negative when the sample mean of `a` is less than the sample mean of
`b`.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test

.. [3] B. Efron and T. Hastie. Computer Age Statistical Inference. (2016).

.. [4] Yuen, Karen K. "The Two-Sample Trimmed t for Unequal Population
       Variances." Biometrika, vol. 61, no. 1, 1974, pp. 165-170. JSTOR,
       www.jstor.org/stable/2334299. Accessed 30 Mar. 2021.

.. [5] Yuen, Karen K., and W. J. Dixon. "The Approximate Behaviour and
       Performance of the Two-Sample Trimmed t." Biometrika, vol. 60,
       no. 2, 1973, pp. 369-374. JSTOR, www.jstor.org/stable/2334550.
       Accessed 30 Mar. 2021.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()

Test with sample with identical means:

>>> rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
>>> rvs2 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
>>> stats.ttest_ind(rvs1, rvs2)
TtestResult(statistic=-0.4390847099199348,
            pvalue=0.6606952038870015,
            df=998.0)
>>> stats.ttest_ind(rvs1, rvs2, equal_var=False)
TtestResult(statistic=-0.4390847099199348,
            pvalue=0.6606952553131064,
            df=997.4602304121448)

`ttest_ind` underestimates p for unequal variances:

>>> rvs3 = stats.norm.rvs(loc=5, scale=20, size=500, random_state=rng)
>>> stats.ttest_ind(rvs1, rvs3)
TtestResult(statistic=-1.6370984482905417,
            pvalue=0.1019251574705033,
            df=998.0)
>>> stats.ttest_ind(rvs1, rvs3, equal_var=False)
TtestResult(statistic=-1.637098448290542,
            pvalue=0.10202110497954867,
            df=765.1098655246868)

When ``n1 != n2``, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:

>>> rvs4 = stats.norm.rvs(loc=5, scale=20, size=100, random_state=rng)
>>> stats.ttest_ind(rvs1, rvs4)
TtestResult(statistic=-1.9481646859513422,
            pvalue=0.05186270935842703,
            df=598.0)
>>> stats.ttest_ind(rvs1, rvs4, equal_var=False)
TtestResult(statistic=-1.3146566100751664,
            pvalue=0.1913495266513811,
            df=110.41349083985212)

T-test with different means, variance, and n:

>>> rvs5 = stats.norm.rvs(loc=8, scale=20, size=100, random_state=rng)
>>> stats.ttest_ind(rvs1, rvs5)
TtestResult(statistic=-2.8415950600298774,
            pvalue=0.0046418707568707885,
            df=598.0)
>>> stats.ttest_ind(rvs1, rvs5, equal_var=False)
TtestResult(statistic=-1.8686598649188084,
            pvalue=0.06434714193919686,
            df=109.32167496550137)

Take these two samples, one of which has an extreme tail.

>>> a = (56, 128.6, 12, 123.8, 64.34, 78, 763.3)
>>> b = (1.1, 2.9, 4.2)

Use the `trim` keyword to perform a trimmed (Yuen) t-test. For example,
using 20% trimming, ``trim=.2``, the test will reduce the impact of one
(``np.floor(trim*len(a))``) element from each tail of sample `a`. It will
have no effect on sample `b` because ``np.floor(trim*len(b))`` is 0.

>>> stats.ttest_ind(a, b, trim=.2)
TtestResult(statistic=3.4463884028073513,
            pvalue=0.01369338726499547,
            df=6.0)
================================================================================

ttest_ind_from_stats:
Firma: (mean1, std1, nobs1, mean2, std2, nobs2, equal_var=True, alternative='two-sided')

Docstring:
T-test for means of two independent samples from descriptive statistics.

This is a test for the null hypothesis that two independent
samples have identical average (expected) values.

Parameters
----------
mean1 : array_like
    The mean(s) of sample 1.
std1 : array_like
    The corrected sample standard deviation of sample 1 (i.e. ``ddof=1``).
nobs1 : array_like
    The number(s) of observations of sample 1.
mean2 : array_like
    The mean(s) of sample 2.
std2 : array_like
    The corrected sample standard deviation of sample 2 (i.e. ``ddof=1``).
nobs2 : array_like
    The number(s) of observations of sample 2.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the means of the distributions are unequal.
    * 'less': the mean of the first distribution is less than the
      mean of the second distribution.
    * 'greater': the mean of the first distribution is greater than the
      mean of the second distribution.

    .. versionadded:: 1.6.0

Returns
-------
statistic : float or array
    The calculated t-statistics.
pvalue : float or array
    The two-tailed p-value.

See Also
--------
scipy.stats.ttest_ind

Notes
-----
The statistic is calculated as ``(mean1 - mean2)/se``, where ``se`` is the
standard error. Therefore, the statistic will be positive when `mean1` is
greater than `mean2` and negative when `mean1` is less than `mean2`.

This method does not check whether any of the elements of `std1` or `std2`
are negative. If any elements of the `std1` or `std2` parameters are
negative in a call to this method, this method will return the same result
as if it were passed ``numpy.abs(std1)`` and ``numpy.abs(std2)``,
respectively, instead; no exceptions or warnings will be emitted.

References
----------
.. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test

Examples
--------
Suppose we have the summary data for two samples, as follows (with the
Sample Variance being the corrected sample variance)::

                     Sample   Sample
               Size   Mean   Variance
    Sample 1    13    15.0     87.5
    Sample 2    11    12.0     39.0

Apply the t-test to this data (with the assumption that the population
variances are equal):

>>> import numpy as np
>>> from scipy.stats import ttest_ind_from_stats
>>> ttest_ind_from_stats(mean1=15.0, std1=np.sqrt(87.5), nobs1=13,
...                      mean2=12.0, std2=np.sqrt(39.0), nobs2=11)
Ttest_indResult(statistic=0.9051358093310269, pvalue=0.3751996797581487)

For comparison, here is the data from which those summary statistics
were taken.  With this data, we can compute the same result using
`scipy.stats.ttest_ind`:

>>> a = np.array([1, 3, 4, 6, 11, 13, 15, 19, 22, 24, 25, 26, 26])
>>> b = np.array([2, 4, 6, 9, 11, 13, 14, 15, 18, 19, 21])
>>> from scipy.stats import ttest_ind
>>> ttest_ind(a, b)
TtestResult(statistic=0.905135809331027,
            pvalue=0.3751996797581486,
            df=22.0)

Suppose we instead have binary data and would like to apply a t-test to
compare the proportion of 1s in two independent groups::

                      Number of    Sample     Sample
                Size    ones        Mean     Variance
    Sample 1    150      30         0.2        0.161073
    Sample 2    200      45         0.225      0.175251

The sample mean :math:`\hat{p}` is the proportion of ones in the sample
and the variance for a binary observation is estimated by
:math:`\hat{p}(1-\hat{p})`.

>>> ttest_ind_from_stats(mean1=0.2, std1=np.sqrt(0.161073), nobs1=150,
...                      mean2=0.225, std2=np.sqrt(0.175251), nobs2=200)
Ttest_indResult(statistic=-0.5627187905196761, pvalue=0.5739887114209541)

For comparison, we could compute the t statistic and p-value using
arrays of 0s and 1s and `scipy.stat.ttest_ind`, as above.

>>> group1 = np.array([1]*30 + [0]*(150-30))
>>> group2 = np.array([1]*45 + [0]*(200-45))
>>> ttest_ind(group1, group2)
TtestResult(statistic=-0.5627179589855622,
            pvalue=0.573989277115258,
            df=348.0)
================================================================================

ttest_rel:
Firma: (a, b, axis=0, nan_policy='propagate', alternative='two-sided', *, keepdims=False)

Docstring:
Calculate the t-test on TWO RELATED samples of scores, a and b.

This is a test for the null hypothesis that two related or
repeated samples have identical average (expected) values.

Parameters
----------
a, b : array_like
    The arrays must have the same shape.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):
    
    * 'two-sided': the means of the distributions underlying the samples
      are unequal.
    * 'less': the mean of the distribution underlying the first sample
      is less than the mean of the distribution underlying the second
      sample.
    * 'greater': the mean of the distribution underlying the first
      sample is greater than the mean of the distribution underlying
      the second sample.
    
    .. versionadded:: 1.6.0
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
result : `~scipy.stats._result_classes.TtestResult`
    An object with the following attributes:
    
    statistic : float or array
        The t-statistic.
    pvalue : float or array
        The p-value associated with the given alternative.
    df : float or array
        The number of degrees of freedom used in calculation of the
        t-statistic; this is one less than the size of the sample
        (``a.shape[axis]``).
    
        .. versionadded:: 1.10.0
    
    The object also has the following method:
    
    confidence_interval(confidence_level=0.95)
        Computes a confidence interval around the difference in
        population means for the given confidence level.
        The confidence interval is returned in a ``namedtuple`` with
        fields `low` and `high`.
    
        .. versionadded:: 1.10.0

Notes
-----
Examples for use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.

The t-statistic is calculated as ``np.mean(a - b)/se``, where ``se`` is the
standard error. Therefore, the t-statistic will be positive when the sample
mean of ``a - b`` is greater than zero and negative when the sample mean of
``a - b`` is less than zero.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()

>>> rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
>>> rvs2 = (stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))
>>> stats.ttest_rel(rvs1, rvs2)
TtestResult(statistic=-0.4549717054410304, pvalue=0.6493274702088672, df=499)
>>> rvs3 = (stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)
...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))
>>> stats.ttest_rel(rvs1, rvs3)
TtestResult(statistic=-5.879467544540889, pvalue=7.540777129099917e-09, df=499)
================================================================================

tukey_hsd:
Firma: (*args)

Docstring:
Perform Tukey's HSD test for equality of means over multiple treatments.

Tukey's honestly significant difference (HSD) test performs pairwise
comparison of means for a set of samples. Whereas ANOVA (e.g. `f_oneway`)
assesses whether the true means underlying each sample are identical,
Tukey's HSD is a post hoc test used to compare the mean of each sample
to the mean of each other sample.

The null hypothesis is that the distributions underlying the samples all
have the same mean. The test statistic, which is computed for every
possible pairing of samples, is simply the difference between the sample
means. For each pair, the p-value is the probability under the null
hypothesis (and other assumptions; see notes) of observing such an extreme
value of the statistic, considering that many pairwise comparisons are
being performed. Confidence intervals for the difference between each pair
of means are also available.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group. There must be at least
    two arguments.

Returns
-------
result : `~scipy.stats._result_classes.TukeyHSDResult` instance
    The return value is an object with the following attributes:

    statistic : float ndarray
        The computed statistic of the test for each comparison. The element
        at index ``(i, j)`` is the statistic for the comparison between
        groups ``i`` and ``j``.
    pvalue : float ndarray
        The computed p-value of the test for each comparison. The element
        at index ``(i, j)`` is the p-value for the comparison between
        groups ``i`` and ``j``.

    The object has the following methods:

    confidence_interval(confidence_level=0.95):
        Compute the confidence interval for the specified confidence level.

See Also
--------
dunnett : performs comparison of means against a control group.

Notes
-----
The use of this test relies on several assumptions.

1. The observations are independent within and among groups.
2. The observations within each group are normally distributed.
3. The distributions from which the samples are drawn have the same finite
   variance.

The original formulation of the test was for samples of equal size [6]_.
In case of unequal sample sizes, the test uses the Tukey-Kramer method
[4]_.

References
----------
.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, "7.4.7.1. Tukey's
       Method."
       https://www.itl.nist.gov/div898/handbook/prc/section4/prc471.htm,
       28 November 2020.
.. [2] Abdi, Herve & Williams, Lynne. (2021). "Tukey's Honestly Significant
       Difference (HSD) Test."
       https://personal.utdallas.edu/~herve/abdi-HSD2010-pretty.pdf
.. [3] "One-Way ANOVA Using SAS PROC ANOVA & PROC GLM." SAS
       Tutorials, 2007, www.stattutorials.com/SAS/TUTORIAL-PROC-GLM.htm.
.. [4] Kramer, Clyde Young. "Extension of Multiple Range Tests to Group
       Means with Unequal Numbers of Replications." Biometrics, vol. 12,
       no. 3, 1956, pp. 307-310. JSTOR, www.jstor.org/stable/3001469.
       Accessed 25 May 2021.
.. [5] NIST/SEMATECH e-Handbook of Statistical Methods, "7.4.3.3.
       The ANOVA table and tests of hypotheses about means"
       https://www.itl.nist.gov/div898/handbook/prc/section4/prc433.htm,
       2 June 2021.
.. [6] Tukey, John W. "Comparing Individual Means in the Analysis of
       Variance." Biometrics, vol. 5, no. 2, 1949, pp. 99-114. JSTOR,
       www.jstor.org/stable/3001913. Accessed 14 June 2021.


Examples
--------
Here are some data comparing the time to relief of three brands of
headache medicine, reported in minutes. Data adapted from [3]_.

>>> import numpy as np
>>> from scipy.stats import tukey_hsd
>>> group0 = [24.5, 23.5, 26.4, 27.1, 29.9]
>>> group1 = [28.4, 34.2, 29.5, 32.2, 30.1]
>>> group2 = [26.1, 28.3, 24.3, 26.2, 27.8]

We would like to see if the means between any of the groups are
significantly different. First, visually examine a box and whisker plot.

>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)
>>> ax.boxplot([group0, group1, group2])
>>> ax.set_xticklabels(["group0", "group1", "group2"]) # doctest: +SKIP
>>> ax.set_ylabel("mean") # doctest: +SKIP
>>> plt.show()

From the box and whisker plot, we can see overlap in the interquartile
ranges group 1 to group 2 and group 3, but we can apply the ``tukey_hsd``
test to determine if the difference between means is significant. We
set a significance level of .05 to reject the null hypothesis.

>>> res = tukey_hsd(group0, group1, group2)
>>> print(res)
Tukey's HSD Pairwise Group Comparisons (95.0% Confidence Interval)
Comparison  Statistic  p-value   Lower CI   Upper CI
(0 - 1)     -4.600      0.014     -8.249     -0.951
(0 - 2)     -0.260      0.980     -3.909      3.389
(1 - 0)      4.600      0.014      0.951      8.249
(1 - 2)      4.340      0.020      0.691      7.989
(2 - 0)      0.260      0.980     -3.389      3.909
(2 - 1)     -4.340      0.020     -7.989     -0.691

The null hypothesis is that each group has the same mean. The p-value for
comparisons between ``group0`` and ``group1`` as well as ``group1`` and
``group2`` do not exceed .05, so we reject the null hypothesis that they
have the same means. The p-value of the comparison between ``group0``
and ``group2`` exceeds .05, so we accept the null hypothesis that there
is not a significant difference between their means.

We can also compute the confidence interval associated with our chosen
confidence level.

>>> group0 = [24.5, 23.5, 26.4, 27.1, 29.9]
>>> group1 = [28.4, 34.2, 29.5, 32.2, 30.1]
>>> group2 = [26.1, 28.3, 24.3, 26.2, 27.8]
>>> result = tukey_hsd(group0, group1, group2)
>>> conf = res.confidence_interval(confidence_level=.99)
>>> for ((i, j), l) in np.ndenumerate(conf.low):
...     # filter out self comparisons
...     if i != j:
...         h = conf.high[i,j]
...         print(f"({i} - {j}) {l:>6.3f} {h:>6.3f}")
(0 - 1) -9.480  0.280
(0 - 2) -5.140  4.620
(1 - 0) -0.280  9.480
(1 - 2) -0.540  9.220
(2 - 0) -4.620  5.140
(2 - 1) -9.220  0.540
================================================================================

tukeylambda:
Firma: (*args, **kwds)

Docstring:
A Tukey-Lamdba continuous random variable.

As an instance of the `rv_continuous` class, `tukeylambda` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(lam, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, lam, loc=0, scale=1)
    Probability density function.
logpdf(x, lam, loc=0, scale=1)
    Log of the probability density function.
cdf(x, lam, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, lam, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, lam, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, lam, loc=0, scale=1)
    Log of the survival function.
ppf(q, lam, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, lam, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, lam, loc=0, scale=1)
    Non-central moment of the specified order.
stats(lam, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(lam, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(lam,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(lam, loc=0, scale=1)
    Median of the distribution.
mean(lam, loc=0, scale=1)
    Mean of the distribution.
var(lam, loc=0, scale=1)
    Variance of the distribution.
std(lam, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, lam, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
A flexible distribution, able to represent and interpolate between the
following distributions:

- Cauchy                (:math:`lambda = -1`)
- logistic              (:math:`lambda = 0`)
- approx Normal         (:math:`lambda = 0.14`)
- uniform from -1 to 1  (:math:`lambda = 1`)

`tukeylambda` takes a real number :math:`lambda` (denoted ``lam``
in the implementation) as a shape parameter.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``tukeylambda.pdf(x, lam, loc, scale)`` is identically
equivalent to ``tukeylambda.pdf(y, lam) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import tukeylambda
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> lam = 3.13
>>> mean, var, skew, kurt = tukeylambda.stats(lam, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(tukeylambda.ppf(0.01, lam),
...                 tukeylambda.ppf(0.99, lam), 100)
>>> ax.plot(x, tukeylambda.pdf(x, lam),
...        'r-', lw=5, alpha=0.6, label='tukeylambda pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = tukeylambda(lam)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = tukeylambda.ppf([0.001, 0.5, 0.999], lam)
>>> np.allclose([0.001, 0.5, 0.999], tukeylambda.cdf(vals, lam))
True

Generate random numbers:

>>> r = tukeylambda.rvs(lam, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

tvar:
Firma: (a, limits=None, inclusive=(True, True), axis=0, ddof=1, *, nan_policy='propagate', keepdims=False)

Docstring:
Compute the trimmed variance.

This function computes the sample variance of an array of values,
while ignoring values which are outside of given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
tvar : float
    Trimmed variance.

Notes
-----
`tvar` computes the unbiased sample variance, i.e. it uses a correction
factor ``n / (n - 1)``.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.tvar(x)
35.0
>>> stats.tvar(x, (3,17))
20.0
================================================================================

uniform:
Firma: (*args, **kwds)

Docstring:
A uniform continuous random variable.

In the standard form, the distribution is uniform on ``[0, 1]``. Using
the parameters ``loc`` and ``scale``, one obtains the uniform distribution
on ``[loc, loc + scale]``.

As an instance of the `rv_continuous` class, `uniform` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import uniform
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = uniform.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(uniform.ppf(0.01),
...                 uniform.ppf(0.99), 100)
>>> ax.plot(x, uniform.pdf(x),
...        'r-', lw=5, alpha=0.6, label='uniform pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = uniform()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = uniform.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], uniform.cdf(vals))
True

Generate random numbers:

>>> r = uniform.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

uniform_direction:
Firma: (dim=None, seed=None)

Docstring:
A vector-valued uniform direction.

Return a random direction (unit vector). The `dim` keyword specifies
the dimensionality of the space.

Methods
-------
rvs(dim=None, size=1, random_state=None)
    Draw random directions.

Parameters
----------
dim : scalar
    Dimension of directions.
seed : {None, int, `numpy.random.Generator`,
        `numpy.random.RandomState`}, optional

    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
This distribution generates unit vectors uniformly distributed on
the surface of a hypersphere. These can be interpreted as random
directions.
For example, if `dim` is 3, 3D vectors from the surface of :math:`S^2`
will be sampled.

References
----------
.. [1] Marsaglia, G. (1972). "Choosing a Point from the Surface of a
       Sphere". Annals of Mathematical Statistics. 43 (2): 645-646.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import uniform_direction
>>> x = uniform_direction.rvs(3)
>>> np.linalg.norm(x)
1.

This generates one random direction, a vector on the surface of
:math:`S^2`.

Alternatively, the object may be called (as a function) to return a frozen
distribution with fixed `dim` parameter. Here,
we create a `uniform_direction` with ``dim=3`` and draw 5 observations.
The samples are then arranged in an array of shape 5x3.

>>> rng = np.random.default_rng()
>>> uniform_sphere_dist = uniform_direction(3)
>>> unit_vectors = uniform_sphere_dist.rvs(5, random_state=rng)
>>> unit_vectors
array([[ 0.56688642, -0.1332634 , -0.81294566],
       [-0.427126  , -0.74779278,  0.50830044],
       [ 0.3793989 ,  0.92346629,  0.05715323],
       [ 0.36428383, -0.92449076, -0.11231259],
       [-0.27733285,  0.94410968, -0.17816678]])
================================================================================

unitary_group:
Firma: (dim=None, seed=None)

Docstring:
A matrix-valued U(N) random variable.

Return a random unitary matrix.

The `dim` keyword specifies the dimension N.

Methods
-------
rvs(dim=None, size=1, random_state=None)
    Draw random samples from U(N).

Parameters
----------
dim : scalar
    Dimension of matrices, must be greater than 1.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Notes
-----
This class is similar to `ortho_group`.

References
----------
.. [1] F. Mezzadri, "How to generate random matrices from the classical
       compact groups", :arXiv:`math-ph/0609050v2`.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import unitary_group
>>> x = unitary_group.rvs(3)

>>> np.dot(x, x.conj().T)
array([[  1.00000000e+00,   1.13231364e-17,  -2.86852790e-16],
       [  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],
       [ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])  # may vary

This generates one random matrix from U(3). The dot product confirms that
it is unitary up to machine precision.

Alternatively, the object may be called (as a function) to fix the `dim`
parameter, return a "frozen" unitary_group random variable:

>>> rv = unitary_group(5)

See Also
--------
ortho_group
================================================================================

variation:
Firma: (a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False)

Docstring:
Compute the coefficient of variation.

The coefficient of variation is the standard deviation divided by the
mean.  This function is equivalent to::

    np.std(x, axis=axis, ddof=ddof) / np.mean(x)

The default for ``ddof`` is 0, but many definitions of the coefficient
of variation use the square root of the unbiased sample variance
for the sample standard deviation, which corresponds to ``ddof=1``.

The function does not take the absolute value of the mean of the data,
so the return value is negative if the mean is negative.

Parameters
----------
a : array_like
    Input array.
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
ddof : int, optional
    Gives the "Delta Degrees Of Freedom" used when computing the
    standard deviation.  The divisor used in the calculation of the
    standard deviation is ``N - ddof``, where ``N`` is the number of
    elements.  `ddof` must be less than ``N``; if it isn't, the result
    will be ``nan`` or ``inf``, depending on ``N`` and the values in
    the array.  By default `ddof` is zero for backwards compatibility,
    but it is recommended to use ``ddof=1`` to ensure that the sample
    standard deviation is computed as the square root of the unbiased
    sample variance.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
variation : ndarray
    The calculated variation along the requested axis.

Notes
-----
There are several edge cases that are handled without generating a
warning:

* If both the mean and the standard deviation are zero, ``nan``
  is returned.
* If the mean is zero and the standard deviation is nonzero, ``inf``
  is returned.
* If the input has length zero (either because the array has zero
  length, or all the input values are ``nan`` and ``nan_policy`` is
  ``'omit'``), ``nan`` is returned.
* If the input contains ``inf``, ``nan`` is returned.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import variation
>>> variation([1, 2, 3, 4, 5], ddof=1)
0.5270462766947299

Compute the variation along a given dimension of an array that contains
a few ``nan`` values:

>>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],
...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],
...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])
>>> variation(x, axis=1, ddof=1, nan_policy='omit')
array([1.05109361, 0.31428986, 0.146483  ])
================================================================================

vonmises:
Firma: (*args, **kwds)

Docstring:
A Von Mises continuous random variable.

As an instance of the `rv_continuous` class, `vonmises` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(kappa, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, kappa, loc=0, scale=1)
    Probability density function.
logpdf(x, kappa, loc=0, scale=1)
    Log of the probability density function.
cdf(x, kappa, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, kappa, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, kappa, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, kappa, loc=0, scale=1)
    Log of the survival function.
ppf(q, kappa, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, kappa, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, kappa, loc=0, scale=1)
    Non-central moment of the specified order.
stats(kappa, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(kappa, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(kappa,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(kappa, loc=0, scale=1)
    Median of the distribution.
mean(kappa, loc=0, scale=1)
    Mean of the distribution.
var(kappa, loc=0, scale=1)
    Variance of the distribution.
std(kappa, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, kappa, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
scipy.stats.vonmises_fisher : Von-Mises Fisher distribution on a
                              hypersphere

Notes
-----
The probability density function for `vonmises` and `vonmises_line` is:

.. math::

    f(x, \kappa) = \frac{ \exp(\kappa \cos(x)) }{ 2 \pi I_0(\kappa) }

for :math:`-\pi \le x \le \pi`, :math:`\kappa \ge 0`. :math:`I_0` is the
modified Bessel function of order zero (`scipy.special.i0`).

`vonmises` is a circular distribution which does not restrict the
distribution to a fixed interval. Currently, there is no circular
distribution framework in SciPy. The ``cdf`` is implemented such that
``cdf(x + 2*np.pi) == cdf(x) + 1``.

`vonmises_line` is the same distribution, defined on :math:`[-\pi, \pi]`
on the real line. This is a regular (i.e. non-circular) distribution.

Note about distribution parameters: `vonmises` and `vonmises_line` take
``kappa`` as a shape parameter (concentration) and ``loc`` as the location
(circular mean). A ``scale`` parameter is accepted but does not have any
effect.

Examples
--------
Import the necessary modules.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import vonmises

Define distribution parameters.

>>> loc = 0.5 * np.pi  # circular mean
>>> kappa = 1  # concentration

Compute the probability density at ``x=0`` via the ``pdf`` method.

>>> vonmises.pdf(0, loc=loc, kappa=kappa)
0.12570826359722018

Verify that the percentile function ``ppf`` inverts the cumulative
distribution function ``cdf`` up to floating point accuracy.

>>> x = 1
>>> cdf_value = vonmises.cdf(x, loc=loc, kappa=kappa)
>>> ppf_value = vonmises.ppf(cdf_value, loc=loc, kappa=kappa)
>>> x, cdf_value, ppf_value
(1, 0.31489339900904967, 1.0000000000000004)

Draw 1000 random variates by calling the ``rvs`` method.

>>> sample_size = 1000
>>> sample = vonmises(loc=loc, kappa=kappa).rvs(sample_size)

Plot the von Mises density on a Cartesian and polar grid to emphasize
that it is a circular distribution.

>>> fig = plt.figure(figsize=(12, 6))
>>> left = plt.subplot(121)
>>> right = plt.subplot(122, projection='polar')
>>> x = np.linspace(-np.pi, np.pi, 500)
>>> vonmises_pdf = vonmises.pdf(x, loc=loc, kappa=kappa)
>>> ticks = [0, 0.15, 0.3]

The left image contains the Cartesian plot.

>>> left.plot(x, vonmises_pdf)
>>> left.set_yticks(ticks)
>>> number_of_bins = int(np.sqrt(sample_size))
>>> left.hist(sample, density=True, bins=number_of_bins)
>>> left.set_title("Cartesian plot")
>>> left.set_xlim(-np.pi, np.pi)
>>> left.grid(True)

The right image contains the polar plot.

>>> right.plot(x, vonmises_pdf, label="PDF")
>>> right.set_yticks(ticks)
>>> right.hist(sample, density=True, bins=number_of_bins,
...            label="Histogram")
>>> right.set_title("Polar plot")
>>> right.legend(bbox_to_anchor=(0.15, 1.06))
================================================================================

vonmises_fisher:
Firma: (mu=None, kappa=1, seed=None)

Docstring:
A von Mises-Fisher variable.

The `mu` keyword specifies the mean direction vector. The `kappa` keyword
specifies the concentration parameter.

Methods
-------
pdf(x, mu=None, kappa=1)
    Probability density function.
logpdf(x, mu=None, kappa=1)
    Log of the probability density function.
rvs(mu=None, kappa=1, size=1, random_state=None)
    Draw random samples from a von Mises-Fisher distribution.
entropy(mu=None, kappa=1)
    Compute the differential entropy of the von Mises-Fisher distribution.
fit(data)
    Fit a von Mises-Fisher distribution to data.

Parameters
----------
mu : array_like
    Mean direction of the distribution. Must be a one-dimensional unit
    vector of norm 1.
kappa : float
    Concentration parameter. Must be positive.
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

See Also
--------
scipy.stats.vonmises : Von-Mises Fisher distribution in 2D on a circle
uniform_direction : uniform distribution on the surface of a hypersphere

Notes
-----
The von Mises-Fisher distribution is a directional distribution on the
surface of the unit hypersphere. The probability density
function of a unit vector :math:`\mathbf{x}` is

.. math::

    f(\mathbf{x}) = \frac{\kappa^{d/2-1}}{(2\pi)^{d/2}I_{d/2-1}(\kappa)}
           \exp\left(\kappa \mathbf{\mu}^T\mathbf{x}\right),

where :math:`\mathbf{\mu}` is the mean direction, :math:`\kappa` the
concentration parameter, :math:`d` the dimension and :math:`I` the
modified Bessel function of the first kind. As :math:`\mu` represents
a direction, it must be a unit vector or in other words, a point
on the hypersphere: :math:`\mathbf{\mu}\in S^{d-1}`. :math:`\kappa` is a
concentration parameter, which means that it must be positive
(:math:`\kappa>0`) and that the distribution becomes more narrow with
increasing :math:`\kappa`. In that sense, the reciprocal value
:math:`1/\kappa` resembles the variance parameter of the normal
distribution.

The von Mises-Fisher distribution often serves as an analogue of the
normal distribution on the sphere. Intuitively, for unit vectors, a
useful distance measure is given by the angle :math:`\alpha` between
them. This is exactly what the scalar product
:math:`\mathbf{\mu}^T\mathbf{x}=\cos(\alpha)` in the
von Mises-Fisher probability density function describes: the angle
between the mean direction :math:`\mathbf{\mu}` and the vector
:math:`\mathbf{x}`. The larger the angle between them, the smaller the
probability to observe :math:`\mathbf{x}` for this particular mean
direction :math:`\mathbf{\mu}`.

In dimensions 2 and 3, specialized algorithms are used for fast sampling
[2]_, [3]_. For dimensions of 4 or higher the rejection sampling algorithm
described in [4]_ is utilized. This implementation is partially based on
the geomstats package [5]_, [6]_.

.. versionadded:: 1.11

References
----------
.. [1] Von Mises-Fisher distribution, Wikipedia,
       https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution
.. [2] Mardia, K., and Jupp, P. Directional statistics. Wiley, 2000.
.. [3] J. Wenzel. Numerically stable sampling of the von Mises Fisher
       distribution on S2.
       https://www.mitsuba-renderer.org/~wenzel/files/vmf.pdf
.. [4] Wood, A. Simulation of the von mises fisher distribution.
       Communications in statistics-simulation and computation 23,
       1 (1994), 157-164. https://doi.org/10.1080/03610919408813161
.. [5] geomstats, Github. MIT License. Accessed: 06.01.2023.
       https://github.com/geomstats/geomstats
.. [6] Miolane, N. et al. Geomstats:  A Python Package for Riemannian
       Geometry in Machine Learning. Journal of Machine Learning Research
       21 (2020). http://jmlr.org/papers/v21/19-027.html

Examples
--------
**Visualization of the probability density**

Plot the probability density in three dimensions for increasing
concentration parameter. The density is calculated by the ``pdf``
method.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import vonmises_fisher
>>> from matplotlib.colors import Normalize
>>> n_grid = 100
>>> u = np.linspace(0, np.pi, n_grid)
>>> v = np.linspace(0, 2 * np.pi, n_grid)
>>> u_grid, v_grid = np.meshgrid(u, v)
>>> vertices = np.stack([np.cos(v_grid) * np.sin(u_grid),
...                      np.sin(v_grid) * np.sin(u_grid),
...                      np.cos(u_grid)],
...                     axis=2)
>>> x = np.outer(np.cos(v), np.sin(u))
>>> y = np.outer(np.sin(v), np.sin(u))
>>> z = np.outer(np.ones_like(u), np.cos(u))
>>> def plot_vmf_density(ax, x, y, z, vertices, mu, kappa):
...     vmf = vonmises_fisher(mu, kappa)
...     pdf_values = vmf.pdf(vertices)
...     pdfnorm = Normalize(vmin=pdf_values.min(), vmax=pdf_values.max())
...     ax.plot_surface(x, y, z, rstride=1, cstride=1,
...                     facecolors=plt.cm.viridis(pdfnorm(pdf_values)),
...                     linewidth=0)
...     ax.set_aspect('equal')
...     ax.view_init(azim=-130, elev=0)
...     ax.axis('off')
...     ax.set_title(rf"$\kappa={kappa}$")
>>> fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(9, 4),
...                          subplot_kw={"projection": "3d"})
>>> left, middle, right = axes
>>> mu = np.array([-np.sqrt(0.5), -np.sqrt(0.5), 0])
>>> plot_vmf_density(left, x, y, z, vertices, mu, 5)
>>> plot_vmf_density(middle, x, y, z, vertices, mu, 20)
>>> plot_vmf_density(right, x, y, z, vertices, mu, 100)
>>> plt.subplots_adjust(top=1, bottom=0.0, left=0.0, right=1.0, wspace=0.)
>>> plt.show()

As we increase the concentration parameter, the points are getting more
clustered together around the mean direction.

**Sampling**

Draw 5 samples from the distribution using the ``rvs`` method resulting
in a 5x3 array.

>>> rng = np.random.default_rng()
>>> mu = np.array([0, 0, 1])
>>> samples = vonmises_fisher(mu, 20).rvs(5, random_state=rng)
>>> samples
array([[ 0.3884594 , -0.32482588,  0.86231516],
       [ 0.00611366, -0.09878289,  0.99509023],
       [-0.04154772, -0.01637135,  0.99900239],
       [-0.14613735,  0.12553507,  0.98126695],
       [-0.04429884, -0.23474054,  0.97104814]])

These samples are unit vectors on the sphere :math:`S^2`. To verify,
let us calculate their euclidean norms:

>>> np.linalg.norm(samples, axis=1)
array([1., 1., 1., 1., 1.])

Plot 20 observations drawn from the von Mises-Fisher distribution for
increasing concentration parameter :math:`\kappa`. The red dot highlights
the mean direction :math:`\mu`.

>>> def plot_vmf_samples(ax, x, y, z, mu, kappa):
...     vmf = vonmises_fisher(mu, kappa)
...     samples = vmf.rvs(20)
...     ax.plot_surface(x, y, z, rstride=1, cstride=1, linewidth=0,
...                     alpha=0.2)
...     ax.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c='k', s=5)
...     ax.scatter(mu[0], mu[1], mu[2], c='r', s=30)
...     ax.set_aspect('equal')
...     ax.view_init(azim=-130, elev=0)
...     ax.axis('off')
...     ax.set_title(rf"$\kappa={kappa}$")
>>> mu = np.array([-np.sqrt(0.5), -np.sqrt(0.5), 0])
>>> fig, axes = plt.subplots(nrows=1, ncols=3,
...                          subplot_kw={"projection": "3d"},
...                          figsize=(9, 4))
>>> left, middle, right = axes
>>> plot_vmf_samples(left, x, y, z, mu, 5)
>>> plot_vmf_samples(middle, x, y, z, mu, 20)
>>> plot_vmf_samples(right, x, y, z, mu, 100)
>>> plt.subplots_adjust(top=1, bottom=0.0, left=0.0,
...                     right=1.0, wspace=0.)
>>> plt.show()

The plots show that with increasing concentration :math:`\kappa` the
resulting samples are centered more closely around the mean direction.

**Fitting the distribution parameters**

The distribution can be fitted to data using the ``fit`` method returning
the estimated parameters. As a toy example let's fit the distribution to
samples drawn from a known von Mises-Fisher distribution.

>>> mu, kappa = np.array([0, 0, 1]), 20
>>> samples = vonmises_fisher(mu, kappa).rvs(1000, random_state=rng)
>>> mu_fit, kappa_fit = vonmises_fisher.fit(samples)
>>> mu_fit, kappa_fit
(array([0.01126519, 0.01044501, 0.99988199]), 19.306398751730995)

We see that the estimated parameters `mu_fit` and `kappa_fit` are
very close to the ground truth parameters.
================================================================================

vonmises_line:
Firma: (*args, **kwds)

Docstring:
A Von Mises continuous random variable.

As an instance of the `rv_continuous` class, `vonmises_line` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(kappa, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, kappa, loc=0, scale=1)
    Probability density function.
logpdf(x, kappa, loc=0, scale=1)
    Log of the probability density function.
cdf(x, kappa, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, kappa, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, kappa, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, kappa, loc=0, scale=1)
    Log of the survival function.
ppf(q, kappa, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, kappa, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, kappa, loc=0, scale=1)
    Non-central moment of the specified order.
stats(kappa, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(kappa, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(kappa,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(kappa, loc=0, scale=1)
    Median of the distribution.
mean(kappa, loc=0, scale=1)
    Mean of the distribution.
var(kappa, loc=0, scale=1)
    Variance of the distribution.
std(kappa, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, kappa, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
scipy.stats.vonmises_fisher : Von-Mises Fisher distribution on a
                              hypersphere

Notes
-----
The probability density function for `vonmises` and `vonmises_line` is:

.. math::

    f(x, \kappa) = \frac{ \exp(\kappa \cos(x)) }{ 2 \pi I_0(\kappa) }

for :math:`-\pi \le x \le \pi`, :math:`\kappa \ge 0`. :math:`I_0` is the
modified Bessel function of order zero (`scipy.special.i0`).

`vonmises` is a circular distribution which does not restrict the
distribution to a fixed interval. Currently, there is no circular
distribution framework in SciPy. The ``cdf`` is implemented such that
``cdf(x + 2*np.pi) == cdf(x) + 1``.

`vonmises_line` is the same distribution, defined on :math:`[-\pi, \pi]`
on the real line. This is a regular (i.e. non-circular) distribution.

Note about distribution parameters: `vonmises` and `vonmises_line` take
``kappa`` as a shape parameter (concentration) and ``loc`` as the location
(circular mean). A ``scale`` parameter is accepted but does not have any
effect.

Examples
--------
Import the necessary modules.

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import vonmises

Define distribution parameters.

>>> loc = 0.5 * np.pi  # circular mean
>>> kappa = 1  # concentration

Compute the probability density at ``x=0`` via the ``pdf`` method.

>>> vonmises.pdf(0, loc=loc, kappa=kappa)
0.12570826359722018

Verify that the percentile function ``ppf`` inverts the cumulative
distribution function ``cdf`` up to floating point accuracy.

>>> x = 1
>>> cdf_value = vonmises.cdf(x, loc=loc, kappa=kappa)
>>> ppf_value = vonmises.ppf(cdf_value, loc=loc, kappa=kappa)
>>> x, cdf_value, ppf_value
(1, 0.31489339900904967, 1.0000000000000004)

Draw 1000 random variates by calling the ``rvs`` method.

>>> sample_size = 1000
>>> sample = vonmises(loc=loc, kappa=kappa).rvs(sample_size)

Plot the von Mises density on a Cartesian and polar grid to emphasize
that it is a circular distribution.

>>> fig = plt.figure(figsize=(12, 6))
>>> left = plt.subplot(121)
>>> right = plt.subplot(122, projection='polar')
>>> x = np.linspace(-np.pi, np.pi, 500)
>>> vonmises_pdf = vonmises.pdf(x, loc=loc, kappa=kappa)
>>> ticks = [0, 0.15, 0.3]

The left image contains the Cartesian plot.

>>> left.plot(x, vonmises_pdf)
>>> left.set_yticks(ticks)
>>> number_of_bins = int(np.sqrt(sample_size))
>>> left.hist(sample, density=True, bins=number_of_bins)
>>> left.set_title("Cartesian plot")
>>> left.set_xlim(-np.pi, np.pi)
>>> left.grid(True)

The right image contains the polar plot.

>>> right.plot(x, vonmises_pdf, label="PDF")
>>> right.set_yticks(ticks)
>>> right.hist(sample, density=True, bins=number_of_bins,
...            label="Histogram")
>>> right.set_title("Polar plot")
>>> right.legend(bbox_to_anchor=(0.15, 1.06))
================================================================================

wald:
Firma: (*args, **kwds)

Docstring:
A Wald continuous random variable.

As an instance of the `rv_continuous` class, `wald` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, loc=0, scale=1)
    Probability density function.
logpdf(x, loc=0, scale=1)
    Log of the probability density function.
cdf(x, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, loc=0, scale=1)
    Log of the survival function.
ppf(q, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, loc=0, scale=1)
    Non-central moment of the specified order.
stats(loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(loc=0, scale=1)
    Median of the distribution.
mean(loc=0, scale=1)
    Mean of the distribution.
var(loc=0, scale=1)
    Variance of the distribution.
std(loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `wald` is:

.. math::

    f(x) = \frac{1}{\sqrt{2\pi x^3}} \exp(- \frac{ (x-1)^2 }{ 2x })

for :math:`x >= 0`.

`wald` is a special case of `invgauss` with ``mu=1``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``wald.pdf(x, loc, scale)`` is identically
equivalent to ``wald.pdf(y) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import wald
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:


>>> mean, var, skew, kurt = wald.stats(moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(wald.ppf(0.01),
...                 wald.ppf(0.99), 100)
>>> ax.plot(x, wald.pdf(x),
...        'r-', lw=5, alpha=0.6, label='wald pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = wald()
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = wald.ppf([0.001, 0.5, 0.999])
>>> np.allclose([0.001, 0.5, 0.999], wald.cdf(vals))
True

Generate random numbers:

>>> r = wald.rvs(size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

wasserstein_distance:
Firma: (u_values, v_values, u_weights=None, v_weights=None)

Docstring:
Compute the Wasserstein-1 distance between two 1D discrete distributions.

The Wasserstein distance, also called the Earth mover's distance or the
optimal transport distance, is a similarity metric between two probability
distributions [1]_. In the discrete case, the Wasserstein distance can be
understood as the cost of an optimal transport plan to convert one
distribution into the other. The cost is calculated as the product of the
amount of probability mass being moved and the distance it is being moved.
A brief and intuitive introduction can be found at [2]_.

.. versionadded:: 1.0.0

Parameters
----------
u_values : 1d array_like
    A sample from a probability distribution or the support (set of all
    possible values) of a probability distribution. Each element is an
    observation or possible value.

v_values : 1d array_like
    A sample from or the support of a second distribution.

u_weights, v_weights : 1d array_like, optional
    Weights or counts corresponding with the sample or probability masses
    corresponding with the support values. Sum of elements must be positive
    and finite. If unspecified, each value is assigned the same weight.

Returns
-------
distance : float
    The computed distance between the distributions.

Notes
-----
Given two 1D probability mass functions, :math:`u` and :math:`v`, the first
Wasserstein distance between the distributions is:

.. math::

    l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int_{\mathbb{R} \times
    \mathbb{R}} |x-y| \mathrm{d} \pi (x, y)

where :math:`\Gamma (u, v)` is the set of (probability) distributions on
:math:`\mathbb{R} \times \mathbb{R}` whose marginals are :math:`u` and
:math:`v` on the first and second factors respectively. For a given value
:math:`x`, :math:`u(x)` gives the probability of :math:`u` at position
:math:`x`, and the same for :math:`v(x)`.

If :math:`U` and :math:`V` are the respective CDFs of :math:`u` and
:math:`v`, this distance also equals to:

.. math::

    l_1(u, v) = \int_{-\infty}^{+\infty} |U-V|

See [3]_ for a proof of the equivalence of both definitions.

The input distributions can be empirical, therefore coming from samples
whose values are effectively inputs of the function, or they can be seen as
generalized functions, in which case they are weighted sums of Dirac delta
functions located at the specified values.

References
----------
.. [1] "Wasserstein metric", https://en.wikipedia.org/wiki/Wasserstein_metric
.. [2] Lili Weng, "What is Wasserstein distance?", Lil'log,
       https://lilianweng.github.io/posts/2017-08-20-gan/#what-is-wasserstein-distance.
.. [3] Ramdas, Garcia, Cuturi "On Wasserstein Two Sample Testing and Related
       Families of Nonparametric Tests" (2015). :arXiv:`1509.02237`.

See Also
--------
wasserstein_distance_nd: Compute the Wasserstein-1 distance between two N-D
    discrete distributions.

Examples
--------
>>> from scipy.stats import wasserstein_distance
>>> wasserstein_distance([0, 1, 3], [5, 6, 8])
5.0
>>> wasserstein_distance([0, 1], [0, 1], [3, 1], [2, 2])
0.25
>>> wasserstein_distance([3.4, 3.9, 7.5, 7.8], [4.5, 1.4],
...                      [1.4, 0.9, 3.1, 7.2], [3.2, 3.5])
4.0781331438047861
================================================================================

wasserstein_distance_nd:
Firma: (u_values, v_values, u_weights=None, v_weights=None)

Docstring:
Compute the Wasserstein-1 distance between two N-D discrete distributions.

The Wasserstein distance, also called the Earth mover's distance or the
optimal transport distance, is a similarity metric between two probability
distributions [1]_. In the discrete case, the Wasserstein distance can be
understood as the cost of an optimal transport plan to convert one
distribution into the other. The cost is calculated as the product of the
amount of probability mass being moved and the distance it is being moved.
A brief and intuitive introduction can be found at [2]_.

.. versionadded:: 1.13.0

Parameters
----------
u_values : 2d array_like
    A sample from a probability distribution or the support (set of all
    possible values) of a probability distribution. Each element along
    axis 0 is an observation or possible value, and axis 1 represents the
    dimensionality of the distribution; i.e., each row is a vector
    observation or possible value.

v_values : 2d array_like
    A sample from or the support of a second distribution.

u_weights, v_weights : 1d array_like, optional
    Weights or counts corresponding with the sample or probability masses
    corresponding with the support values. Sum of elements must be positive
    and finite. If unspecified, each value is assigned the same weight.

Returns
-------
distance : float
    The computed distance between the distributions.

Notes
-----
Given two probability mass functions, :math:`u`
and :math:`v`, the first Wasserstein distance between the distributions
using the Euclidean norm is:

.. math::

    l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int \| x-y \|_2 \mathrm{d} \pi (x, y)

where :math:`\Gamma (u, v)` is the set of (probability) distributions on
:math:`\mathbb{R}^n \times \mathbb{R}^n` whose marginals are :math:`u` and
:math:`v` on the first and second factors respectively. For a given value
:math:`x`, :math:`u(x)` gives the probability of :math:`u` at position
:math:`x`, and the same for :math:`v(x)`.

This is also called the optimal transport problem or the Monge problem.
Let the finite point sets :math:`\{x_i\}` and :math:`\{y_j\}` denote
the support set of probability mass function :math:`u` and :math:`v`
respectively. The Monge problem can be expressed as follows,

Let :math:`\Gamma` denote the transport plan, :math:`D` denote the
distance matrix and,

.. math::

    x = \text{vec}(\Gamma)          \\
    c = \text{vec}(D)               \\
    b = \begin{bmatrix}
            u\\
            v\\
        \end{bmatrix}

The :math:`\text{vec}()` function denotes the Vectorization function
that transforms a matrix into a column vector by vertically stacking
the columns of the matrix.
The transport plan :math:`\Gamma` is a matrix :math:`[\gamma_{ij}]` in
which :math:`\gamma_{ij}` is a positive value representing the amount of
probability mass transported from :math:`u(x_i)` to :math:`v(y_i)`.
Summing over the rows of :math:`\Gamma` should give the source distribution
:math:`u` : :math:`\sum_j \gamma_{ij} = u(x_i)` holds for all :math:`i`
and summing over the columns of :math:`\Gamma` should give the target
distribution :math:`v`: :math:`\sum_i \gamma_{ij} = v(y_j)` holds for all
:math:`j`.
The distance matrix :math:`D` is a matrix :math:`[d_{ij}]`, in which
:math:`d_{ij} = d(x_i, y_j)`.

Given :math:`\Gamma`, :math:`D`, :math:`b`, the Monge problem can be
transformed into a linear programming problem by
taking :math:`A x = b` as constraints and :math:`z = c^T x` as minimization
target (sum of costs) , where matrix :math:`A` has the form

.. math::

    \begin{array} {rrrr|rrrr|r|rrrr}
        1 & 1 & \dots & 1 & 0 & 0 & \dots & 0 & \dots & 0 & 0 & \dots &
            0 \cr
        0 & 0 & \dots & 0 & 1 & 1 & \dots & 1 & \dots & 0 & 0 &\dots &
            0 \cr
        \vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots
            & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots  \cr
        0 & 0 & \dots & 0 & 0 & 0 & \dots & 0 & \dots & 1 & 1 & \dots &
            1 \cr \hline

        1 & 0 & \dots & 0 & 1 & 0 & \dots & \dots & \dots & 1 & 0 & \dots &
            0 \cr
        0 & 1 & \dots & 0 & 0 & 1 & \dots & \dots & \dots & 0 & 1 & \dots &
            0 \cr
        \vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots &
            \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr
        0 & 0 & \dots & 1 & 0 & 0 & \dots & 1 & \dots & 0 & 0 & \dots & 1
    \end{array}

By solving the dual form of the above linear programming problem (with
solution :math:`y^*`), the Wasserstein distance :math:`l_1 (u, v)` can
be computed as :math:`b^T y^*`.

The above solution is inspired by Vincent Herrmann's blog [3]_ . For a
more thorough explanation, see [4]_ .

The input distributions can be empirical, therefore coming from samples
whose values are effectively inputs of the function, or they can be seen as
generalized functions, in which case they are weighted sums of Dirac delta
functions located at the specified values.

References
----------
.. [1] "Wasserstein metric",
       https://en.wikipedia.org/wiki/Wasserstein_metric
.. [2] Lili Weng, "What is Wasserstein distance?", Lil'log,
       https://lilianweng.github.io/posts/2017-08-20-gan/#what-is-wasserstein-distance.
.. [3] Hermann, Vincent. "Wasserstein GAN and the Kantorovich-Rubinstein
       Duality". https://vincentherrmann.github.io/blog/wasserstein/.
.. [4] Peyré, Gabriel, and Marco Cuturi. "Computational optimal
       transport." Center for Research in Economics and Statistics
       Working Papers 2017-86 (2017).

See Also
--------
wasserstein_distance: Compute the Wasserstein-1 distance between two
    1D discrete distributions.

Examples
--------
Compute the Wasserstein distance between two three-dimensional samples,
each with two observations.

>>> from scipy.stats import wasserstein_distance_nd
>>> wasserstein_distance_nd([[0, 2, 3], [1, 2, 5]], [[3, 2, 3], [4, 2, 5]])
3.0

Compute the Wasserstein distance between two two-dimensional distributions
with three and two weighted observations, respectively.

>>> wasserstein_distance_nd([[0, 2.75], [2, 209.3], [0, 0]],
...                      [[0.2, 0.322], [4.5, 25.1808]],
...                      [0.4, 5.2, 0.114], [0.8, 1.5])
174.15840245217169
================================================================================

weibull_max:
Firma: (*args, **kwds)

Docstring:
Weibull maximum continuous random variable.

The Weibull Maximum Extreme Value distribution, from extreme value theory
(Fisher-Gnedenko theorem), is the limiting distribution of rescaled
maximum of iid random variables. This is the distribution of -X
if X is from the `weibull_min` function.

As an instance of the `rv_continuous` class, `weibull_max` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
weibull_min

Notes
-----
The probability density function for `weibull_max` is:

.. math::

    f(x, c) = c (-x)^{c-1} \exp(-(-x)^c)

for :math:`x < 0`, :math:`c > 0`.

`weibull_max` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``weibull_max.pdf(x, c, loc, scale)`` is identically
equivalent to ``weibull_max.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
https://en.wikipedia.org/wiki/Weibull_distribution

https://en.wikipedia.org/wiki/Fisher-Tippett-Gnedenko_theorem

Examples
--------
>>> import numpy as np
>>> from scipy.stats import weibull_max
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 2.87
>>> mean, var, skew, kurt = weibull_max.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(weibull_max.ppf(0.01, c),
...                 weibull_max.ppf(0.99, c), 100)
>>> ax.plot(x, weibull_max.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='weibull_max pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = weibull_max(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = weibull_max.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], weibull_max.cdf(vals, c))
True

Generate random numbers:

>>> r = weibull_max.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

weibull_min:
Firma: (*args, **kwds)

Docstring:
Weibull minimum continuous random variable.

The Weibull Minimum Extreme Value distribution, from extreme value theory
(Fisher-Gnedenko theorem), is also often simply called the Weibull
distribution. It arises as the limiting distribution of the rescaled
minimum of iid random variables.

As an instance of the `rv_continuous` class, `weibull_min` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

See Also
--------
weibull_max, numpy.random.Generator.weibull, exponweib

Notes
-----
The probability density function for `weibull_min` is:

.. math::

    f(x, c) = c x^{c-1} \exp(-x^c)

for :math:`x > 0`, :math:`c > 0`.

`weibull_min` takes ``c`` as a shape parameter for :math:`c`.
(named :math:`k` in Wikipedia article and :math:`a` in
``numpy.random.weibull``).  Special shape values are :math:`c=1` and
:math:`c=2` where Weibull distribution reduces to the `expon` and
`rayleigh` distributions respectively.

Suppose ``X`` is an exponentially distributed random variable with
scale ``s``. Then ``Y = X**k`` is `weibull_min` distributed with shape
``c = 1/k`` and scale ``s**k``.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``weibull_min.pdf(x, c, loc, scale)`` is identically
equivalent to ``weibull_min.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

References
----------
https://en.wikipedia.org/wiki/Weibull_distribution

https://en.wikipedia.org/wiki/Fisher-Tippett-Gnedenko_theorem

Examples
--------
>>> import numpy as np
>>> from scipy.stats import weibull_min
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 1.79
>>> mean, var, skew, kurt = weibull_min.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(weibull_min.ppf(0.01, c),
...                 weibull_min.ppf(0.99, c), 100)
>>> ax.plot(x, weibull_min.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='weibull_min pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = weibull_min(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = weibull_min.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], weibull_min.cdf(vals, c))
True

Generate random numbers:

>>> r = weibull_min.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

weightedtau:
Firma: (x, y, rank=True, weigher=None, additive=True)

Docstring:
Compute a weighted version of Kendall's :math:`\tau`.

The weighted :math:`\tau` is a weighted version of Kendall's
:math:`\tau` in which exchanges of high weight are more influential than
exchanges of low weight. The default parameters compute the additive
hyperbolic version of the index, :math:`\tau_\mathrm h`, which has
been shown to provide the best balance between important and
unimportant elements [1]_.

The weighting is defined by means of a rank array, which assigns a
nonnegative rank to each element (higher importance ranks being
associated with smaller values, e.g., 0 is the highest possible rank),
and a weigher function, which assigns a weight based on the rank to
each element. The weight of an exchange is then the sum or the product
of the weights of the ranks of the exchanged elements. The default
parameters compute :math:`\tau_\mathrm h`: an exchange between
elements with rank :math:`r` and :math:`s` (starting from zero) has
weight :math:`1/(r+1) + 1/(s+1)`.

Specifying a rank array is meaningful only if you have in mind an
external criterion of importance. If, as it usually happens, you do
not have in mind a specific rank, the weighted :math:`\tau` is
defined by averaging the values obtained using the decreasing
lexicographical rank by (`x`, `y`) and by (`y`, `x`). This is the
behavior with default parameters. Note that the convention used
here for ranking (lower values imply higher importance) is opposite
to that used by other SciPy statistical functions.

Parameters
----------
x, y : array_like
    Arrays of scores, of the same shape. If arrays are not 1-D, they will
    be flattened to 1-D.
rank : array_like of ints or bool, optional
    A nonnegative rank assigned to each element. If it is None, the
    decreasing lexicographical rank by (`x`, `y`) will be used: elements of
    higher rank will be those with larger `x`-values, using `y`-values to
    break ties (in particular, swapping `x` and `y` will give a different
    result). If it is False, the element indices will be used
    directly as ranks. The default is True, in which case this
    function returns the average of the values obtained using the
    decreasing lexicographical rank by (`x`, `y`) and by (`y`, `x`).
weigher : callable, optional
    The weigher function. Must map nonnegative integers (zero
    representing the most important element) to a nonnegative weight.
    The default, None, provides hyperbolic weighing, that is,
    rank :math:`r` is mapped to weight :math:`1/(r+1)`.
additive : bool, optional
    If True, the weight of an exchange is computed by adding the
    weights of the ranks of the exchanged elements; otherwise, the weights
    are multiplied. The default is True.

Returns
-------
res: SignificanceResult
    An object containing attributes:

    statistic : float
       The weighted :math:`\tau` correlation index.
    pvalue : float
       Presently ``np.nan``, as the null distribution of the statistic is
       unknown (even in the additive hyperbolic case).

See Also
--------
kendalltau : Calculates Kendall's tau.
spearmanr : Calculates a Spearman rank-order correlation coefficient.
theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).

Notes
-----
This function uses an :math:`O(n \log n)`, mergesort-based algorithm
[1]_ that is a weighted extension of Knight's algorithm for Kendall's
:math:`\tau` [2]_. It can compute Shieh's weighted :math:`\tau` [3]_
between rankings without ties (i.e., permutations) by setting
`additive` and `rank` to False, as the definition given in [1]_ is a
generalization of Shieh's.

NaNs are considered the smallest possible score.

.. versionadded:: 0.19.0

References
----------
.. [1] Sebastiano Vigna, "A weighted correlation index for rankings with
       ties", Proceedings of the 24th international conference on World
       Wide Web, pp. 1166-1176, ACM, 2015.
.. [2] W.R. Knight, "A Computer Method for Calculating Kendall's Tau with
       Ungrouped Data", Journal of the American Statistical Association,
       Vol. 61, No. 314, Part 1, pp. 436-439, 1966.
.. [3] Grace S. Shieh. "A weighted Kendall's tau statistic", Statistics &
       Probability Letters, Vol. 39, No. 1, pp. 17-24, 1998.

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> x = [12, 2, 1, 12, 2]
>>> y = [1, 4, 7, 1, 0]
>>> res = stats.weightedtau(x, y)
>>> res.statistic
-0.56694968153682723
>>> res.pvalue
nan
>>> res = stats.weightedtau(x, y, additive=False)
>>> res.statistic
-0.62205716951801038

NaNs are considered the smallest possible score:

>>> x = [12, 2, 1, 12, 2]
>>> y = [1, 4, 7, 1, np.nan]
>>> res = stats.weightedtau(x, y)
>>> res.statistic
-0.56694968153682723

This is exactly Kendall's tau:

>>> x = [12, 2, 1, 12, 2]
>>> y = [1, 4, 7, 1, 0]
>>> res = stats.weightedtau(x, y, weigher=lambda x: 1)
>>> res.statistic
-0.47140452079103173

>>> x = [12, 2, 1, 12, 2]
>>> y = [1, 4, 7, 1, 0]
>>> stats.weightedtau(x, y, rank=None)
SignificanceResult(statistic=-0.4157652301037516, pvalue=nan)
>>> stats.weightedtau(y, x, rank=None)
SignificanceResult(statistic=-0.7181341329699028, pvalue=nan)
================================================================================

wilcoxon:
Firma: (x, y=None, zero_method='wilcox', correction=False, alternative='two-sided', method='auto', *, axis=0, nan_policy='propagate', keepdims=False)

Docstring:
Calculate the Wilcoxon signed-rank test.

The Wilcoxon signed-rank test tests the null hypothesis that two
related paired samples come from the same distribution. In particular,
it tests whether the distribution of the differences ``x - y`` is symmetric
about zero. It is a non-parametric version of the paired T-test.

Parameters
----------
x : array_like
    Either the first set of measurements (in which case ``y`` is the second
    set of measurements), or the differences between two sets of
    measurements (in which case ``y`` is not to be specified.)  Must be
    one-dimensional.
y : array_like, optional
    Either the second set of measurements (if ``x`` is the first set of
    measurements), or not specified (if ``x`` is the differences between
    two sets of measurements.)  Must be one-dimensional.
    
    .. warning::
        When `y` is provided, `wilcoxon` calculates the test statistic
        based on the ranks of the absolute values of ``d = x - y``.
        Roundoff error in the subtraction can result in elements of ``d``
        being assigned different ranks even when they would be tied with
        exact arithmetic. Rather than passing `x` and `y` separately,
        consider computing the difference ``x - y``, rounding as needed to
        ensure that only truly unique elements are numerically distinct,
        and passing the result as `x`, leaving `y` at the default (None).
zero_method : {"wilcox", "pratt", "zsplit"}, optional
    There are different conventions for handling pairs of observations
    with equal values ("zero-differences", or "zeros").
    
    * "wilcox": Discards all zero-differences (default); see [4]_.
    * "pratt": Includes zero-differences in the ranking process,
      but drops the ranks of the zeros (more conservative); see [3]_.
      In this case, the normal approximation is adjusted as in [5]_.
    * "zsplit": Includes zero-differences in the ranking process and
      splits the zero rank between positive and negative ones.
correction : bool, optional
    If True, apply continuity correction by adjusting the Wilcoxon rank
    statistic by 0.5 towards the mean value when computing the
    z-statistic if a normal approximation is used.  Default is False.
alternative : {"two-sided", "greater", "less"}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    In the following, let ``d`` represent the difference between the paired
    samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or
    ``d = x`` otherwise.
    
    * 'two-sided': the distribution underlying ``d`` is not symmetric
      about zero.
    * 'less': the distribution underlying ``d`` is stochastically less
      than a distribution symmetric about zero.
    * 'greater': the distribution underlying ``d`` is stochastically
      greater than a distribution symmetric about zero.
method : {"auto", "exact", "asymptotic"} or `PermutationMethod` instance, optional
    Method to calculate the p-value, see Notes. Default is "auto".
axis : int or None, default: 0
    If an int, the axis of the input along which to compute the statistic.
    The statistic of each axis-slice (e.g. row) of the input will appear in a
    corresponding element of the output.
    If ``None``, the input will be raveled before computing the statistic.
nan_policy : {'propagate', 'omit', 'raise'}
    Defines how to handle input NaNs.
    
    - ``propagate``: if a NaN is present in the axis slice (e.g. row) along
      which the  statistic is computed, the corresponding entry of the output
      will be NaN.
    - ``omit``: NaNs will be omitted when performing the calculation.
      If insufficient data remains in the axis slice along which the
      statistic is computed, the corresponding entry of the output will be
      NaN.
    - ``raise``: if a NaN is present, a ``ValueError`` will be raised.
keepdims : bool, default: False
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
An object with the following attributes.
statistic : array_like
    If `alternative` is "two-sided", the sum of the ranks of the
    differences above or below zero, whichever is smaller.
    Otherwise the sum of the ranks of the differences above zero.
pvalue : array_like
    The p-value for the test depending on `alternative` and `method`.
zstatistic : array_like
    When ``method = 'asymptotic'``, this is the normalized z-statistic::
    
        z = (T - mn - d) / se
    
    where ``T`` is `statistic` as defined above, ``mn`` is the mean of the
    distribution under the null hypothesis, ``d`` is a continuity
    correction, and ``se`` is the standard error.
    When ``method != 'asymptotic'``, this attribute is not available.

See Also
--------

:func:`kruskal`, :func:`mannwhitneyu`
    ..

Notes
-----
In the following, let ``d`` represent the difference between the paired
samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or ``d = x``
otherwise. Assume that all elements of ``d`` are independent and
identically distributed observations, and all are distinct and nonzero.

- When ``len(d)`` is sufficiently large, the null distribution of the
  normalized test statistic (`zstatistic` above) is approximately normal,
  and ``method = 'asymptotic'`` can be used to compute the p-value.

- When ``len(d)`` is small, the normal approximation may not be accurate,
  and ``method='exact'`` is preferred (at the cost of additional
  execution time).

- The default, ``method='auto'``, selects between the two:
  ``method='exact'`` is used when ``len(d) <= 50``, and
  ``method='asymptotic'`` is used otherwise.

The presence of "ties" (i.e. not all elements of ``d`` are unique) or
"zeros" (i.e. elements of ``d`` are zero) changes the null distribution
of the test statistic, and ``method='exact'`` no longer calculates
the exact p-value. If ``method='asymptotic'``, the z-statistic is adjusted
for more accurate comparison against the standard normal, but still,
for finite sample sizes, the standard normal is only an approximation of
the true null distribution of the z-statistic. For such situations, the
`method` parameter also accepts instances of `PermutationMethod`. In this
case, the p-value is computed using `permutation_test` with the provided
configuration options and other appropriate settings.

The presence of ties and zeros affects the resolution of ``method='auto'``
accordingly: exhasutive permutations are performed when ``len(d) <= 13``,
and the asymptotic method is used otherwise. Note that they asymptotic
method may not be very accurate even for ``len(d) > 14``; the threshold
was chosen as a compromise between execution time and accuracy under the
constraint that the results must be deterministic. Consider providing an
instance of `PermutationMethod` method manually, choosing the
``n_resamples`` parameter to balance time constraints and accuracy
requirements.

Please also note that in the edge case that all elements of ``d`` are zero,
the p-value relying on the normal approximaton cannot be computed (NaN)
if ``zero_method='wilcox'`` or ``zero_method='pratt'``.

Beginning in SciPy 1.9, ``np.matrix`` inputs (not recommended for new
code) are converted to ``np.ndarray`` before the calculation is performed. In
this case, the output will be a scalar or ``np.ndarray`` of appropriate shape
rather than a 2D ``np.matrix``. Similarly, while masked elements of masked
arrays are ignored, the output will be a scalar or ``np.ndarray`` rather than a
masked array with ``mask=False``.

References
----------
.. [1] https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
.. [2] Conover, W.J., Practical Nonparametric Statistics, 1971.
.. [3] Pratt, J.W., Remarks on Zeros and Ties in the Wilcoxon Signed
   Rank Procedures, Journal of the American Statistical Association,
   Vol. 54, 1959, pp. 655-667. :doi:`10.1080/01621459.1959.10501526`
.. [4] Wilcoxon, F., Individual Comparisons by Ranking Methods,
   Biometrics Bulletin, Vol. 1, 1945, pp. 80-83. :doi:`10.2307/3001968`
.. [5] Cureton, E.E., The Normal Approximation to the Signed-Rank
   Sampling Distribution When Zero Differences are Present,
   Journal of the American Statistical Association, Vol. 62, 1967,
   pp. 1068-1069. :doi:`10.1080/01621459.1967.10500917`

Examples
--------
In [4]_, the differences in height between cross- and self-fertilized
corn plants is given as follows:

>>> d = [6, 8, 14, 16, 23, 24, 28, 29, 41, -48, 49, 56, 60, -67, 75]

Cross-fertilized plants appear to be higher. To test the null
hypothesis that there is no height difference, we can apply the
two-sided test:

>>> from scipy.stats import wilcoxon
>>> res = wilcoxon(d)
>>> res.statistic, res.pvalue
(24.0, 0.041259765625)

Hence, we would reject the null hypothesis at a confidence level of 5%,
concluding that there is a difference in height between the groups.
To confirm that the median of the differences can be assumed to be
positive, we use:

>>> res = wilcoxon(d, alternative='greater')
>>> res.statistic, res.pvalue
(96.0, 0.0206298828125)

This shows that the null hypothesis that the median is negative can be
rejected at a confidence level of 5% in favor of the alternative that
the median is greater than zero. The p-values above are exact. Using the
normal approximation gives very similar values:

>>> res = wilcoxon(d, method='asymptotic')
>>> res.statistic, res.pvalue
(24.0, 0.04088813291185591)

Note that the statistic changed to 96 in the one-sided case (the sum
of ranks of positive differences) whereas it is 24 in the two-sided
case (the minimum of sum of ranks above and below zero).

In the example above, the differences in height between paired plants are
provided to `wilcoxon` directly. Alternatively, `wilcoxon` accepts two
samples of equal length, calculates the differences between paired
elements, then performs the test. Consider the samples ``x`` and ``y``:

>>> import numpy as np
>>> x = np.array([0.5, 0.825, 0.375, 0.5])
>>> y = np.array([0.525, 0.775, 0.325, 0.55])
>>> res = wilcoxon(x, y, alternative='greater')
>>> res
WilcoxonResult(statistic=5.0, pvalue=0.5625)

Note that had we calculated the differences by hand, the test would have
produced different results:

>>> d = [-0.025, 0.05, 0.05, -0.05]
>>> ref = wilcoxon(d, alternative='greater')
>>> ref
WilcoxonResult(statistic=6.0, pvalue=0.5)

The substantial difference is due to roundoff error in the results of
``x-y``:

>>> d - (x-y)
array([2.08166817e-17, 6.93889390e-17, 1.38777878e-17, 4.16333634e-17])

Even though we expected all the elements of ``(x-y)[1:]`` to have the same
magnitude ``0.05``, they have slightly different magnitudes in practice,
and therefore are assigned different ranks in the test. Before performing
the test, consider calculating ``d`` and adjusting it as necessary to
ensure that theoretically identically values are not numerically distinct.
For example:

>>> d2 = np.around(x - y, decimals=3)
>>> wilcoxon(d2, alternative='greater')
WilcoxonResult(statistic=6.0, pvalue=0.5)
================================================================================

wishart:
Firma: (df=None, scale=None, seed=None)

Docstring:
A Wishart random variable.

The `df` keyword specifies the degrees of freedom. The `scale` keyword
specifies the scale matrix, which must be symmetric and positive definite.
In this context, the scale matrix is often interpreted in terms of a
multivariate normal precision matrix (the inverse of the covariance
matrix). These arguments must satisfy the relationship
``df > scale.ndim - 1``, but see notes on using the `rvs` method with
``df < scale.ndim``.

Methods
-------
pdf(x, df, scale)
    Probability density function.
logpdf(x, df, scale)
    Log of the probability density function.
rvs(df, scale, size=1, random_state=None)
    Draw random samples from a Wishart distribution.
entropy()
    Compute the differential entropy of the Wishart distribution.

Parameters
----------
df : int
    Degrees of freedom, must be greater than or equal to dimension of the
    scale matrix
scale : array_like
    Symmetric positive definite scale matrix of the distribution
seed : {None, int, np.random.RandomState, np.random.Generator}, optional
    Used for drawing random variates.
    If `seed` is `None`, the `~np.random.RandomState` singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used, seeded
    with seed.
    If `seed` is already a ``RandomState`` or ``Generator`` instance,
    then that object is used.
    Default is `None`.

Raises
------
scipy.linalg.LinAlgError
    If the scale matrix `scale` is not positive definite.

See Also
--------
invwishart, chi2

Notes
-----


The scale matrix `scale` must be a symmetric positive definite
matrix. Singular matrices, including the symmetric positive semi-definite
case, are not supported. Symmetry is not checked; only the lower triangular
portion is used.

The Wishart distribution is often denoted

.. math::

    W_p(\nu, \Sigma)

where :math:`\nu` is the degrees of freedom and :math:`\Sigma` is the
:math:`p \times p` scale matrix.

The probability density function for `wishart` has support over positive
definite matrices :math:`S`; if :math:`S \sim W_p(\nu, \Sigma)`, then
its PDF is given by:

.. math::

    f(S) = \frac{|S|^{\frac{\nu - p - 1}{2}}}{2^{ \frac{\nu p}{2} }
           |\Sigma|^\frac{\nu}{2} \Gamma_p \left ( \frac{\nu}{2} \right )}
           \exp\left( -tr(\Sigma^{-1} S) / 2 \right)

If :math:`S \sim W_p(\nu, \Sigma)` (Wishart) then
:math:`S^{-1} \sim W_p^{-1}(\nu, \Sigma^{-1})` (inverse Wishart).

If the scale matrix is 1-dimensional and equal to one, then the Wishart
distribution :math:`W_1(\nu, 1)` collapses to the :math:`\chi^2(\nu)`
distribution.

The algorithm [2]_ implemented by the `rvs` method may
produce numerically singular matrices with :math:`p - 1 < \nu < p`; the
user may wish to check for this condition and generate replacement samples
as necessary.


.. versionadded:: 0.16.0

References
----------
.. [1] M.L. Eaton, "Multivariate Statistics: A Vector Space Approach",
       Wiley, 1983.
.. [2] W.B. Smith and R.R. Hocking, "Algorithm AS 53: Wishart Variate
       Generator", Applied Statistics, vol. 21, pp. 341-345, 1972.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import wishart, chi2
>>> x = np.linspace(1e-5, 8, 100)
>>> w = wishart.pdf(x, df=3, scale=1); w[:5]
array([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])
>>> c = chi2.pdf(x, 3); c[:5]
array([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])
>>> plt.plot(x, w)
>>> plt.show()

The input quantiles can be any shape of array, as long as the last
axis labels the components.

Alternatively, the object may be called (as a function) to fix the degrees
of freedom and scale parameters, returning a "frozen" Wishart random
variable:

>>> rv = wishart(df=1, scale=1)
>>> # Frozen object with the same methods but holding the given
>>> # degrees of freedom and scale fixed.
================================================================================

wrapcauchy:
Firma: (*args, **kwds)

Docstring:
A wrapped Cauchy continuous random variable.

As an instance of the `rv_continuous` class, `wrapcauchy` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(c, loc=0, scale=1, size=1, random_state=None)
    Random variates.
pdf(x, c, loc=0, scale=1)
    Probability density function.
logpdf(x, c, loc=0, scale=1)
    Log of the probability density function.
cdf(x, c, loc=0, scale=1)
    Cumulative distribution function.
logcdf(x, c, loc=0, scale=1)
    Log of the cumulative distribution function.
sf(x, c, loc=0, scale=1)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(x, c, loc=0, scale=1)
    Log of the survival function.
ppf(q, c, loc=0, scale=1)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, c, loc=0, scale=1)
    Inverse survival function (inverse of ``sf``).
moment(order, c, loc=0, scale=1)
    Non-central moment of the specified order.
stats(c, loc=0, scale=1, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(c, loc=0, scale=1)
    (Differential) entropy of the RV.
fit(data)
    Parameter estimates for generic data.
    See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the
    keyword arguments.
expect(func, args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
    Expected value of a function (of one argument) with respect to the distribution.
median(c, loc=0, scale=1)
    Median of the distribution.
mean(c, loc=0, scale=1)
    Mean of the distribution.
var(c, loc=0, scale=1)
    Variance of the distribution.
std(c, loc=0, scale=1)
    Standard deviation of the distribution.
interval(confidence, c, loc=0, scale=1)
    Confidence interval with equal areas around the median.

Notes
-----
The probability density function for `wrapcauchy` is:

.. math::

    f(x, c) = \frac{1-c^2}{2\pi (1+c^2 - 2c \cos(x))}

for :math:`0 \le x \le 2\pi`, :math:`0 < c < 1`.

`wrapcauchy` takes ``c`` as a shape parameter for :math:`c`.

The probability density above is defined in the "standardized" form. To shift
and/or scale the distribution use the ``loc`` and ``scale`` parameters.
Specifically, ``wrapcauchy.pdf(x, c, loc, scale)`` is identically
equivalent to ``wrapcauchy.pdf(y, c) / scale`` with
``y = (x - loc) / scale``. Note that shifting the location of a distribution
does not make it a "noncentral" distribution; noncentral generalizations of
some distributions are available in separate classes.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import wrapcauchy
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> c = 0.0311
>>> mean, var, skew, kurt = wrapcauchy.stats(c, moments='mvsk')

Display the probability density function (``pdf``):

>>> x = np.linspace(wrapcauchy.ppf(0.01, c),
...                 wrapcauchy.ppf(0.99, c), 100)
>>> ax.plot(x, wrapcauchy.pdf(x, c),
...        'r-', lw=5, alpha=0.6, label='wrapcauchy pdf')

Alternatively, the distribution object can be called (as a function)
to fix the shape, location and scale parameters. This returns a "frozen"
RV object holding the given parameters fixed.

Freeze the distribution and display the frozen ``pdf``:

>>> rv = wrapcauchy(c)
>>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')

Check accuracy of ``cdf`` and ``ppf``:

>>> vals = wrapcauchy.ppf([0.001, 0.5, 0.999], c)
>>> np.allclose([0.001, 0.5, 0.999], wrapcauchy.cdf(vals, c))
True

Generate random numbers:

>>> r = wrapcauchy.rvs(c, size=1000)

And compare the histogram:

>>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)
>>> ax.set_xlim([x[0], x[-1]])
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()
================================================================================

yeojohnson:
Firma: (x, lmbda=None)

Docstring:
Return a dataset transformed by a Yeo-Johnson power transformation.

Parameters
----------
x : ndarray
    Input array.  Should be 1-dimensional.
lmbda : float, optional
    If ``lmbda`` is ``None``, find the lambda that maximizes the
    log-likelihood function and return it as the second output argument.
    Otherwise the transformation is done for the given value.

Returns
-------
yeojohnson: ndarray
    Yeo-Johnson power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the lambda that maximizes the log-likelihood function.

See Also
--------
probplot, yeojohnson_normplot, yeojohnson_normmax, yeojohnson_llf, boxcox

Notes
-----
The Yeo-Johnson transform is given by::

    y = ((x + 1)**lmbda - 1) / lmbda,                for x >= 0, lmbda != 0
        log(x + 1),                                  for x >= 0, lmbda = 0
        -((-x + 1)**(2 - lmbda) - 1) / (2 - lmbda),  for x < 0, lmbda != 2
        -log(-x + 1),                                for x < 0, lmbda = 2

Unlike `boxcox`, `yeojohnson` does not require the input data to be
positive.

.. versionadded:: 1.2.0


References
----------
I. Yeo and R.A. Johnson, "A New Family of Power Transformations to
Improve Normality or Symmetry", Biometrika 87.4 (2000):


Examples
--------
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

>>> fig = plt.figure()
>>> ax1 = fig.add_subplot(211)
>>> x = stats.loggamma.rvs(5, size=500) + 5
>>> prob = stats.probplot(x, dist=stats.norm, plot=ax1)
>>> ax1.set_xlabel('')
>>> ax1.set_title('Probplot against normal distribution')

We now use `yeojohnson` to transform the data so it's closest to normal:

>>> ax2 = fig.add_subplot(212)
>>> xt, lmbda = stats.yeojohnson(x)
>>> prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
>>> ax2.set_title('Probplot after Yeo-Johnson transformation')

>>> plt.show()
================================================================================

yeojohnson_llf:
Firma: (lmb, data)

Docstring:
The yeojohnson log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Yeo-Johnson transformation. See `yeojohnson` for
    details.
data : array_like
    Data to calculate Yeo-Johnson log-likelihood for. If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float
    Yeo-Johnson log-likelihood of `data` given `lmb`.

See Also
--------
yeojohnson, probplot, yeojohnson_normplot, yeojohnson_normmax

Notes
-----
The Yeo-Johnson log-likelihood function is defined here as

.. math::

    llf = -N/2 \log(\hat{\sigma}^2) + (\lambda - 1)
          \sum_i \text{ sign }(x_i)\log(|x_i| + 1)

where :math:`\hat{\sigma}^2` is estimated variance of the Yeo-Johnson
transformed input data ``x``.

.. versionadded:: 1.2.0

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Yeo-Johnson log-likelihood
values for them for a range of ``lmbda`` values:

>>> x = stats.loggamma.rvs(5, loc=10, size=1000)
>>> lmbdas = np.linspace(-2, 10)
>>> llf = np.zeros(lmbdas.shape, dtype=float)
>>> for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.yeojohnson_llf(lmbda, x)

Also find the optimal lmbda value with `yeojohnson`:

>>> x_most_normal, lmbda_optimal = stats.yeojohnson(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(lmbdas, llf, 'b.-')
>>> ax.axhline(stats.yeojohnson_llf(lmbda_optimal, x), color='r')
>>> ax.set_xlabel('lmbda parameter')
>>> ax.set_ylabel('Yeo-Johnson log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `yeojohnson` looks closest to normal:

>>> locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
>>> for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.yeojohnson(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

>>> plt.show()
================================================================================

yeojohnson_normmax:
Firma: (x, brack=None)

Docstring:
Compute optimal Yeo-Johnson transform parameter.

Compute optimal Yeo-Johnson transform parameter for input data, using
maximum likelihood estimation.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional
    The starting interval for a downhill bracket search with
    `optimize.brent`. Note that this is in most cases not critical; the
    final result is allowed to be outside this bracket. If None,
    `optimize.fminbound` is used with bounds that avoid overflow.

Returns
-------
maxlog : float
    The optimal transform parameter found.

See Also
--------
yeojohnson, yeojohnson_llf, yeojohnson_normplot

Notes
-----
.. versionadded:: 1.2.0

Examples
--------
>>> import numpy as np
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

Generate some data and determine optimal ``lmbda``

>>> rng = np.random.default_rng()
>>> x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
>>> lmax = stats.yeojohnson_normmax(x)

>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> prob = stats.yeojohnson_normplot(x, -10, 10, plot=ax)
>>> ax.axvline(lmax, color='r')

>>> plt.show()
================================================================================

yeojohnson_normplot:
Firma: (x, la, lb, plot=None, N=80)

Docstring:
Compute parameters for a Yeo-Johnson normality plot, optionally show it.

A Yeo-Johnson normality plot shows graphically what the best
transformation parameter is to use in `yeojohnson` to obtain a
distribution that is close to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to
    `yeojohnson` for Yeo-Johnson transformations. These are also the
    limits of the horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Yeo-Johnson transform was done.
ppcc : ndarray
    Probability Plot Correlation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, yeojohnson, yeojohnson_normmax, yeojohnson_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

.. versionadded:: 1.2.0

Examples
--------
>>> from scipy import stats
>>> import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Yeo-Johnson plot:

>>> x = stats.loggamma.rvs(5, size=500) + 5
>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> prob = stats.yeojohnson_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

>>> _, maxlog = stats.yeojohnson(x)
>>> ax.axvline(maxlog, color='r')

>>> plt.show()
================================================================================

yulesimon:
Firma: (*args, **kwds)

Docstring:
A Yule-Simon discrete random variable.

As an instance of the `rv_discrete` class, `yulesimon` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(alpha, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, alpha, loc=0)
    Probability mass function.
logpmf(k, alpha, loc=0)
    Log of the probability mass function.
cdf(k, alpha, loc=0)
    Cumulative distribution function.
logcdf(k, alpha, loc=0)
    Log of the cumulative distribution function.
sf(k, alpha, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, alpha, loc=0)
    Log of the survival function.
ppf(q, alpha, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, alpha, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(alpha, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(alpha, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(alpha,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(alpha, loc=0)
    Median of the distribution.
mean(alpha, loc=0)
    Mean of the distribution.
var(alpha, loc=0)
    Variance of the distribution.
std(alpha, loc=0)
    Standard deviation of the distribution.
interval(confidence, alpha, loc=0)
    Confidence interval with equal areas around the median.

Notes
-----

The probability mass function for the `yulesimon` is:

.. math::

    f(k) =  \alpha B(k, \alpha+1)

for :math:`k=1,2,3,...`, where :math:`\alpha>0`.
Here :math:`B` refers to the `scipy.special.beta` function.

The sampling of random variates is based on pg 553, Section 6.3 of [1]_.
Our notation maps to the referenced logic via :math:`\alpha=a-1`.

For details see the wikipedia entry [2]_.

References
----------
.. [1] Devroye, Luc. "Non-uniform Random Variate Generation",
     (1986) Springer, New York.

.. [2] https://en.wikipedia.org/wiki/Yule-Simon_distribution

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``yulesimon.pmf(k, alpha, loc)`` is identically
equivalent to ``yulesimon.pmf(k - loc, alpha)``.

Examples
--------
>>> import numpy as np
>>> from scipy.stats import yulesimon
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> alpha = 11
>>> mean, var, skew, kurt = yulesimon.stats(alpha, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(yulesimon.ppf(0.01, alpha),
...               yulesimon.ppf(0.99, alpha))
>>> ax.plot(x, yulesimon.pmf(x, alpha), 'bo', ms=8, label='yulesimon pmf')
>>> ax.vlines(x, 0, yulesimon.pmf(x, alpha), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = yulesimon(alpha)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = yulesimon.cdf(x, alpha)
>>> np.allclose(x, yulesimon.ppf(prob, alpha))
True

Generate random numbers:

>>> r = yulesimon.rvs(alpha, size=1000)
================================================================================

zipf:
Firma: (*args, **kwds)

Docstring:
A Zipf (Zeta) discrete random variable.

As an instance of the `rv_discrete` class, `zipf` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, a, loc=0)
    Probability mass function.
logpmf(k, a, loc=0)
    Log of the probability mass function.
cdf(k, a, loc=0)
    Cumulative distribution function.
logcdf(k, a, loc=0)
    Log of the cumulative distribution function.
sf(k, a, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, a, loc=0)
    Log of the survival function.
ppf(q, a, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(a, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(a,), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, loc=0)
    Median of the distribution.
mean(a, loc=0)
    Mean of the distribution.
var(a, loc=0)
    Variance of the distribution.
std(a, loc=0)
    Standard deviation of the distribution.
interval(confidence, a, loc=0)
    Confidence interval with equal areas around the median.

See Also
--------
zipfian

Notes
-----
The probability mass function for `zipf` is:

.. math::

    f(k, a) = \frac{1}{\zeta(a) k^a}

for :math:`k \ge 1`, :math:`a > 1`.

`zipf` takes :math:`a > 1` as shape parameter. :math:`\zeta` is the
Riemann zeta function (`scipy.special.zeta`)

The Zipf distribution is also known as the zeta distribution, which is
a special case of the Zipfian distribution (`zipfian`).

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``zipf.pmf(k, a, loc)`` is identically
equivalent to ``zipf.pmf(k - loc, a)``.

References
----------
.. [1] "Zeta Distribution", Wikipedia,
       https://en.wikipedia.org/wiki/Zeta_distribution

Examples
--------
>>> import numpy as np
>>> from scipy.stats import zipf
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a = 6.6
>>> mean, var, skew, kurt = zipf.stats(a, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(zipf.ppf(0.01, a),
...               zipf.ppf(0.99, a))
>>> ax.plot(x, zipf.pmf(x, a), 'bo', ms=8, label='zipf pmf')
>>> ax.vlines(x, 0, zipf.pmf(x, a), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = zipf(a)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = zipf.cdf(x, a)
>>> np.allclose(x, zipf.ppf(prob, a))
True

Generate random numbers:

>>> r = zipf.rvs(a, size=1000)

Confirm that `zipf` is the large `n` limit of `zipfian`.

>>> import numpy as np
>>> from scipy.stats import zipf, zipfian
>>> k = np.arange(11)
>>> np.allclose(zipf.pmf(k, a), zipfian.pmf(k, a, n=10000000))
True
================================================================================

zipfian:
Firma: (*args, **kwds)

Docstring:
A Zipfian discrete random variable.

As an instance of the `rv_discrete` class, `zipfian` object inherits from it
a collection of generic methods (see below for the full list),
and completes them with details specific for this particular distribution.

Methods
-------
rvs(a, n, loc=0, size=1, random_state=None)
    Random variates.
pmf(k, a, n, loc=0)
    Probability mass function.
logpmf(k, a, n, loc=0)
    Log of the probability mass function.
cdf(k, a, n, loc=0)
    Cumulative distribution function.
logcdf(k, a, n, loc=0)
    Log of the cumulative distribution function.
sf(k, a, n, loc=0)
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
logsf(k, a, n, loc=0)
    Log of the survival function.
ppf(q, a, n, loc=0)
    Percent point function (inverse of ``cdf`` --- percentiles).
isf(q, a, n, loc=0)
    Inverse survival function (inverse of ``sf``).
stats(a, n, loc=0, moments='mv')
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').
entropy(a, n, loc=0)
    (Differential) entropy of the RV.
expect(func, args=(a, n), loc=0, lb=None, ub=None, conditional=False)
    Expected value of a function (of one argument) with respect to the distribution.
median(a, n, loc=0)
    Median of the distribution.
mean(a, n, loc=0)
    Mean of the distribution.
var(a, n, loc=0)
    Variance of the distribution.
std(a, n, loc=0)
    Standard deviation of the distribution.
interval(confidence, a, n, loc=0)
    Confidence interval with equal areas around the median.

See Also
--------
zipf

Notes
-----
The probability mass function for `zipfian` is:

.. math::

    f(k, a, n) = \frac{1}{H_{n,a} k^a}

for :math:`k \in \{1, 2, \dots, n-1, n\}`, :math:`a \ge 0`,
:math:`n \in \{1, 2, 3, \dots\}`.

`zipfian` takes :math:`a` and :math:`n` as shape parameters.
:math:`H_{n,a}` is the :math:`n`:sup:`th` generalized harmonic
number of order :math:`a`.

The Zipfian distribution reduces to the Zipf (zeta) distribution as
:math:`n \rightarrow \infty`.

The probability mass function above is defined in the "standardized" form.
To shift distribution use the ``loc`` parameter.
Specifically, ``zipfian.pmf(k, a, n, loc)`` is identically
equivalent to ``zipfian.pmf(k - loc, a, n)``.

References
----------
.. [1] "Zipf's Law", Wikipedia, https://en.wikipedia.org/wiki/Zipf's_law
.. [2] Larry Leemis, "Zipf Distribution", Univariate Distribution
       Relationships. http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Zipf.pdf

Examples
--------
>>> import numpy as np
>>> from scipy.stats import zipfian
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots(1, 1)

Calculate the first four moments:

>>> a, n = 1.25, 10
>>> mean, var, skew, kurt = zipfian.stats(a, n, moments='mvsk')

Display the probability mass function (``pmf``):

>>> x = np.arange(zipfian.ppf(0.01, a, n),
...               zipfian.ppf(0.99, a, n))
>>> ax.plot(x, zipfian.pmf(x, a, n), 'bo', ms=8, label='zipfian pmf')
>>> ax.vlines(x, 0, zipfian.pmf(x, a, n), colors='b', lw=5, alpha=0.5)

Alternatively, the distribution object can be called (as a function)
to fix the shape and location. This returns a "frozen" RV object holding
the given parameters fixed.

Freeze the distribution and display the frozen ``pmf``:

>>> rv = zipfian(a, n)
>>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1,
...         label='frozen pmf')
>>> ax.legend(loc='best', frameon=False)
>>> plt.show()

Check accuracy of ``cdf`` and ``ppf``:

>>> prob = zipfian.cdf(x, a, n)
>>> np.allclose(x, zipfian.ppf(prob, a, n))
True

Generate random numbers:

>>> r = zipfian.rvs(a, n, size=1000)

Confirm that `zipfian` reduces to `zipf` for large `n`, ``a > 1``.

>>> import numpy as np
>>> from scipy.stats import zipf, zipfian
>>> k = np.arange(11)
>>> np.allclose(zipfian.pmf(k, a=3.5, n=10000000), zipf.pmf(k, a=3.5))
True
================================================================================

zmap:
Firma: (scores, compare, axis=0, ddof=0, nan_policy='propagate')

Docstring:
Calculate the relative z-scores.

Return an array of z-scores, i.e., scores that are standardized to
zero mean and unit variance, where mean and variance are calculated
from the comparison array.

Parameters
----------
scores : array_like
    The input for which z-scores are calculated.
compare : array_like
    The input from which the mean and standard deviation of the
    normalization are taken; assumed to have the same dimension as
    `scores`.
axis : int or None, optional
    Axis over which mean and variance of `compare` are calculated.
    Default is 0. If None, compute over the whole array `scores`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle the occurrence of nans in `compare`.
    'propagate' returns nan, 'raise' raises an exception, 'omit'
    performs the calculations ignoring nan values. Default is
    'propagate'. Note that when the value is 'omit', nans in `scores`
    also propagate to the output, but they do not affect the z-scores
    computed for the non-nan values.

Returns
-------
zscore : array_like
    Z-scores, in the same shape as `scores`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of
`asarray` for parameters).

Examples
--------
>>> from scipy.stats import zmap
>>> a = [0.5, 2.0, 2.5, 3]
>>> b = [0, 1, 2, 3, 4]
>>> zmap(a, b)
array([-1.06066017,  0.        ,  0.35355339,  0.70710678])
================================================================================

zscore:
Firma: (a, axis=0, ddof=0, nan_policy='propagate')

Docstring:
Compute the z score.

Compute the z score of each value in the sample, relative to the
sample mean and standard deviation.

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.  Note that when the value is 'omit',
    nans in the input also propagate to the output, but they do not affect
    the z-scores computed for the non-nan values.

Returns
-------
zscore : array_like
    The z-scores, standardized by mean and standard deviation of
    input array `a`.

See Also
--------
numpy.mean : Arithmetic average
numpy.std : Arithmetic standard deviation
scipy.stats.gzscore : Geometric standard score

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of
`asarray` for parameters).

References
----------
.. [1] "Standard score", *Wikipedia*,
       https://en.wikipedia.org/wiki/Standard_score.
.. [2] Huck, S. W., Cross, T. L., Clark, S. B, "Overcoming misconceptions
       about Z-scores", Teaching Statistics, vol. 8, pp. 38-40, 1986

Examples
--------
>>> import numpy as np
>>> a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,
...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])
>>> from scipy import stats
>>> stats.zscore(a)
array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
        0.6748, -1.1488, -1.3324])

Computing along a specified axis, using n-1 degrees of freedom
(``ddof=1``) to calculate the standard deviation:

>>> b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
...               [ 0.7149,  0.0775,  0.6072,  0.9656],
...               [ 0.6341,  0.1403,  0.9759,  0.4064],
...               [ 0.5918,  0.6948,  0.904 ,  0.3721],
...               [ 0.0921,  0.2481,  0.1188,  0.1366]])
>>> stats.zscore(b, axis=1, ddof=1)
array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
       [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
       [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
       [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
       [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])

An example with ``nan_policy='omit'``:

>>> x = np.array([[25.11, 30.10, np.nan, 32.02, 43.15],
...               [14.95, 16.06, 121.25, 94.35, 29.81]])
>>> stats.zscore(x, axis=1, nan_policy='omit')
array([[-1.13490897, -0.37830299,         nan, -0.08718406,  1.60039602],
       [-0.91611681, -0.89090508,  1.4983032 ,  0.88731639, -0.5785977 ]])
================================================================================
